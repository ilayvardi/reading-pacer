<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Reading Pacer</title>
  <!-- PDF.js for browser-based PDF processing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <style>
    * { box-sizing: border-box; }

    :root {
      /* Default: Sweet Mars */
      --bg-primary: #1a1a2e;
      --bg-secondary: #252540;
      --bg-tertiary: #151525;
      --text-primary: #eee;
      --text-secondary: #aaa;
      --text-muted: #888;
      --accent: #0a84ff;
      --accent-hover: #0070e0;
      --border: #3a3a5c;
      --btn-bg: #3a3a5c;
      --btn-hover: #4a4a6c;
      --highlight-read: rgba(100, 200, 100, 0.25);
      --highlight-current: rgba(255, 200, 0, 0.5);
      --highlight-current-border: rgba(255, 180, 0, 0.8);
    }

    /* Catppuccin Mocha */
    .theme-catppuccin {
      --bg-primary: #1e1e2e;
      --bg-secondary: #313244;
      --bg-tertiary: #181825;
      --text-primary: #cdd6f4;
      --text-secondary: #bac2de;
      --text-muted: #6c7086;
      --accent: #89b4fa;
      --accent-hover: #74a8f7;
      --border: #45475a;
      --btn-bg: #45475a;
      --btn-hover: #585b70;
      --highlight-read: rgba(166, 227, 161, 0.25);
      --highlight-current: rgba(249, 226, 175, 0.5);
      --highlight-current-border: rgba(249, 226, 175, 0.8);
    }

    /* Dracula */
    .theme-dracula {
      --bg-primary: #282a36;
      --bg-secondary: #44475a;
      --bg-tertiary: #21222c;
      --text-primary: #f8f8f2;
      --text-secondary: #d4d4d4;
      --text-muted: #6272a4;
      --accent: #bd93f9;
      --accent-hover: #a77bf3;
      --border: #44475a;
      --btn-bg: #44475a;
      --btn-hover: #6272a4;
      --highlight-read: rgba(80, 250, 123, 0.25);
      --highlight-current: rgba(255, 121, 198, 0.4);
      --highlight-current-border: rgba(255, 121, 198, 0.8);
    }

    /* Nord */
    .theme-nord {
      --bg-primary: #2e3440;
      --bg-secondary: #3b4252;
      --bg-tertiary: #272c36;
      --text-primary: #eceff4;
      --text-secondary: #d8dee9;
      --text-muted: #4c566a;
      --accent: #88c0d0;
      --accent-hover: #8fbcbb;
      --border: #4c566a;
      --btn-bg: #4c566a;
      --btn-hover: #5e6779;
      --highlight-read: rgba(163, 190, 140, 0.25);
      --highlight-current: rgba(235, 203, 139, 0.4);
      --highlight-current-border: rgba(235, 203, 139, 0.8);
    }

    /* Gruvbox Dark */
    .theme-gruvbox {
      --bg-primary: #282828;
      --bg-secondary: #3c3836;
      --bg-tertiary: #1d2021;
      --text-primary: #ebdbb2;
      --text-secondary: #d5c4a1;
      --text-muted: #665c54;
      --accent: #fe8019;
      --accent-hover: #d65d0e;
      --border: #504945;
      --btn-bg: #504945;
      --btn-hover: #665c54;
      --highlight-read: rgba(184, 187, 38, 0.25);
      --highlight-current: rgba(250, 189, 47, 0.4);
      --highlight-current-border: rgba(250, 189, 47, 0.8);
    }

    /* Tokyo Night */
    .theme-tokyo {
      --bg-primary: #1a1b26;
      --bg-secondary: #24283b;
      --bg-tertiary: #16161e;
      --text-primary: #c0caf5;
      --text-secondary: #a9b1d6;
      --text-muted: #565f89;
      --accent: #7aa2f7;
      --accent-hover: #5d87e8;
      --border: #3b4261;
      --btn-bg: #3b4261;
      --btn-hover: #4a5274;
      --highlight-read: rgba(158, 206, 106, 0.25);
      --highlight-current: rgba(224, 175, 104, 0.4);
      --highlight-current-border: rgba(224, 175, 104, 0.8);
    }

    /* Solarized Dark */
    .theme-solarized {
      --bg-primary: #002b36;
      --bg-secondary: #073642;
      --bg-tertiary: #00212b;
      --text-primary: #93a1a1;
      --text-secondary: #839496;
      --text-muted: #586e75;
      --accent: #268bd2;
      --accent-hover: #1a6fa3;
      --border: #094959;
      --btn-bg: #094959;
      --btn-hover: #0a5a6b;
      --highlight-read: rgba(133, 153, 0, 0.3);
      --highlight-current: rgba(181, 137, 0, 0.4);
      --highlight-current-border: rgba(181, 137, 0, 0.8);
    }

    /* ===== LIGHT THEMES ===== */

    /* Classic Light */
    .theme-light {
      --bg-primary: #ffffff;
      --bg-secondary: #f5f5f5;
      --bg-tertiary: #e8e8e8;
      --text-primary: #1a1a1a;
      --text-secondary: #4a4a4a;
      --text-muted: #888888;
      --accent: #0066cc;
      --accent-hover: #0052a3;
      --border: #d0d0d0;
      --btn-bg: #e0e0e0;
      --btn-hover: #d0d0d0;
      --highlight-read: rgba(100, 180, 100, 0.2);
      --highlight-current: rgba(255, 200, 50, 0.5);
      --highlight-current-border: rgba(230, 160, 0, 0.8);
    }

    /* Solarized Light */
    .theme-solarized-light {
      --bg-primary: #fdf6e3;
      --bg-secondary: #eee8d5;
      --bg-tertiary: #f5efdc;
      --text-primary: #657b83;
      --text-secondary: #586e75;
      --text-muted: #93a1a1;
      --accent: #268bd2;
      --accent-hover: #1a6fa3;
      --border: #d3cbb7;
      --btn-bg: #eee8d5;
      --btn-hover: #ddd6c3;
      --highlight-read: rgba(133, 153, 0, 0.2);
      --highlight-current: rgba(181, 137, 0, 0.35);
      --highlight-current-border: rgba(181, 137, 0, 0.7);
    }

    /* GitHub Light */
    .theme-github-light {
      --bg-primary: #ffffff;
      --bg-secondary: #f6f8fa;
      --bg-tertiary: #eaeef2;
      --text-primary: #24292f;
      --text-secondary: #57606a;
      --text-muted: #8b949e;
      --accent: #0969da;
      --accent-hover: #0550ae;
      --border: #d0d7de;
      --btn-bg: #f3f4f6;
      --btn-hover: #e5e7eb;
      --highlight-read: rgba(46, 160, 67, 0.2);
      --highlight-current: rgba(255, 200, 50, 0.45);
      --highlight-current-border: rgba(210, 150, 0, 0.8);
    }

    /* ===== DARK THEMES ===== */

    /* Pure Dark (OLED) */
    .theme-pure-dark {
      --bg-primary: #000000;
      --bg-secondary: #0d0d0d;
      --bg-tertiary: #000000;
      --text-primary: #e0e0e0;
      --text-secondary: #b0b0b0;
      --text-muted: #666666;
      --accent: #6eb5ff;
      --accent-hover: #4a9eff;
      --border: #222222;
      --btn-bg: #1a1a1a;
      --btn-hover: #2a2a2a;
      --highlight-read: rgba(100, 200, 100, 0.2);
      --highlight-current: rgba(255, 200, 0, 0.4);
      --highlight-current-border: rgba(255, 180, 0, 0.7);
    }

    /* One Dark */
    .theme-one-dark {
      --bg-primary: #282c34;
      --bg-secondary: #21252b;
      --bg-tertiary: #1e2227;
      --text-primary: #abb2bf;
      --text-secondary: #9da5b4;
      --text-muted: #636d83;
      --accent: #61afef;
      --accent-hover: #4d9fe0;
      --border: #3e4451;
      --btn-bg: #3e4451;
      --btn-hover: #4d5566;
      --highlight-read: rgba(152, 195, 121, 0.25);
      --highlight-current: rgba(229, 192, 123, 0.4);
      --highlight-current-border: rgba(229, 192, 123, 0.8);
    }

    /* Monokai Pro */
    .theme-monokai {
      --bg-primary: #2d2a2e;
      --bg-secondary: #403e41;
      --bg-tertiary: #221f22;
      --text-primary: #fcfcfa;
      --text-secondary: #c1c0c0;
      --text-muted: #727072;
      --accent: #ffd866;
      --accent-hover: #e6c25a;
      --border: #525053;
      --btn-bg: #403e41;
      --btn-hover: #525053;
      --highlight-read: rgba(169, 220, 118, 0.25);
      --highlight-current: rgba(255, 216, 102, 0.4);
      --highlight-current-border: rgba(255, 216, 102, 0.8);
    }

    /* Ayu Dark */
    .theme-ayu {
      --bg-primary: #0b0e14;
      --bg-secondary: #1f2430;
      --bg-tertiary: #0d1017;
      --text-primary: #bfbdb6;
      --text-secondary: #9c9a93;
      --text-muted: #565b66;
      --accent: #e6b450;
      --accent-hover: #d4a43e;
      --border: #2d3640;
      --btn-bg: #1f2430;
      --btn-hover: #2d3640;
      --highlight-read: rgba(170, 217, 76, 0.2);
      --highlight-current: rgba(230, 180, 80, 0.4);
      --highlight-current-border: rgba(230, 180, 80, 0.8);
    }

    /* Palenight */
    .theme-palenight {
      --bg-primary: #292d3e;
      --bg-secondary: #343b51;
      --bg-tertiary: #232635;
      --text-primary: #a6accd;
      --text-secondary: #959dcb;
      --text-muted: #676e95;
      --accent: #82aaff;
      --accent-hover: #6699ff;
      --border: #444b6a;
      --btn-bg: #343b51;
      --btn-hover: #444b6a;
      --highlight-read: rgba(195, 232, 141, 0.2);
      --highlight-current: rgba(255, 203, 107, 0.4);
      --highlight-current-border: rgba(255, 203, 107, 0.8);
    }

    /* Rosé Pine */
    .theme-rose-pine {
      --bg-primary: #191724;
      --bg-secondary: #1f1d2e;
      --bg-tertiary: #13111e;
      --text-primary: #e0def4;
      --text-secondary: #c4a7e7;
      --text-muted: #6e6a86;
      --accent: #ebbcba;
      --accent-hover: #e0a8a6;
      --border: #403d52;
      --btn-bg: #26233a;
      --btn-hover: #403d52;
      --highlight-read: rgba(156, 207, 216, 0.2);
      --highlight-current: rgba(246, 193, 119, 0.4);
      --highlight-current-border: rgba(246, 193, 119, 0.8);
    }

    /* Everforest Dark */
    .theme-everforest {
      --bg-primary: #2d353b;
      --bg-secondary: #3d484d;
      --bg-tertiary: #272e33;
      --text-primary: #d3c6aa;
      --text-secondary: #c5b992;
      --text-muted: #7a8478;
      --accent: #a7c080;
      --accent-hover: #93b571;
      --border: #4f5b58;
      --btn-bg: #3d484d;
      --btn-hover: #4f5b58;
      --highlight-read: rgba(167, 192, 128, 0.2);
      --highlight-current: rgba(219, 188, 127, 0.4);
      --highlight-current-border: rgba(219, 188, 127, 0.8);
    }

    /* Kanagawa */
    .theme-kanagawa {
      --bg-primary: #1f1f28;
      --bg-secondary: #2a2a37;
      --bg-tertiary: #16161d;
      --text-primary: #dcd7ba;
      --text-secondary: #c8c093;
      --text-muted: #727169;
      --accent: #7e9cd8;
      --accent-hover: #6a8bc9;
      --border: #3d3d50;
      --btn-bg: #2a2a37;
      --btn-hover: #3d3d50;
      --highlight-read: rgba(152, 187, 108, 0.2);
      --highlight-current: rgba(226, 194, 144, 0.4);
      --highlight-current-border: rgba(226, 194, 144, 0.8);
    }


    body {
      font-family: 'David', 'Noto Sans Hebrew', system-ui, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      margin: 0;
      padding: 20px;
      min-height: 100vh;
    }

    .container {
      max-width: 1400px;
      width: calc(100% - 80px);
      margin: 0 auto;
      transition: margin 0.3s ease;
    }

    h1 {
      text-align: center;
      color: var(--text-primary);
      margin-bottom: 20px;
    }

    /* Control Panel */
    .controls {
      background: var(--bg-secondary);
      padding: 16px 24px;
      border-radius: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      justify-content: center;
      margin-bottom: 20px;
      position: sticky;
      top: 10px;
      z-index: 100;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }

    button {
      background: var(--btn-bg);
      border: none;
      color: var(--text-primary);
      padding: 10px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 16px;
      transition: background 0.2s;
      user-select: none;
    }

    button:hover { background: var(--btn-hover); }
    button.active { background: var(--accent); }
    button.primary { background: var(--accent); }
    button.primary:hover { background: var(--accent-hover); }

    label {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--text-secondary);
    }

    input[type="number"], select {
      width: 70px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      color: var(--text-primary);
      padding: 8px;
      border-radius: 6px;
      font-size: 14px;
    }

    select {
      width: auto;
      cursor: pointer;
    }

    .progress {
      color: var(--text-muted);
      font-size: 14px;
      width: 200px;
      flex-shrink: 0;
      text-align: center;
      font-variant-numeric: tabular-nums;
    }

    .page-nav {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .page-nav select {
      width: auto;
      min-width: 100px;
    }

    .separator {
      color: var(--text-muted);
      margin: 0 4px;
    }

    /* Text Display */
    .text-display {
      background: transparent;
      padding: 15px 30px;
      padding-bottom: 220px; /* Space for bottom bar so end of page text stays visible */
      min-height: 400px;
      font-size: 22px;
      line-height: 2;
      direction: rtl;
      text-align: right;
    }

    .text-display.centered-block {
      max-width: 800px;
      margin: 0 auto;
    }

    .word {
      display: inline;
      cursor: pointer;
      padding: 0;
      margin: 0;
    }

    .word:hover {
      background: var(--btn-bg);
    }

    .highlight-read {
      background: var(--highlight-read);
      border-radius: 4px;
    }
    .highlight-continuous .highlight-read {
      border-top-left-radius: 0;
      border-bottom-left-radius: 0;
    }

    .highlight-current {
      background: var(--highlight-current);
      border-radius: 4px;
    }
    .highlight-continuous .highlight-current {
      border-top-right-radius: 0;
      border-bottom-right-radius: 0;
    }

    /* Half-bold mode (הדגשת חצי) - bold first letters of current chunk */
    .half-bold-prefix {
      font-weight: bold;
      color: var(--half-bold-color, inherit);
      font-size: var(--half-bold-font-size, 1em);
    }
    .half-bold-suffix {
      font-weight: normal;
    }

    /* Fake cursor at end of chunk */
    .fake-cursor {
      display: inline-block;
      width: 2px;
      height: 0.85em;
      background: var(--fake-cursor-color, #e0e0e0);
      margin: 0;
      vertical-align: middle;
      border-radius: 1px;
    }
    .fake-cursor.blink {
      animation: cursor-blink 0.8s ease-in-out infinite;
    }
    @keyframes cursor-blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }

    /* RSVP Mode - fixed center reading */
    .rsvp-overlay {
      display: none;
      position: fixed;
      top: 60px;
      left: 0;
      right: 0;
      bottom: 60px;
      background: var(--bg-primary);
      z-index: 50;
    }
    .rsvp-overlay.active {
      display: block;
    }
    body.rsvp-active #textDisplay {
      visibility: hidden;
    }
    .rsvp-content {
      display: block;
      width: 70%;
      margin-left: -2.5%;
      margin-right: auto;
      margin-top: 22.5%;
      padding-left: 25%;
      font-size: var(--rsvp-font-size, 2.5em);
      text-align: right;
      direction: rtl;
      line-height: 1.4;
    }
    .rsvp-content.orp-mode {
      position: relative;
      padding-left: 0;
      padding-right: 0;
      width: 100%;
      margin-left: 0;
      text-align: left;
      direction: ltr;
      height: 1.5em;
      pointer-events: none;
    }
    .orp-word {
      position: absolute;
      white-space: nowrap;
    }
    .orp-letter {
      color: #e74c3c;
    }
    /* Spritz redicle - horizontal lines with vertical center line */
    .rsvp-redicle {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 1;
    }
    .redicle-line-top,
    .redicle-line-bottom {
      position: absolute;
      left: 0;
      right: 0;
      height: 1px;
      background: var(--text-muted);
      opacity: 0.5;
    }
    .redicle-line-top {
      top: var(--redicle-top, 100px);
    }
    .redicle-line-bottom {
      top: var(--redicle-bottom, 150px);
    }
    .redicle-vertical-top,
    .redicle-vertical-bottom {
      position: absolute;
      left: var(--redicle-x, 50%);
      width: 2px;
      background: #e74c3c;
      transform: translateX(-50%);
    }
    .redicle-vertical-top {
      top: 0;
      height: calc(var(--redicle-top, 100px) + 12px);
    }
    .redicle-vertical-bottom {
      top: calc(var(--redicle-bottom, 150px) - 12px);
      bottom: 0;
    }
    .rsvp-progress {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.9em;
      color: var(--text-muted);
    }
    .rsvp-grid {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 1;
      opacity: var(--rsvp-grid-opacity, 0.15);
      font-size: var(--rsvp-font-size, 2.5em);
      background-image:
        linear-gradient(to right, var(--text-muted) 1px, transparent 1px),
        linear-gradient(to bottom, var(--text-muted) 1px, transparent 1px);
      background-size: 0.75em 1.4em;
      background-position: center calc(50% + 10px);
    }
    .rsvp-grid.hidden {
      display: none;
    }
    .rsvp-redicle.hidden {
      display: none;
    }
    .rsvp-hint {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.8em;
      color: var(--text-muted);
      opacity: 0.7;
    }

    /* Vertical Progress Bar */
    .progress-bar-container {
      position: fixed;
      right: 20px;
      top: 80px;
      bottom: 20%;
      width: 5px;
      background: var(--btn-bg);
      border-radius: 4px;
      opacity: 0;
      transition: opacity 0.3s ease, right 0.3s ease;
      z-index: 100;
    }
    .progress-bar-container.visible {
      opacity: 1;
    }
    /* Move left when figures panel is open */
    .progress-bar-container.figures-open {
      right: 1px;
    }
    .progress-bar-fill {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      background: var(--highlight-current-border);
      opacity: 0.5;
      border-radius: 4px;
      transition: height 0.2s ease;
    }
    .progress-bar-percent {
      position: absolute;
      left: 50%;
      transform: translateX(-50%) translateY(-50%);
      font-size: 11px;
      font-weight: bold;
      color: var(--text);
      background: var(--bg-secondary);
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.5);
      border: 2px solid var(--highlight-current-border);
      top: 0;
      transition: top 0.2s ease;
      cursor: grab;
      user-select: none;
    }
    .progress-bar-percent:active {
      cursor: grabbing;
    }
    .progress-bar-percent.dragging {
      transition: none;
    }

    /* Per-word pop animation (not in VN or sentence mode) */
    .text-display:not(.vn-mode):not(.sentence-mode) .word-pop {
      display: inline-block;
      transform-origin: center center;
      animation: word-pop var(--anim-speed, 0.15s) ease-out;
    }

    @keyframes word-pop {
      0% { transform: scale(1); opacity: 0; }
      50% { transform: scale(var(--pop-scale, 1.08)); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }

    /* VN Fade Mode - opacity based on sentence distance */
    .vn-mode .vn-fade-0 { opacity: 1; transition: opacity 0.5s ease; }
    .vn-mode .vn-fade-1 { opacity: 0.50; transition: opacity 0.5s ease; }
    .vn-mode .vn-fade-2 { opacity: 0.375; transition: opacity 0.5s ease; }
    .vn-mode .vn-fade-3 { opacity: 0.25; transition: opacity 0.5s ease; }
    .vn-mode .vn-fade-4 { opacity: 0.125; transition: opacity 0.5s ease; }
    .vn-mode .vn-fade-5 { opacity: 0; transition: opacity 0.5s ease; }
    .vn-mode .vn-fade-6 { opacity: 0; transition: opacity 0.5s ease; }
    .vn-mode .vn-fade-peek { opacity: 0.08; transition: opacity 0.5s ease; }

    /* VN Border - SVG overlay */
    #vnBorderSvg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1000;
    }
    #vnBorderPath {
      fill: none;
      stroke: var(--border-color, #e0e0e0);
      stroke-width: var(--border-width, 2);
      opacity: var(--border-opacity, 0.6);
      stroke-linejoin: round;
      stroke-linecap: round;
    }

    /* Current chunk fade-in animation */
    .vn-mode .vn-fade-in {
      animation: vnFadeIn 0.3s ease forwards;
    }

    @keyframes vnFadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .heading {
      font-weight: bold;
      text-decoration: underline;
      font-size: 1.3em;
    }

    .paragraph-break {
      display: block;
      height: var(--paragraph-spacing, 16px);
    }

    /* Top Bar */
    .top-bar {
      position: fixed;
      top: 0;
      left: 0;
      right: 1px;
      height: 50px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 16px;
      z-index: 1000;
    }

    .top-bar-left,
    .top-bar-right {
      display: flex;
      gap: 8px;
    }

    .top-bar-title {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      margin: 0;
      font-size: 22px;
      font-weight: 600;
      color: var(--text-primary);
      letter-spacing: 1px;
    }

    .top-btn {
      background: transparent;
      border: none;
      font-size: 20px;
      padding: 8px;
      cursor: pointer;
      border-radius: 8px;
      transition: background 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .top-btn:hover {
      background: var(--bg-tertiary);
    }

    /* Library Sidebar */
    .library-sidebar {
      position: fixed;
      top: 50px;
      left: 0;
      bottom: 0;
      width: 300px;
      background: var(--bg-secondary);
      border-right: 1px solid var(--border);
      transform: translateX(-100%);
      transition: transform 0.3s ease;
      z-index: 100;
      display: flex;
      flex-direction: column;
    }

    .library-sidebar.open {
      transform: translateX(0);
    }

    .library-header {
      padding: 15px;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .library-header h2 {
      margin: 0;
      font-size: 18px;
      color: var(--text-primary);
    }

    .library-close {
      background: transparent;
      border: none;
      font-size: 20px;
      cursor: pointer;
      color: var(--text-muted);
    }

    .library-list {
      flex: 1;
      overflow-y: auto;
      overscroll-behavior: contain;
      padding: 10px;
    }

    .library-item {
      display: flex;
      align-items: center;
      padding: 12px;
      margin-bottom: 8px;
      background: var(--bg-tertiary);
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .library-item:hover {
      background: var(--bg-primary);
    }

    .library-item.active {
      border: 2px solid var(--accent);
    }

    .library-item-content {
      flex: 1;
      min-width: 0;
    }

    .library-item-name {
      font-size: 14px;
      color: var(--text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      direction: rtl;
    }

    .library-item-name[contenteditable="true"] {
      background: var(--bg-secondary);
      padding: 2px 6px;
      border-radius: 4px;
      outline: 1px solid var(--accent);
    }

    .library-item-meta {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 4px;
    }

    .library-item-rename,
    .library-item-delete {
      background: transparent;
      border: none;
      font-size: 16px;
      cursor: pointer;
      color: var(--text-muted);
      padding: 4px 8px;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .library-item:hover .library-item-rename,
    .library-item-delete {
      opacity: 1;
    }

    .library-item-delete:hover {
      color: #ff6b6b;
    }

    .library-empty {
      text-align: center;
      padding: 40px 20px;
      color: var(--text-muted);
    }

    .library-overlay {
      position: fixed;
      top: 50px;
      left: 0;
      right: 1px;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s;
      z-index: 99;
    }

    .library-overlay.open {
      opacity: 1;
      visibility: visible;
    }


    /* Offset container for fixed top bar */
    .container {
      padding-top: 60px;
    }

    /* Drop Zone */
    .drop-zone {
      position: fixed;
      top: 50px;
      left: 0;
      right: 1px;
      bottom: 0;
      overflow: hidden;
      cursor: pointer;
      transition: background 0.2s;
    }

    .drop-zone:hover,
    .drop-zone.drag-over {
      border-color: var(--accent);
      background: var(--bg-tertiary);
    }

    .sample-text-bg {
      position: absolute;
      top: 0;
      left: 0;
      right: 1px;
      bottom: 0;
      padding: 20px 60px 40px 60px;
      font-size: 20px;
      line-height: 1.8;
      color: var(--text-primary);
      opacity: 0.12;
      direction: rtl;
      text-align: right;
      pointer-events: none;
      overflow: hidden;
      transition: opacity 0.3s;
    }

    .sample-text-bg p {
      margin: 0 0 0.6em 0;
    }

    .sample-text-bg p:first-child {
      font-size: 1.2em;
      font-weight: 600;
      margin-bottom: 0.8em;
    }

    .drop-prompt {
      position: absolute;
      top: calc(50% - 70px);
      left: 50%;
      transform: translate(-50%, -50%) scale(1);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 16px;
      z-index: 1;
      background: var(--bg-secondary);
      backdrop-filter: blur(8px);
      border: 2px dashed var(--border);
      border-radius: 16px;
      padding: 50px 80px;
      cursor: default;
      opacity: 1;
      transition: opacity 0.25s ease, transform 0.25s ease;
    }

    .drop-prompt.hidden {
      opacity: 0;
      transform: translate(-50%, -50%) scale(0.95);
      pointer-events: none;
    }

    /* When prompt is hidden, sample text becomes full opacity and interactive */
    .drop-zone:has(.drop-prompt.hidden) .sample-text-bg {
      opacity: 1;
      pointer-events: auto;
      cursor: text;
      overflow-y: auto;
      overscroll-behavior: contain;
    }

    /* When prompt is visible, clicking the zone dismisses it */
    .drop-zone:has(.drop-prompt:not(.hidden))::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 1px;
      bottom: 0;
      z-index: 0;
    }

    .drop-icon {
      font-size: 64px;
      opacity: 0.6;
    }

    .drop-text {
      font-size: 20px;
      color: var(--text-primary);
    }

    .drop-or {
      color: var(--text-muted);
      font-size: 14px;
    }

    .paste-btn {
      background: var(--accent);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      transition: opacity 0.2s;
    }

    .paste-btn:hover {
      opacity: 0.9;
    }

    /* Settings row */
    .settings {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
    }

    /* Loading Overlay */
    #loadingOverlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 1px;
      bottom: 0;
      background: rgba(0,0,0,0.85);
      display: none;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      gap: 20px;
      z-index: 10000;
    }
    #loadingOverlay.active { display: flex; }
    #loadingSpinner {
      width: 40px;
      height: 40px;
      border: 4px solid var(--bg-tertiary);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    #loadingText {
      color: var(--text-primary);
      font-size: 18px;
    }

    /* PDF Helper Modal */
    #pdfModal {
      position: fixed;
      top: 0;
      left: 0;
      right: 1px;
      bottom: 0;
      background: rgba(0,0,0,0.85);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10001;
    }
    #pdfModal.active { display: flex; }
    .pdf-modal-content {
      background: var(--bg-secondary);
      border-radius: 16px;
      padding: 30px;
      max-width: 550px;
      width: 90%;
      text-align: center;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
    }
    .pdf-modal-content h2 {
      color: var(--text-primary);
      margin: 0 0 16px 0;
      font-size: 24px;
    }
    .pdf-modal-content p {
      color: var(--text-secondary);
      margin: 12px 0;
      line-height: 1.6;
    }
    .pdf-command-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 10px 0;
    }

    .pdf-command {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px 16px;
      font-family: monospace;
      font-size: 14px;
      color: var(--accent);
      direction: ltr;
      text-align: left;
      word-break: break-all;
      flex: 1;
    }
    .pdf-modal-buttons {
      display: flex;
      gap: 12px;
      justify-content: center;
      margin-top: 20px;
    }
    .pdf-steps {
      text-align: right;
      background: var(--bg-tertiary);
      border-radius: 8px;
      padding: 16px;
      margin: 16px 0;
    }
    .pdf-steps ol {
      margin: 0;
      padding-right: 24px;
    }
    .pdf-steps li {
      margin: 12px 0;
      color: var(--text-secondary);
    }
    .pdf-steps li .pdf-command-row {
      margin-top: 6px;
    }
    .pdf-steps a {
      color: var(--accent);
    }
    .pdf-dropzone {
      border: 2px dashed var(--border);
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      color: var(--text-muted);
      margin: 16px 0;
      transition: all 0.2s;
    }
    .pdf-dropzone.drag-over {
      border-color: var(--accent);
      background: var(--bg-tertiary);
      color: var(--accent);
    }
    .pdf-filename {
      color: var(--accent);
      font-weight: bold;
    }
    .pdf-note {
      font-size: 12px;
      color: var(--text-muted);
      margin: 4px 0;
    }
    .pdf-example-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 6px;
      font-size: 13px;
      color: var(--text-muted);
    }
    .pdf-example-row code {
      background: var(--bg-tertiary);
      color: var(--accent);
      padding: 4px 8px;
      border-radius: 4px;
      font-family: monospace;
      direction: ltr;
    }
    .pdf-example-row button {
      padding: 4px 8px;
      font-size: 12px;
    }
    .pdf-install-note {
      font-size: 13px;
      color: var(--text-muted);
      margin-top: 16px;
    }
    .pdf-install-note a {
      color: var(--accent);
    }

    /* Paste Modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 1px;
      bottom: 0;
      background: rgba(0,0,0,0.85);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10001;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.25s ease, visibility 0.25s ease;
    }
    .modal-overlay.active {
      opacity: 1;
      visibility: visible;
    }
    .paste-modal-content {
      background: var(--bg-secondary);
      border-radius: 16px;
      padding: 30px;
      max-width: 600px;
      width: 90%;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
      transform: scale(0.95) translateY(-10px);
      transition: transform 0.25s ease;
    }
    .modal-overlay.active .paste-modal-content {
      transform: scale(1) translateY(0);
    }
    .paste-modal-content h2 {
      color: var(--text-primary);
      margin: 0 0 16px 0;
      font-size: 20px;
      text-align: right;
    }
    .paste-modal-content textarea {
      width: 100%;
      height: 200px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-primary);
      padding: 16px;
      border-radius: 8px;
      font-size: 16px;
      font-family: inherit;
      resize: vertical;
    }
    .paste-modal-content textarea::placeholder {
      color: var(--text-muted);
    }
    .paste-modal-buttons {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      margin-top: 16px;
    }

    /* Bottom Control Bar */
    .bottom-bar {
      position: fixed;
      bottom: 81px;
      left: 50%;
      transform: translateX(-50%);
      width: 85%;
      max-width: 900px;
      min-height: 84px;
      background: var(--bg-secondary);
      border: 2px solid var(--border);
      border-radius: 16px;
      padding: 16px 32px;
      z-index: 60;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .play-btn {
      position: absolute;
      top: 2px;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: var(--accent);
      border: none;
      color: white;
      font-size: 42px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1;
      transition: background 0.2s, transform 0.1s;
    }
    .play-btn:hover {
      background: var(--accent-hover);
      transform: translate(-50%, -50%) scale(1.05);
    }

    .wing {
      position: absolute;
      top: 8px;
      transform: translateY(-50%);
      height: 50px;
      background: var(--bg-tertiary);
      border: 2px solid var(--border);
      width: 125px;
      z-index: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 50px;
      padding-bottom: 10px;
      color: var(--text-secondary);
      cursor: pointer;
      transition: background 0.2s;
      user-select: none;
    }
    .wing:hover {
      background: var(--btn-hover);
    }
    .wing-left {
      right: calc(50% - 20px);
      transform: translateY(-50%) skewX(20deg);
      border-radius: 6px 0 0 6px;
      padding-right: 50px;
      padding-left: 0;
    }
    .wing-right {
      left: calc(50% - 20px);
      transform: translateY(-50%) skewX(-20deg);
      border-radius: 0 6px 6px 0;
      padding-left: 50px;
      padding-right: 1px;
    }

    .wing-outer {
      position: absolute;
      top: 0;
      height: 33px;
      background: var(--bg-tertiary);
      border: 2px solid var(--border);
      width: 81px;
      z-index: -1;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      padding-bottom: 8px;
      color: var(--text-secondary);
      cursor: pointer;
      transition: background 0.2s;
      user-select: none;
    }
    .wing-outer:hover {
      background: var(--btn-hover);
    }
    .wing-outer-left {
      right: calc(50% + 95px);
      transform: skewX(20deg);
      border-radius: 6px 0 0 6px;
      border-right: none;
      padding-right: 8px;
    }
    .wing-outer-right {
      left: calc(50% + 95px);
      transform: skewX(-20deg);
      border-radius: 0 6px 6px 0;
      border-left: none;
      padding-left: 8px;
    }

    .bar-inputs {
      position: absolute;
      bottom: 6px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 40px;
      direction: rtl;
    }
    .bar-input-group {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--text-secondary);
      font-size: 14px;
      white-space: nowrap;
    }
    .bar-input-group span {
      min-width: 95px;
      text-align: right;
    }
    .bar-input-group input[type="number"] {
      width: 68px;
      padding: 6px 8px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-primary);
      font-size: 14px;
      text-align: center;
      margin-right: -16px;
    }
    #wpmInput {
      margin-right: -20px;
    }
    .bar-input-group:last-child {
      margin-right: -20px;
    }
    .bar-input-group input[type="number"]::-webkit-inner-spin-button,
    .bar-input-group input[type="number"]::-webkit-outer-spin-button {
      opacity: 1;
      height: 24px;
    }

    .bar-buttons-right {
      position: absolute;
      top: 7.5px;
      right: 26px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .bar-buttons-right .bar-btn {
      width: 100px;
    }
    .bar-buttons-right .bar-input-group {
      margin-right: 0px;
    }
    .bar-buttons-right .bar-input-group span {
      margin-right: 1px;
    }
    .bar-buttons-right .bar-input-group input[type="number"] {
      margin-right: -40px;
    }
    .bar-buttons-left {
      position: absolute;
      bottom: 10px;
      left: 26px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .bar-btn {
      min-width: 100px;
      height: 28px;
      padding: 0 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-secondary);
      font-size: 13px;
      cursor: pointer;
      transition: background 0.2s;
      white-space: nowrap;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .bar-btn:hover {
      background: var(--btn-hover);
    }
    .bar-btn.active {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }

    /* TTS Controls */
    .tts-controls {
      display: flex;
      gap: 4px;
      align-items: center;
    }
    #ttsLoadBtn {
      min-width: 50px !important;
      width: auto !important;
      padding: 0 8px !important;
    }
    .tts-full-toggle {
      min-width: 36px !important;
      width: auto !important;
      padding: 0 6px !important;
    }
    .tts-full-toggle.active {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }
    .tts-speed-wrapper {
      position: relative;
    }
    .tts-speed-rec {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      font-size: 9px;
      color: var(--text-muted);
      margin-bottom: 1px;
      white-space: nowrap;
    }
    .tts-speed-btn {
      min-width: 36px !important;
      width: auto !important;
      padding: 0 6px !important;
      font-weight: 600;
      font-size: 12px;
    }
    .tts-speed-menu {
      display: none;
      position: absolute;
      bottom: 100%;
      right: 0;
      margin-bottom: 4px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 -4px 12px rgba(0,0,0,0.3);
      z-index: 1000;
    }
    .tts-speed-menu.open {
      display: block;
    }
    .tts-speed-option {
      padding: 8px 16px;
      cursor: pointer;
      white-space: nowrap;
      font-size: 13px;
      color: var(--text-secondary);
      transition: background 0.15s;
    }
    .tts-speed-option:hover {
      background: var(--btn-hover);
    }
    .tts-speed-option.selected {
      color: var(--accent);
      font-weight: 600;
    }

    .page-slider-wrapper {
      position: fixed;
      bottom: 48px;
      left: 50%;
      transform: translateX(-50%);
      width: 70%;
      max-width: 750px;
      z-index: 55;
    }
    .page-slider-container {
      width: 100%;
      padding: 14px 24px;
      background: var(--btn-bg);
      clip-path: polygon(0% 0%, 100% 0%, 95% 100%, 5% 100%);
    }
    .page-slider-container::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: var(--btn-hover);
      clip-path: polygon(0% 0%, 100% 0%, 95% 100%, 5% 100%);
      z-index: -1;
    }
    .page-slider-track {
      width: 100%;
      height: 6px;
      background: var(--bg-tertiary);
      border-radius: 3px;
    }
    .page-slider-thumb {
      position: absolute;
      top: 17px;
      left: 24px;
      transform: translate(-50%, -50%);
      min-width: 50px;
      height: 24px;
      padding: 0 10px;
      background: var(--bg-secondary);
      border: 2px solid var(--border);
      border-radius: 6px;
      cursor: grab;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      color: var(--text-secondary);
      user-select: none;
      z-index: 10;
    }
    .page-slider-thumb:active {
      cursor: grabbing;
    }

    /* Debug Icon & Panel */
    #debugIcon {
      position: fixed;
      bottom: 12px;
      right: 12px;
      width: 28px;
      height: 28px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      opacity: 0.5;
      transition: opacity 0.2s;
      z-index: 9998;
    }
    #debugIcon:hover { opacity: 1; }
    #debugPanel {
      position: fixed;
      bottom: 48px;
      right: 12px;
      width: 400px;
      max-width: calc(100vw - 24px);
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      z-index: 9999;
      display: flex;
      flex-direction: column;
      box-shadow: 0 -4px 20px rgba(0,0,0,0.3);
      opacity: 0;
      visibility: hidden;
      transform: translateY(10px);
      transition: opacity 0.2s ease, visibility 0.2s ease, transform 0.2s ease;
    }
    #debugPanel.open {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }
    #debugHeader {
      background: var(--bg-secondary);
      color: var(--text-secondary);
      padding: 8px 12px;
      font-family: monospace;
      font-size: 12px;
      display: flex;
      justify-content: flex-end;
      gap: 12px;
      border-bottom: 1px solid var(--border);
      border-radius: 8px 8px 0 0;
    }
    #debugHeader span {
      cursor: pointer;
      opacity: 0.7;
    }
    #debugHeader span:hover { opacity: 1; }
    #debugLog {
      height: 200px;
      overflow-y: auto;
      overscroll-behavior: contain;
      padding: 8px;
      font-family: monospace;
      font-size: 11px;
      color: var(--text-muted);
      background: var(--bg-tertiary);
      white-space: pre-wrap;
      user-select: text;
      border-radius: 0 0 8px 8px;
    }
    #debugLog .e { color: #ff6b6b; }
    #debugLog .w { color: #ffd43b; }
    #debugLog .i { color: var(--accent); }

    /* Settings Dropdown */
    .settings-dropdown {
      position: fixed;
      top: 50px;
      left: 50%;
      transform: translateX(-50%) translateY(-100%);
      width: 760px;
      max-width: 96vw;
      max-height: calc(100vh - 100px);
      overflow-y: auto;
      overscroll-behavior: contain;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-top: none;
      border-radius: 0 0 12px 12px;
      padding: 24px;
      z-index: 999;
      opacity: 0;
      pointer-events: none;
      transition: transform 0.3s ease, opacity 0.3s ease;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }
    @media (max-width: 750px) {
      .settings-dropdown {
        width: 400px;
        grid-template-columns: 1fr;
      }
    }
    .settings-dropdown.open {
      transform: translateX(-50%) translateY(0);
      opacity: 0.65;
      pointer-events: auto;
    }
    .settings-dropdown.open:hover {
      opacity: 0.98;
    }
    .settings-section {
      margin-bottom: 0;
      padding: 16px;
      border-radius: 10px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
    }
    .settings-section:nth-child(even) {
      background: color-mix(in srgb, var(--bg-tertiary) 60%, var(--bg-secondary));
    }
    .settings-section h3 {
      margin: 0 0 12px 0;
      font-size: 14px;
      color: var(--text-muted);
      font-weight: normal;
    }
    .settings-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
      gap: 12px;
    }
    .settings-row:last-child {
      margin-bottom: 0;
    }
    .settings-row label {
      color: var(--text-secondary);
      font-size: 14px;
      flex-shrink: 0;
    }
    .settings-row select,
    .settings-row input[type="number"] {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-primary);
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 14px;
    }
    .settings-row select {
      min-width: 140px;
    }
    .settings-row input[type="number"] {
      width: 70px;
      text-align: center;
    }
    .settings-row input[type="color"] {
      width: 40px;
      height: 30px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-tertiary);
      cursor: pointer;
      padding: 2px;
    }
    .color-with-opacity {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .color-with-opacity input[type="range"] {
      width: 80px;
      flex-shrink: 0;
    }
    .color-with-opacity .opacity-value {
      min-width: 35px;
      font-size: 12px;
      color: var(--text-muted);
    }
    .slider-with-value {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .slider-with-value input[type="range"] {
      width: 100px;
      flex-shrink: 0;
    }
    .slider-with-value .slider-value {
      min-width: 40px;
      font-size: 12px;
      color: var(--text-muted);
    }
    .settings-row input[type="range"] {
      flex: 1;
      min-width: 100px;
      accent-color: var(--accent);
    }
    .settings-toggle {
      display: flex;
      gap: 8px;
    }
    .settings-toggle button {
      padding: 8px 14px;
      font-size: 13px;
      min-width: 50px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      color: var(--text-secondary);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s ease;
    }
    .settings-toggle button:hover {
      background: var(--bg-primary);
      border-color: var(--accent);
    }
    .settings-toggle button.active {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }
    .settings-toggle.align-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
    }
    .range-value {
      min-width: 50px;
      text-align: left;
      color: var(--text-muted);
      font-size: 12px;
      background: var(--bg-secondary);
      padding: 4px 8px;
      border-radius: 4px;
    }

    /* Pages Panel - Left side PDF-style preview */
    .figures-panel {
      position: fixed;
      top: 50px;
      left: 0;
      width: 88px;
      bottom: 0;
      background: var(--bg-tertiary);
      border-right: 1px solid var(--border);
      z-index: 55;
      display: flex;
      flex-direction: column;
      transform: translateX(-100%);
      transition: transform 0.3s ease;
      box-shadow: 4px 0 20px rgba(0,0,0,0.3);
    }
    .figures-panel.open {
      transform: translateX(0);
    }
    /* Shift content when panel is open */
    body.figures-panel-open .container {
      margin-left: 27px;
      margin-right: -27px;
    }
    body.figures-panel-open .rsvp-content {
      margin-left: 24.5px;
    }
    .figures-header {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 4px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
    }
    .figures-header span {
      display: none;
    }
    .figures-close {
      background: transparent;
      border: none;
      color: var(--text-muted);
      font-size: 14px;
      cursor: pointer;
      padding: 2px;
    }
    .figures-close:hover {
      color: var(--text-primary);
    }
    .figures-content {
      flex: 1;
      overflow-y: auto;
      overscroll-behavior: contain;
      padding: 3px;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .page-thumb {
      position: relative;
      cursor: pointer;
      border-radius: 2px;
      overflow: hidden;
      border: 1px solid transparent;
      transition: border-color 0.2s;
      flex-shrink: 0;
    }
    .page-thumb:hover {
      border-color: var(--text-muted);
    }
    .page-thumb.active {
      border-color: var(--accent);
      box-shadow: 0 0 8px var(--accent);
      transform: scale(1.05);
      z-index: 2;
    }
    .page-thumb img {
      width: 100%;
      display: block;
    }
    .page-thumb-label {
      position: absolute;
      bottom: 2px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.6);
      color: white;
      font-size: 9px;
      padding: 1px 4px;
      border-radius: 2px;
      transition: all 0.2s;
    }
    .page-thumb.active .page-thumb-label {
      background: var(--accent);
      font-size: 11px;
      font-weight: bold;
      padding: 2px 6px;
    }
    .figures-placeholder {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 150px;
      border: 2px dashed var(--border);
      border-radius: 8px;
      color: var(--text-muted);
      text-align: center;
      padding: 12px;
      font-size: 12px;
      transition: all 0.2s;
    }
    .figures-placeholder p {
      margin: 4px 0;
    }
    .figures-content.drag-over {
      background: var(--bg-secondary);
    }
    .figures-content.drag-over .figures-placeholder {
      border-color: var(--accent);
      background: var(--btn-bg);
      color: var(--accent);
    }
    /* Lightbox for full-size figure view */
    .figure-lightbox {
      position: fixed;
      top: 0;
      left: 0;
      right: 1px;
      bottom: 0;
      background: rgba(0,0,0,0.9);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10002;
      cursor: zoom-in;
      overflow: hidden;
    }
    .figure-lightbox.active {
      display: flex;
    }
    .figure-lightbox.zoomed {
      cursor: grab;
    }
    .figure-lightbox.zoomed.dragging {
      cursor: grabbing;
    }
    .figure-lightbox img {
      max-width: 95vw;
      max-height: 95vh;
      transition: transform 0.1s ease-out;
      transform-origin: center center;
      object-fit: contain;
    }
  </style>
</head>
<body>
  <!-- VN Border SVG Overlay -->
  <svg id="vnBorderSvg" style="display: none;">
    <path id="vnBorderPath"></path>
  </svg>

  <!-- Top Bar -->
  <header class="top-bar">
    <div class="top-bar-right">
      <button class="top-btn" id="newDocBtn" title="מסמך חדש">➕</button>
    </div>
    <h1 class="top-bar-title">קרא בקצב שלך</h1>
    <div class="top-bar-left">
      <button class="top-btn" id="figuresBtn" title="איורים">🖼️</button>
      <button class="top-btn" id="styleBtn" title="עיצוב">🎨</button>
      <button class="top-btn" id="libraryBtn" title="ספרייה">📚</button>
    </div>
  </header>

  <!-- Library Sidebar -->
  <div class="library-overlay" id="libraryOverlay"></div>
  <aside class="library-sidebar" id="librarySidebar">
    <div class="library-header">
      <h2>📚 ספרייה</h2>
      <button class="library-close" id="libraryClose">✕</button>
    </div>
    <div class="library-list" id="libraryList">
      <div class="library-empty">אין פריטים בספרייה</div>
    </div>
  </aside>

  <!-- Vertical Progress Bar -->
  <div class="progress-bar-container" id="progressBar">
    <div class="progress-bar-fill" id="progressFill"></div>
    <span class="progress-bar-percent" id="progressPercent">0%</span>
  </div>

  <!-- Settings Dropdown -->
  <div class="settings-dropdown" id="settingsDropdown">
    <!-- Theme -->
    <div class="settings-section">
      <h3>סגנון</h3>
      <div class="settings-row">
        <label>סגנון:</label>
        <select id="settingsTheme" onchange="setTheme(this.value)">
          <optgroup label="── Light ──">
            <option value="theme-light">☀️ Classic Light</option>
            <option value="theme-solarized-light">🌤️ Solarized Light</option>
            <option value="theme-github-light">📄 GitHub Light</option>
          </optgroup>
          <optgroup label="── Dark ──">
            <option value="theme-pure-dark">🌑 Pure Dark (OLED)</option>
            <option value="">🔮 Sweet Mars</option>
            <option value="theme-catppuccin">🐱 Catppuccin Mocha</option>
            <option value="theme-dracula">🧛 Dracula</option>
            <option value="theme-one-dark">⚛️ One Dark</option>
            <option value="theme-tokyo">🌃 Tokyo Night</option>
            <option value="theme-nord">❄️ Nord</option>
            <option value="theme-gruvbox">🎨 Gruvbox</option>
            <option value="theme-monokai">🎭 Monokai Pro</option>
            <option value="theme-ayu">🌙 Ayu Dark</option>
            <option value="theme-palenight">💜 Palenight</option>
            <option value="theme-rose-pine">🌹 Rosé Pine</option>
            <option value="theme-everforest">🌲 Everforest</option>
            <option value="theme-kanagawa">🌊 Kanagawa</option>
            <option value="theme-solarized">☯️ Solarized Dark</option>
          </optgroup>
        </select>
      </div>
      <div class="settings-row">
        <label>בהירות:</label>
        <div class="slider-with-value">
          <input type="range" id="globalBrightness" min="50" max="150" value="100">
          <span class="slider-value" id="globalBrightnessValue">100%</span>
        </div>
      </div>
      <div class="settings-row">
        <label>ניגודיות:</label>
        <div class="slider-with-value">
          <input type="range" id="globalContrast" min="50" max="150" value="100">
          <span class="slider-value" id="globalContrastValue">100%</span>
        </div>
      </div>
    </div>

    <!-- Font -->
    <div class="settings-section">
      <h3>גופן</h3>
      <div class="settings-row">
        <label>סוג:</label>
        <select id="settingsFont">
          <option value="'David', serif">David</option>
          <option value="'Noto Sans Hebrew', sans-serif">Noto Sans Hebrew</option>
          <option value="'Arial', sans-serif">Arial</option>
          <option value="'Rubik', sans-serif">Rubik</option>
          <option value="'Heebo', sans-serif">Heebo</option>
          <option value="'Assistant', sans-serif">Assistant</option>
          <option value="'Frank Ruhl Libre', serif">Frank Ruhl Libre</option>
        </select>
      </div>
      <div class="settings-row">
        <label>גודל:</label>
        <input type="range" id="settingsFontSize" min="14" max="36" value="22">
        <span class="range-value" id="fontSizeValue">22px</span>
      </div>
      <div class="settings-row">
        <label>עובי:</label>
        <div class="settings-toggle">
          <button id="fontWeightNormal" class="active">רגיל</button>
          <button id="fontWeightBold">מודגש</button>
        </div>
      </div>
    </div>

    <!-- Spacing -->
    <div class="settings-section">
      <h3>ריווח</h3>
      <div class="settings-row">
        <label>גובה שורה:</label>
        <input type="range" id="settingsLineHeight" min="1.2" max="3" step="0.1" value="2">
        <span class="range-value" id="lineHeightValue">2</span>
      </div>
      <div class="settings-row">
        <label>רווח אותיות:</label>
        <input type="range" id="settingsLetterSpacing" min="0" max="5" step="0.5" value="0">
        <span class="range-value" id="letterSpacingValue">0px</span>
      </div>
      <div class="settings-row">
        <label>רווח פסקאות:</label>
        <input type="range" id="settingsParagraphSpacing" min="0" max="40" step="2" value="16">
        <span class="range-value" id="paragraphSpacingValue">16px</span>
      </div>
    </div>

    <!-- Layout -->
    <div class="settings-section">
      <h3>פריסה</h3>
      <div class="settings-row">
        <label>שוליים צדדיים:</label>
        <input type="range" id="settingsMargins" min="10" max="100" step="5" value="30">
        <span class="range-value" id="marginsValue">30px</span>
      </div>
      <div class="settings-row">
        <label>יישור טקסט:</label>
        <div class="settings-toggle align-grid">
          <button id="alignRight">ימין</button>
          <button id="alignCenterRight" class="active">ימין-מרכז</button>
          <button id="alignCenter">מרכז</button>
          <button id="alignJustify">מלא</button>
        </div>
      </div>
    </div>

    <!-- Highlights -->
    <div class="settings-section">
      <h3>הדגשות</h3>
      <div class="settings-row">
        <label>צבע נקרא:</label>
        <div class="color-with-opacity">
          <input type="color" id="settingsHighlightRead" value="#64c864">
          <input type="range" id="highlightReadOpacity" min="0" max="100" value="25">
          <span class="opacity-value" id="highlightReadOpacityValue">25%</span>
        </div>
      </div>
      <div class="settings-row">
        <label>צבע נוכחי:</label>
        <div class="color-with-opacity">
          <input type="color" id="settingsHighlightCurrent" value="#ffc800">
          <input type="range" id="highlightCurrentOpacity" min="0" max="100" value="50">
          <span class="opacity-value" id="highlightCurrentOpacityValue">50%</span>
        </div>
      </div>
      <div class="settings-row">
        <label>הדגשה רציפה:</label>
        <div class="settings-toggle">
          <button id="highlightContinuousOn">פעיל</button>
          <button id="highlightContinuousOff" class="active">כבוי</button>
        </div>
      </div>
    </div>

    <!-- Half-Bold Mode (הדגשת חצי) -->
    <div class="settings-section">
      <h3>הדגשת חצי</h3>
      <div class="settings-row">
        <label>מצב הדגשה:</label>
        <div class="settings-toggle">
          <button id="halfBoldModeOn">פעיל</button>
          <button id="halfBoldModeOff" class="active">כבוי</button>
        </div>
      </div>
      <div class="settings-row">
        <label>צבע (אופציונלי):</label>
        <div class="color-with-opacity">
          <input type="color" id="settingsHalfBoldColor" value="#0a84ff">
          <input type="range" id="halfBoldColorOpacity" min="0" max="100" value="0">
          <span class="opacity-value" id="halfBoldColorOpacityValue">0%</span>
        </div>
      </div>
      <div class="settings-row">
        <label>גודל אותיות:</label>
        <div class="slider-with-value">
          <input type="range" id="halfBoldFontSize" min="100" max="150" value="100">
          <span class="slider-value" id="halfBoldFontSizeValue">100%</span>
        </div>
      </div>
      <div class="settings-row">
        <label>טקסט שלא נקרא:</label>
        <div class="settings-toggle">
          <button id="halfBoldUnreadOn">פעיל</button>
          <button id="halfBoldUnreadOff" class="active">כבוי</button>
        </div>
      </div>
    </div>

    <!-- VN Mode -->
    <div class="settings-section">
      <h3>מצב VN</h3>
      <div class="settings-row">
        <label>אפקט דעיכה:</label>
        <div class="settings-toggle">
          <button id="vnModeOn">פעיל</button>
          <button id="vnModeOff" class="active">כבוי</button>
        </div>
      </div>
      <div class="settings-row">
        <label>טווח תצוגה:</label>
        <input type="range" id="settingsVnRadius" min="0" max="50" value="5">
        <span class="range-value" id="vnRadiusValue">2</span>
      </div>
      <div class="settings-row">
        <label>משפטים גלויים:</label>
        <input type="range" id="settingsVnSentenceBuffer" min="1" max="5" value="1">
        <span class="range-value" id="vnSentenceBufferValue">1</span>
      </div>
    </div>

    <!-- Sentence Border -->
    <div class="settings-section">
      <h3>מסגרת משפט</h3>
      <div class="settings-row">
        <label>מסגרת:</label>
        <div class="settings-toggle">
          <button id="vnBorderOn">פעיל</button>
          <button id="vnBorderOff" class="active">כבוי</button>
        </div>
      </div>
      <div class="settings-row">
        <label>צבע:</label>
        <input type="color" id="borderColor" value="#e0e0e0">
      </div>
      <div class="settings-row">
        <label>שקיפות:</label>
        <div class="slider-with-value">
          <input type="range" id="borderOpacity" min="10" max="100" value="100">
          <span class="slider-value" id="borderOpacityValue">100%</span>
        </div>
      </div>
      <div class="settings-row">
        <label>עובי:</label>
        <div class="slider-with-value">
          <input type="range" id="borderWidth" min="1" max="6" value="2">
          <span class="slider-value" id="borderWidthValue">2px</span>
        </div>
      </div>
    </div>

    <!-- Sound -->
    <div class="settings-section">
      <h3>צליל</h3>
      <div class="settings-row">
        <label>מטרונום:</label>
        <div class="settings-toggle">
          <button id="metronomeOn" class="active">פעיל</button>
          <button id="metronomeOff">כבוי</button>
        </div>
      </div>
      <div class="settings-row">
        <label>עוצמה:</label>
        <input type="range" id="settingsVolume" min="0" max="100" value="50">
        <span class="range-value" id="volumeValue">50%</span>
      </div>
      <div class="settings-row">
        <label>הקראה (TTS):</label>
        <div class="settings-toggle">
          <button id="ttsOn">פעיל</button>
          <button id="ttsOff" class="active">כבוי</button>
        </div>
      </div>

    </div>

    <!-- Animation -->
    <div class="settings-section">
      <h3>אנימציה</h3>
      <div class="settings-row">
        <label>גודל פופ:</label>
        <input type="range" id="settingsPopSize" min="0" max="20" value="8">
        <span class="range-value" id="popSizeValue">8%</span>
      </div>
      <div class="settings-row">
        <label>מהירות:</label>
        <input type="range" id="settingsAnimSpeed" min="5" max="50" value="15">
        <span class="range-value" id="animSpeedValue">0.15s</span>
      </div>
    </div>

    <!-- Fake Cursor -->
    <div class="settings-section">
      <h3>סמן קריאה</h3>
      <div class="settings-row">
        <label>סמן:</label>
        <div class="settings-toggle">
          <button id="fakeCursorOn">פעיל</button>
          <button id="fakeCursorOff" class="active">כבוי</button>
        </div>
      </div>
      <div class="settings-row">
        <label>צבע:</label>
        <input type="color" id="fakeCursorColor" value="#e0e0e0">
      </div>
      <div class="settings-row">
        <label>מהבהב:</label>
        <div class="settings-toggle">
          <button id="fakeCursorBlinkOn">פעיל</button>
          <button id="fakeCursorBlinkOff" class="active">כבוי</button>
        </div>
      </div>
    </div>

    <!-- RSVP Mode -->
    <div class="settings-section">
      <h3>מצב RSVP</h3>
      <div class="settings-row">
        <label>מצב:</label>
        <div class="settings-toggle">
          <button id="rsvpModeOn">פעיל</button>
          <button id="rsvpModeOff" class="active">כבוי</button>
        </div>
      </div>
      <div class="settings-row">
        <label>גודל טקסט:</label>
        <div class="slider-with-value">
          <input type="range" id="rsvpFontSize" min="150" max="500" value="250">
          <span class="slider-value" id="rsvpFontSizeValue">250%</span>
        </div>
      </div>
      <div class="settings-row">
        <label>רשת:</label>
        <div class="settings-toggle">
          <button id="rsvpGridOn">פעיל</button>
          <button id="rsvpGridOff" class="active">כבוי</button>
        </div>
      </div>
      <div class="settings-row">
        <label>שקיפות רשת:</label>
        <div class="slider-with-value">
          <input type="range" id="rsvpGridOpacity" min="0" max="50" value="15">
          <span class="slider-value" id="rsvpGridOpacityValue">15%</span>
        </div>
      </div>
      <div class="settings-row">
        <label>גובה טקסט:</label>
        <div class="slider-with-value">
          <input type="range" id="rsvpTextHeight" min="5" max="50" value="22">
          <span class="slider-value" id="rsvpTextHeightValue">22%</span>
        </div>
      </div>
      <div class="settings-row">
        <label>מיקום אופקי:</label>
        <div class="slider-with-value">
          <input type="range" id="rsvpTextPosition" min="-20" max="20" value="0">
          <span class="slider-value" id="rsvpTextPositionValue">0%</span>
        </div>
      </div>
      <div class="settings-row">
        <label>מצב Spritz (ORP):</label>
        <div class="settings-toggle">
          <button id="rsvpOrpOn">פעיל</button>
          <button id="rsvpOrpOff" class="active">כבוי</button>
        </div>
      </div>
    </div>

  </div>

  <!-- RSVP Overlay -->
  <div class="rsvp-overlay" id="rsvpOverlay">
    <div class="rsvp-hint">Space להתקדם • Esc לצאת • גלגל עכבר לניווט</div>
    <div class="rsvp-grid" id="rsvpGrid"></div>
    <div class="rsvp-redicle hidden" id="rsvpRedicle">
      <div class="redicle-line-top"></div>
      <div class="redicle-line-bottom"></div>
      <div class="redicle-vertical-top"></div>
      <div class="redicle-vertical-bottom"></div>
    </div>
    <div class="rsvp-content" id="rsvpContent"></div>
    <div class="rsvp-progress" id="rsvpProgress"></div>
  </div>

  <!-- Pages Panel - PDF-style thumbnails -->
  <div class="figures-panel" id="figuresPanel">
    <div class="figures-header">
      <span>עמודים</span>
      <button class="figures-close" onclick="closeFiguresPanel()">✕</button>
    </div>
    <div class="figures-content" id="figuresContent">
      <div class="figures-placeholder">
        <p>גרור תיקיית תמונות</p>
      </div>
    </div>
  </div>

  <div class="container">

    <!-- Drop Zone / Input Area (hidden by default, shown if no saved state) -->
    <div class="drop-zone" id="inputArea" style="display: none;">
      <!-- Faded example text as background -->
      <div class="sample-text-bg">
        <p>מה משותף לכל היצורים החיים</p>

        <p>קליטה מתמדת של אנרגיה ותנועה מחזורית של חומרים בינם לבין סביבתם מקיימות את הארגון המורכב של יצורים חיים. אורגניזמים חשים בשינויים ומגיבים עליהם.</p>

        <p>כל האורגניזמים משתמשים לצורך תפקודה והתפתחותם במידע שנמצא בירישתו מההורים או מההורים שלהם DNA. גם אם אינו יכולים להגדיר "חיים" אנחנו יכולים להבין אינטואיטיבית מהו יצור חי, משום שיש כמה תכונות עיקריות המשותפות לכל היצורים החיים:</p>

        <p>כולם זקוקים לאספקה מתמדת של אנרגיה ושל חומרי גלם;<br>
        כולם חשים בשינויים ומגיבים עליהם;<br>
        ולכולם ישהמכתיב את אופן תפקודם DNA.</p>

        <p>אורגניזמים זקוקים לאנרגיה ולחומרי גלם</p>

        <p>לביולוגיה שמור מקום מיוחד בין המדעים: שכנותיה מצד אחד הן הכימיה והפיזיקה, ומצדה האחר היא גובלת בפסיכולוגיה ובסוציולוגיה.</p>

        <p>הביולוגיה עוסקת בטווח עצום של תופעות:<br>
        מתהליכים מולקולריים ועד האבולוציה שבה נוצרו שפע היצורים החיים;<br>
        מהמנגנונים המתוחכמים להפליא של החיסון, הרבייה, עיבוד המידע וההתנהגות;<br>
        ועד הקשרים המורכבים שבין כל היצורים החיים לבין סביבתם.</p>

        <p>מה משותף לכל היצורים החיים. קליטה מתמדת של אנרגיה ותנועה מחזורית של חומרים בינם לבין סביבתם מקיימות את הארגון המורכב של יצורים חיים. אורגניזמים חשים בשינויים ומגיבים עליהם.</p>

        <p>כל האורגניזמים משתמשים לצורך תפקודה והתפתחותם במידע שנמצא בירישתו מההורים או מההורים שלהם DNA. גם אם אינו יכולים להגדיר "חיים" אנחנו יכולים להבין אינטואיטיבית מהו יצור חי.</p>
      </div>
      <!-- Drop prompt overlay -->
      <div class="drop-prompt">
        <div class="drop-icon">📄</div>
        <div class="drop-text">גרור קובץ טקסט לכאן</div>
        <div class="drop-or">או</div>
        <button class="paste-btn" onclick="openPasteModal()">הדבק טקסט</button>
      </div>
      <!-- Hidden file input -->
      <input type="file" id="fileInput" accept=".txt,.md,.pdf" onchange="loadFile(event)" hidden>
      <!-- Hidden textarea for paste modal -->
      <textarea id="textInput" hidden></textarea>
    </div>

    <!-- Controls -->
    <div class="controls" id="controls" style="display: none;">
      <button onclick="backToInput()">↩ חזור</button>

      <!-- Page Navigation -->
      <div class="page-nav" id="pageNav" style="display: none;">
        <button onclick="prevPage()" title="עמוד קודם">⏮ עמוד</button>
        <select id="pageSelect" onchange="goToPage(this.value)"></select>
        <button onclick="nextPage()" title="עמוד הבא">עמוד ⏭</button>
      </div>

      <span class="separator">|</span>

      <button onclick="prevChunk()">→ הקודם</button>
      <button class="primary" onclick="nextChunk()">הבא ←</button>
      <button id="autoBtn" onclick="toggleAuto()">▶ אוטומטי</button>
      <button id="cleanBtn" class="active" onclick="toggleClean()">🧹 נקי</button>

      <div class="settings">
        <label>
          <select id="modeSelect" onchange="toggleMode()">
            <option value="words">מילים</option>
            <option value="sentences">משפטים</option>
          </select>
          <input type="number" id="chunkSize" value="1" min="1" max="20" onchange="updateSettings()">
        </label>
        <label>
          מ/דקה:
          <input type="number" id="wpm" value="200" min="50" max="500" step="25" onchange="updateSettings()">
        </label>
      </div>

      <span class="progress" id="progress">0 / 0</span>
      <button onclick="reset()">איפוס</button>
      <select id="themeSelect" onchange="setTheme(this.value)">
        <optgroup label="── Light ──">
          <option value="theme-light">☀️ Classic Light</option>
          <option value="theme-solarized-light">🌤️ Solarized Light</option>
          <option value="theme-github-light">📄 GitHub Light</option>
        </optgroup>
        <optgroup label="── Dark ──">
          <option value="theme-pure-dark">🌑 Pure Dark (OLED)</option>
          <option value="">🔮 Sweet Mars</option>
          <option value="theme-catppuccin">🐱 Catppuccin Mocha</option>
          <option value="theme-dracula">🧛 Dracula</option>
          <option value="theme-one-dark">⚛️ One Dark</option>
          <option value="theme-tokyo">🌃 Tokyo Night</option>
          <option value="theme-nord">❄️ Nord</option>
          <option value="theme-gruvbox">🎨 Gruvbox</option>
          <option value="theme-monokai">🎭 Monokai Pro</option>
          <option value="theme-ayu">🌙 Ayu Dark</option>
          <option value="theme-palenight">💜 Palenight</option>
          <option value="theme-rose-pine">🌹 Rosé Pine</option>
          <option value="theme-everforest">🌲 Everforest</option>
          <option value="theme-kanagawa">🌊 Kanagawa</option>
          <option value="theme-solarized">☯️ Solarized Dark</option>
        </optgroup>
      </select>
    </div>

    <!-- Text Display -->
    <div class="text-display" id="textDisplay" style="display: none;"></div>
  </div>

  <!-- Loading Overlay -->
  <div id="loadingOverlay">
    <div id="loadingSpinner"></div>
    <div id="loadingText">טוען...</div>
  </div>

  <!-- Paste Modal -->
  <div id="pasteModal" class="modal-overlay">
    <div class="paste-modal-content">
      <h2>הדבק טקסט</h2>
      <textarea id="pasteTextarea" placeholder="הדבק טקסט כאן..." dir="rtl"></textarea>
      <div class="paste-modal-buttons">
        <button class="primary" onclick="loadPastedText()">טען</button>
        <button onclick="closePasteModal()">ביטול</button>
      </div>
    </div>
  </div>

  <!-- PDF Helper Modal -->
  <div id="pdfModal">
    <div class="pdf-modal-content">
      <h2>📄 קובץ PDF זוהה</h2>
      <p>דפדפנים לא יכולים לקרוא PDF ישירות. השתמש בסקריפט extract_pdf.py לחילוץ טקסט נקי.</p>

      <div class="pdf-steps">
        <ol>
          <li>ודא ש-<code>extract_pdf.py</code> נמצא בתיקיית ה-PDF</li>
          <li>פתח Terminal בתיקייה (קליק ימני → "Open Terminal Here")</li>
          <li>
            הרץ: <span class="pdf-note">💡 הדבקה בטרמינל: Ctrl+Shift+V</span>
            <div class="pdf-command-row">
              <div class="pdf-command" id="cdCommand">python3 extract_pdf.py "שם_הקובץ.pdf"</div>
              <button onclick="copyCdCommand()">📋</button>
            </div>
            <div class="pdf-example-row">
              <span>לדוגמה:</span>
              <code id="pdfCommand">python3 extract_pdf.py "filename.pdf"</code>
            </div>
          </li>
          <li>
            גרור את ה-PDF (לתמונות) ואת קובץ ה-txt שנוצר:
            <div class="pdf-dropzone" id="pdfDropzone">
              גרור לכאן
            </div>
          </li>
        </ol>
      </div>

      <div class="pdf-modal-buttons">
        <button onclick="closePdfModal()">סגור</button>
      </div>
    </div>
  </div>

  <!-- Bottom Control Bar -->
  <div class="bottom-bar">
    <div class="wing-outer wing-outer-left">»</div>
    <div class="wing wing-left">›</div>
    <button class="play-btn" id="playBtn">⟳</button>
    <div class="wing wing-right">‹</div>
    <div class="wing-outer wing-outer-right">«</div>

    <div class="bar-inputs">
      <label class="bar-input-group">
        <span>כמות מילים:</span>
        <input type="number" id="chunkSizeInput" value="1" min="1" max="20">
      </label>
      <label class="bar-input-group">
        <span>מילים/דקה:</span>
        <input type="number" id="wpmInput" value="200" min="50" max="1000" step="10">
      </label>
    </div>

    <div class="bar-buttons-left">
      <button class="bar-btn" id="cleanTextBtn">טקסט נקי</button>
      <button class="bar-btn" id="wordModeBtn">מצב מילים</button>
    </div>

    <div class="bar-buttons-right">
      <button class="bar-btn" id="resetBtn">איפוס</button>
<div class="tts-controls" style="display: none;">
  <button class="bar-btn" id="ttsLoadBtn">טען</button>
  <button class="bar-btn tts-full-toggle" id="ttsFullToggle">הכל</button>
  <div class="tts-speed-wrapper">
    <span class="tts-speed-rec" id="ttsSpeedRec"></span>
    <button class="bar-btn tts-speed-btn" id="ttsSpeedBtn">1x</button>
    <div class="tts-speed-menu" id="ttsSpeedMenu">
      <div class="tts-speed-option" data-speed="0.5">0.5x</div>
      <div class="tts-speed-option" data-speed="0.75">0.75x</div>
      <div class="tts-speed-option selected" data-speed="1">1x</div>
      <div class="tts-speed-option" data-speed="1.25">1.25x</div>
      <div class="tts-speed-option" data-speed="1.5">1.5x</div>
      <div class="tts-speed-option" data-speed="2">2x</div>
      <div class="tts-speed-option" data-speed="2.5">2.5x</div>
      <div class="tts-speed-option" data-speed="3">3x</div>
      <div class="tts-speed-option" data-speed="4">4x</div>
    </div>
  </div>
</div>
    </div>
  </div>

  <!-- Page Slider -->
  <div class="page-slider-wrapper">
    <div class="page-slider-container">
      <div class="page-slider-track" id="pageSliderTrack"></div>
    </div>
    <div class="page-slider-thumb" id="pageSliderThumb">1/1</div>
  </div>

  <!-- Figure Lightbox -->
  <div class="figure-lightbox" id="figureLightbox" onclick="closeLightbox()">
    <img id="lightboxImg" src="" alt="Figure">
  </div>

  <!-- Debug -->
  <div id="debugIcon" onclick="toggleDebug()" title="Debug">🪲</div>
  <div id="debugPanel">
    <div id="debugHeader">
      <span onclick="copyDebugLog()">📋 Copy</span>
      <span onclick="clearDebugLog()">🗑️ Clear</span>
    </div>
    <div id="debugLog"></div>
  </div>

  <script>
    // Debug logger
    const DEBUG = true;
    function log(msg, level = '') {
      if (!DEBUG) return;
      const time = new Date().toLocaleTimeString('en-GB');
      const logEl = document.getElementById('debugLog');
      const line = document.createElement('div');
      line.className = level;
      line.textContent = `[${time}] ${msg}`;
      logEl.appendChild(line);
      logEl.scrollTop = logEl.scrollHeight;
    }
    function logState(label) {
      log(`${label} | idx=${currentIndex} words=${words.length} clean=${useCleanText} chunk=${chunkSize}`, 'i');
    }
    function toggleDebug() {
      document.getElementById('debugPanel').classList.toggle('open');
    }
    function copyDebugLog() {
      const logEl = document.getElementById('debugLog');
      navigator.clipboard.writeText(logEl.innerText).then(() => {
        log('Log copied to clipboard', 'i');
      });
    }
    function clearDebugLog() {
      document.getElementById('debugLog').innerHTML = '';
      log('Log cleared');
    }
    // Close debug panel on outside click
    document.addEventListener('click', (e) => {
      const panel = document.getElementById('debugPanel');
      const icon = document.getElementById('debugIcon');
      if (panel.classList.contains('open') && !panel.contains(e.target) && !icon.contains(e.target)) {
        panel.classList.remove('open');
      }
    });

    // Page slider drag functionality
    (function() {
      const thumb = document.getElementById('pageSliderThumb');
      const track = document.getElementById('pageSliderTrack');
      let isDragging = false;

      // Update thumb position based on current page (RTL: right = page 1)
      window.updatePageSlider = function() {
        const totalPages = hasPages ? pages.length : 1;
        const trackWidth = track.offsetWidth;
        const trackLeft = 24; // padding from left
        // RTL: page 1 (idx 0) = right side, last page = left side
        const percent = totalPages > 1 ? (1 - currentPage / (totalPages - 1)) * 100 : 100;
        thumb.style.left = (trackLeft + (trackWidth * percent / 100)) + 'px';
        thumb.textContent = `${currentPage + 1}/${totalPages}`;
      };

      function handleSliderInput(e) {
        if (!hasPages || pages.length <= 1) return;
        const rect = track.getBoundingClientRect();
        let x = (e.clientX || e.touches[0].clientX) - rect.left;
        let percent = Math.max(0, Math.min(100, (x / rect.width) * 100));
        // RTL: right = first page, left = last page (invert percent)
        const pageIdx = Math.round((1 - percent / 100) * (pages.length - 1));
        if (pageIdx !== currentPage) {
          goToPage(pageIdx);
        }
        updatePageSlider();
      }

      thumb.addEventListener('mousedown', (e) => {
        isDragging = true;
        e.preventDefault();
      });
      thumb.addEventListener('touchstart', (e) => {
        isDragging = true;
      });

      document.addEventListener('mousemove', (e) => {
        if (isDragging) handleSliderInput(e);
      });
      document.addEventListener('touchmove', (e) => {
        if (isDragging) handleSliderInput(e);
      });

      document.addEventListener('mouseup', () => isDragging = false);
      document.addEventListener('touchend', () => isDragging = false);

      // Click on track to jump to page
      track.addEventListener('click', (e) => {
        handleSliderInput(e);
      });
    })();

    // Toggle buttons
    document.getElementById('wordModeBtn').addEventListener('click', function() {
      const chunkLabel = document.querySelector('#chunkSizeInput').previousElementSibling;
      const wpmLabel = document.querySelector('#wpmInput').previousElementSibling;
      const modeSelect = document.getElementById('modeSelect');

      if (this.textContent === 'מצב מילים') {
        this.textContent = 'מצב משפטים';
        chunkLabel.textContent = 'כמות משפטים:';
        modeSelect.value = 'sentences';
      } else {
        this.textContent = 'מצב מילים';
        chunkLabel.textContent = 'כמות מילים:';
        modeSelect.value = 'words';
      }
      toggleMode();
    });

    document.getElementById('cleanTextBtn').addEventListener('click', function() {
      if (this.textContent === 'טקסט נקי') {
        this.textContent = 'טקסט מכוער';
      } else {
        this.textContent = 'טקסט נקי';
      }
      toggleClean();
    });

    // Play button - toggle auto advance
    document.getElementById('playBtn').addEventListener('click', toggleAuto);

    // Reset button
    document.getElementById('resetBtn').addEventListener('click', reset);

    // Scroll tolerance input removed

    // Bottom bar input sync
    document.getElementById('chunkSizeInput').addEventListener('input', function() {
      chunkSize = parseInt(this.value) || 1;
      document.getElementById('chunkSize').value = chunkSize;
      renderText();
      if (autoAdvance) {
        stopAutoAdvance();
        startAutoAdvance();
      }
      // Invalidate TTS cache - settings changed
      if (ttsCache.size > 0) {
        clearTTSCache();
        document.getElementById('ttsLoadBtn').textContent = 'טען מחדש';
        log('[TTS] Cache cleared - chunk size changed', 'w');
      }
      updateRecommendedSpeed();
    });
    document.getElementById('wpmInput').addEventListener('input', function() {
      wpm = parseInt(this.value) || 200;
      document.getElementById('wpm').value = wpm;
      if (autoAdvance) {
        stopAutoAdvance();
        startAutoAdvance();
      }
      // Invalidate TTS cache - WPM affects speech rate
      if (ttsCache.size > 0) {
        clearTTSCache();
        document.getElementById('ttsLoadBtn').textContent = 'טען מחדש';
        log('[TTS] Cache cleared - WPM changed', 'w');
      }
      updateRecommendedSpeed();
    });

    // Wings - chunk navigation (inner wings)
    document.querySelector('.wing-left').addEventListener('click', nextChunk);
    document.querySelector('.wing-right').addEventListener('click', prevChunk);

    // Outer wings - page navigation
    document.querySelector('.wing-outer-left').addEventListener('click', nextPage);
    document.querySelector('.wing-outer-right').addEventListener('click', prevPage);

    // Theme management
    function setTheme(theme) {
      document.body.className = theme;
      localStorage.setItem('reading-pacer-theme', theme);
      document.querySelectorAll('#themeSelect, #settingsTheme').forEach(el => {
        if (el) el.value = theme;
      });
      log('Theme set: ' + (theme || 'Sweet Mars'));
    }
    function loadTheme() {
      const saved = localStorage.getItem('reading-pacer-theme') || '';
      document.body.className = saved;
      document.querySelectorAll('#themeSelect, #settingsTheme').forEach(el => {
        if (el) el.value = saved;
      });
    }
    loadTheme();
    log('Page loaded');

    // Simple loading overlay
    function showLoading(text = 'טוען...') {
      document.getElementById('loadingText').textContent = text;
      document.getElementById('loadingOverlay').classList.add('active');
    }
    function hideLoading() {
      document.getElementById('loadingOverlay').classList.remove('active');
    }

    // Async delay helper
    function delay(ms = 0) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    let words = [];
    let currentIndex = 0;
    let chunkSize = 1;
    let wpm = 200;
    let autoAdvance = false;
    let autoInterval = null;
    let dirtyText = '';
    let cleanedText = '';
    let useCleanText = true;

    // Page tracking (only used when \f detected from pdftotext)
    let pages = [];           // Array of page objects: { dirtyText, cleanText, words }
    let currentPage = 0;
    let hasPages = false;     // True if text has page breaks

    // Sentence mode
    let sentenceMode = false;
    let sentences = [];       // Array of { startIdx, endIdx } marking word indices for each sentence
    let currentSentence = 0;
    let scrollTolerance = 20;  // How far from 25% target before scrolling

    // VN Mode - visual novel style fading
    let vnMode = localStorage.getItem('reading-pacer-vnmode') === 'true';
    let vnRadius = parseInt(localStorage.getItem('reading-pacer-vnradius')) || 5;
    let vnSentenceBuffer = parseInt(localStorage.getItem('reading-pacer-vnsentencebuffer')) || 1;
    let vnBorder = localStorage.getItem('reading-pacer-vnborder') === 'true';
    let borderColor = localStorage.getItem('reading-pacer-border-color') || '#e0e0e0';
    let borderOpacity = parseInt(localStorage.getItem('reading-pacer-border-opacity')) || 60;
    let borderWidth = parseInt(localStorage.getItem('reading-pacer-border-width')) || 2;

    // Continuous highlight (no gap between read and current)
    let highlightContinuous = localStorage.getItem('reading-pacer-highlight-continuous') === 'true';

    // Half-bold mode (הדגשת חצי)
    let halfBoldMode = localStorage.getItem('reading-pacer-halfbold') === 'true';
    let halfBoldColor = localStorage.getItem('reading-pacer-halfbold-color') || '';
    let halfBoldUnread = localStorage.getItem('reading-pacer-halfbold-unread') === 'true';
    let fakeCursorEnabled = localStorage.getItem('reading-pacer-fakecursor') === 'true';
    let fakeCursorBlink = localStorage.getItem('reading-pacer-fakecursor-blink') === 'true';
    let fakeCursorColor = localStorage.getItem('reading-pacer-fakecursor-color') || '#e0e0e0';

    // RSVP mode (Rapid Serial Visual Presentation)
    let rsvpMode = localStorage.getItem('reading-pacer-rsvp') === 'true';
    let rsvpFontSize = parseInt(localStorage.getItem('reading-pacer-rsvp-fontsize')) || 250;
    let rsvpGrid = localStorage.getItem('reading-pacer-rsvp-grid') === 'true';
    let rsvpGridOpacity = parseInt(localStorage.getItem('reading-pacer-rsvp-grid-opacity')) || 15;
    let rsvpTextHeight = parseInt(localStorage.getItem('reading-pacer-rsvp-text-height')) || 22;
    let rsvpTextPosition = parseInt(localStorage.getItem('reading-pacer-rsvp-text-position')) || 0;
    let rsvpOrpMode = localStorage.getItem('reading-pacer-rsvp-orp') === 'true';
    let redicleUpdateCount = 2; // Counter: update redicle for first N words after layout change

    // Global brightness and contrast
    let globalBrightness = parseInt(localStorage.getItem('reading-pacer-brightness')) || 100;
    let globalContrast = parseInt(localStorage.getItem('reading-pacer-contrast')) || 100;

    function applyGlobalFilters() {
      // Apply to content elements only, NOT body (filter on body breaks position:fixed)
      const filterValue = `brightness(${globalBrightness / 100}) contrast(${globalContrast / 100})`;
      document.body.style.filter = ''; // Clear any previous body filter
      document.getElementById('textDisplay').style.filter = filterValue;
      document.getElementById('rsvpOverlay').style.filter = filterValue;
    }

    // Junk patterns to remove (for Open University / similar PDF watermarks)
    const cleanPatterns = [
      // === PHASE 1: Remove junk lines ===
      { regex: /^[_\-\u200E\u200F\u202A\u202B\u202C\u202D\u202E\s]+$/gm },           // Separator lines
      { regex: /^.*\d{2}\/\d{2}\/\d{4}\s+\d{2}:\d{2}:\d{2}.*$/gm },                  // Timestamps
      { regex: /^.*\.(indb|indd).*$/gmi },                                           // InDesign file refs (.indb AND .indd)
      { regex: /^.*do not distribute.*$/gmi },                                       // Distribution warning
      { regex: /^.*File #\d+\s*belongs to.*$/gmi },                                  // File # watermarks
      { regex: /^.*\d{6,}.*@.*\.com.*$/gmi },                                        // Email watermarks
      { regex: /^.*\d{6,}.*\w+at\w+\.com.*$/gmi },                                   // Obfuscated emails
      { regex: /^[\u200E\u200F\u202A\u202B\u202C\s]*[A-Z]{5,15}[\u200E\u200F\u202A\u202B\u202C\s]*$/gm }, // Random uppercase
      { regex: /^[\u200E\u200F\u202A\u202B\u202C\s]*\d{1,6}[\u200E\u200F\u202A\u202B\u202C\s]*$/gm },     // Standalone numbers
      { regex: /^.*\bUntitled\b.*$/gm },                                             // Untitled markers
      { regex: /^.*0\s*\d{6,}.*$/gm },                                               // Barcode numbers
      { regex: /^[\u200E\u200F\u202A\u202B\u202C\u202D\u202E\u2066\u2067\u2068\u2069\s\t]+$/gm }, // RTL marks only
      // === NEW: Watermark names ===
      { regex: /^(Ilay|Vardinon)$/gm },                                              // Publisher watermark names
      // === NEW: Repeated digits (OCR artifacts) ===
      { regex: /^([0-9])\1{15,}$/gm },                                               // 15+ repeated same digit
      // === NEW: Product/catalog codes ===
      { regex: /^(מק"ט|מסת"ב|דאנאקוד)\s*.*$/gm },                                    // Hebrew product codes
      { regex: /^ISBN\s+[\d\-]+$/gm },                                               // Standalone ISBN
      // === NEW: Roman numerals alone on line ===
      { regex: /^(i{1,3}|iv|vi{0,3}|ix|x{1,3}|xi{1,3}|xiv|xv|xvi{0,3}|xix|xx{1,3})$/gmi }, // Roman numerals i-xxx
      // === NEW: Diacritics-only lines (Hebrew vowel points) ===
      { regex: /^[\u0591-\u05C7]+$/gm },                                             // Only Hebrew vowel marks
      // === NEW: Single Latin letters ===
      { regex: /^[a-z]$/gmi },                                                        // Single letter lines

      // === PHASE 2: Fix reversed parentheses from RTL extraction ===
      // Pattern: ) X( → (X)
      { regex: /\)\s*([A-Za-z0-9]+)\s*\(/g, replacement: '($1)' },                   // Fix reversed parens
      // Fix broken parentheses patterns from pdftotext: (‪,)word → (word), (‪ )word → (word)
      { regex: /\([\u200E\u200F\u202A\u202B\u202C\u202D\u202E\u2066\u2067\u2068\u2069\s,]*\)[\u200E\u200F\u202A\u202B\u202C\u202D\u202E\u2066\u2067\u2068\u2069\s]*([a-zA-Z][a-zA-Z\s-]*)[\u200E\u200F\u202A\u202B\u202C\u202D\u202E\u2066\u2067\u2068\u2069]*/g, replacement: '($1)' },

      // === PHASE 3: Strip RTL/bidi marks ===
      { regex: /[\u200E\u200F\u202A\u202B\u202C\u202D\u202E\u2066\u2067\u2068\u2069]/g, replacement: '' },

      // === PHASE 4: Fix spacing between languages ===
      { regex: /\)(?=[\u0590-\u05FF])/g, replacement: ') ' },
      { regex: /([\u0590-\u05FF])\(/g, replacement: '$1 (' },
      { regex: /\.(?=[\u0590-\u05FFa-zA-Z])/g, replacement: '. ' },
      { regex: /([a-zA-Z])([\u0590-\u05FF])/g, replacement: '$1 $2' },
      { regex: /([\u0590-\u05FF])([a-zA-Z])/g, replacement: '$1 $2' },

      // === PHASE 5: Fix Hebrew final letters (pdftotext often misses these) ===
      { regex: /מ(?=\s|[^\u0590-\u05FF]|$)/g, replacement: 'ם' },  // mem → final mem
      { regex: /נ(?=\s|[^\u0590-\u05FF]|$)/g, replacement: 'ן' },  // nun → final nun
      { regex: /צ(?=\s|[^\u0590-\u05FF]|$)/g, replacement: 'ץ' },  // tsadi → final tsadi
      { regex: /פ(?=\s|[^\u0590-\u05FF]|$)/g, replacement: 'ף' },  // pe → final pe
      { regex: /כ(?=\s|[^\u0590-\u05FF]|$)/g, replacement: 'ך' },  // kaf → final kaf

      // === PHASE 6: Fix leading zeros before Hebrew ===
      { regex: /^0([א-ת])/gm, replacement: '$1' },                                   // Remove leading 0 before Hebrew

      // === PHASE 7: Collapse whitespace ===
      { regex: /\n{3,}/g, replacement: '\n\n' },                                     // Multiple blank lines
    ];

    // Fix reversed English from RTL extraction
    // Known reversed terms from biology/chemistry OCR extraction
    const reversedTerms = {
      // Elements & atoms
      'negordyh': 'hydrogen', 'muileh': 'helium', 'nobrac': 'carbon', 'negyxo': 'oxygen',
      'negortin': 'nitrogen', 'muidos': 'sodium', 'muissatop': 'potassium', 'muiclac': 'calcium',
      'enirolhc': 'chlorine', 'nogra': 'argon', 'noen': 'neon', 'enidoi': 'iodine',
      'enimora': 'bromine', 'eniroulf': 'fluorine', 'ruhplus': 'sulfur', 'surohpsohp': 'phosphorus',
      'nori': 'iron', 'cniz': 'zinc', 'reppoc': 'copper', 'revlis': 'silver', 'dlog': 'gold',
      // Particles & chemistry
      'nortcele': 'electron', 'notorp': 'proton', 'nortuen': 'neutron', 'mota': 'atom',
      'elucelom': 'molecule', 'noi': 'ion', 'dnob': 'bond', 'cinoi': 'ionic', 'tnelavoc': 'covalent',
      'ralop': 'polar', 'ralopnon': 'nonpolar', 'llehs': 'shell', 'latibro': 'orbital',
      // Biology terms
      'llec': 'cell', 'nietorp': 'protein', 'emyzne': 'enzyme', 'esoculg': 'glucose',
      'enarbmem': 'membrane', 'suelcun': 'nucleus', 'msalpotic': 'cytoplasm',
      'airdnohcotim': 'mitochondria', 'tsalporolhc': 'chloroplast', 'emosibir': 'ribosome',
      'emosomorhc': 'chromosome', 'eneg': 'gene', 'dipil': 'lipid',
      // Structure terms
      'erutcurts': 'structure', 'yramirp': 'primary', 'yradnoces': 'secondary',
      'yraitret': 'tertiary', 'yranretauq': 'quaternary', 'ledom': 'model',
      // Ordinals
      'tsrif': 'first', 'dnoces': 'second', 'driht': 'third', 'htrof': 'fourth', 'htfif': 'fifth',
      // Common words
      'retaw': 'water', 'ygerne': 'energy', 'thgil': 'light', 'taeh': 'heat',
      'dica': 'acid', 'esab': 'base', 'tlas': 'salt', 'ragus': 'sugar',
      // Partial/short
      'rtcele': 'electr', 'econd': 'econd', 'riht': 'thir'
    };

    function fixReversedEnglish(text) {
      let result = text;

      // 1. Fix reversed parentheses pattern: ) word ( → (word)
      result = result.replace(/\)\s*([A-Za-z0-9]+)\s*\(/g, '($1)');

      // 2. Fix known reversed terms (case-insensitive)
      for (const [reversed, correct] of Object.entries(reversedTerms)) {
        const regex = new RegExp(`\\b${reversed}\\b`, 'gi');
        result = result.replace(regex, correct);
      }

      // 3. Heuristic: reverse any remaining word starting with unusual clusters
      result = result.replace(/\b([a-zA-Z]{5,})\b/g, (match) => {
        // Skip if already looks like English (common patterns)
        if (/(?:ing|tion|ment|ness|able|ible|ous|ive|ary|ory|ly|er|ed|es|s)$/i.test(match)) {
          return match;
        }
        // Check for very unusual starting clusters that almost never occur in English
        if (/^(ll[^aeiouy]|dn|hs|hc[^aeiouy]|gn[^aeiouy]|tp|tn|tm|tk)/i.test(match)) {
          const reversed = match.split('').reverse().join('');
          // Only reverse if result looks more normal
          if (/(?:ing|tion|ment|ness|able|ible|ous|ive|ary|ory|al|en|er|ed|es|s)$/i.test(reversed) ||
              /^(the|pre|pro|con|dis|un|re|in|en|ex|de|be|sub|anti|auto|bio|co)/i.test(reversed)) {
            return reversed;
          }
        }
        return match;
      });

      return result;
    }

    // Join fragmented lines from PDF diagram/table extraction
    function joinFragmentedLines(text) {
      // First pass: detect "diagram regions" (many short lines) and remove blanks within them
      let lines = text.split('\n');
      const maxShortLine = 35;
      const minDiagramRegion = 4;

      // Find diagram regions and mark internal blanks for removal
      let i = 0;
      while (i < lines.length) {
        let regionStart = i;
        let shortCount = 0;
        let j = i;

        // Scan forward counting short/empty lines
        while (j < lines.length) {
          const line = lines[j].trim();
          if (line.length === 0) { j++; continue; }
          if (line.length <= maxShortLine && !/[.!?]$/.test(line)) {
            shortCount++;
            j++;
          } else {
            break;
          }
        }

        // If diagram region found, mark internal blanks
        if (shortCount >= minDiagramRegion) {
          for (let k = regionStart; k < j; k++) {
            if (lines[k].trim().length === 0) {
              lines[k] = '\x00'; // Mark for removal
            }
          }
        }
        i = Math.max(i + 1, j);
      }

      // Remove marked blanks
      lines = lines.filter(l => l !== '\x00');

      // Second pass: join consecutive short lines
      const result = [];
      i = 0;
      const sentenceEnd = /[.!?:،؛]$/;
      const isHeading = /^(פרק|חטיבה|סעיף|איור|טבלה|\d+\.\d+)\s/;

      while (i < lines.length) {
        let currentLine = lines[i].trim();

        if (!currentLine) {
          result.push('');
          i++;
          continue;
        }

        // Join consecutive short lines
        while (
          currentLine.length < maxShortLine &&
          !sentenceEnd.test(currentLine) &&
          !isHeading.test(currentLine) &&
          i + 1 < lines.length &&
          lines[i + 1].trim().length > 0 &&
          lines[i + 1].trim().length < maxShortLine
        ) {
          i++;
          const nextLine = lines[i].trim();

          if (currentLine.endsWith('-') || currentLine.endsWith('־')) {
            currentLine = currentLine.slice(0, -1) + nextLine;
          } else if (/^[,.)،؛]/.test(nextLine)) {
            currentLine = currentLine + nextLine;
          } else {
            currentLine = currentLine + ' ' + nextLine;
          }
        }

        result.push(currentLine);
        i++;
      }

      return result.join('\n');
    }

    async function cleanTextAsync(text) {
      let result = text;

      // Phase 1: Apply regex cleanup patterns
      const total = cleanPatterns.length;
      for (let i = 0; i < total; i++) {
        const p = cleanPatterns[i];
        if (p.replacement !== undefined) {
          result = result.replace(p.regex, p.replacement);
        } else {
          result = result.replace(p.regex, '');
        }
        // Yield to UI every few patterns
        if (i % 3 === 0) await delay(0);
      }

      // Phase 2: Fix reversed English from RTL extraction
      result = fixReversedEnglish(result);
      await delay(0);

      // Phase 3: Join fragmented lines from PDF diagrams/tables
      result = joinFragmentedLines(result);

      return result.trim();
    }

    async function loadText() {
      log('loadText() called');
      const text = document.getElementById('textInput').value.trim();
      if (!text) return alert('אנא הכנס טקסט');

      showLoading('קורא טקסט...');
      await delay(10);

      // Check for page breaks (form feed from pdftotext)
      hasPages = text.includes('\f');
      log(`hasPages=${hasPages}`);

      if (hasPages) {
        await loadPagesAsync(text);
      } else {
        dirtyText = text;
        cleanedText = await cleanTextAsync(text);
        log(`dirty=${dirtyText.length}chars, clean=${cleanedText.length}chars`);

        await initPacerAsync(useCleanText ? cleanedText : dirtyText);
      }
      hideLoading();
      
      // Save to library (skip if loading from library)
      if (!currentLibraryId) {
        if (hasPages) {
          currentLibraryId = await saveToLibrary(text, pages);
        } else {
          currentLibraryId = await saveToLibrary(text);
        }
        log('Saved to library: ' + currentLibraryId);
      }
    }

    // Process multi-page PDF text
    async function loadPagesAsync(text) {
      const rawPages = text.split('\f').filter(p => p.trim().length > 0);
      log(`Found ${rawPages.length} pages`);

      pages = [];
      for (let i = 0; i < rawPages.length; i++) {
        const dirty = rawPages[i].trim();
        const clean = await cleanTextAsync(dirty);
        pages.push({ dirtyText: dirty, cleanText: clean, words: null });
      }

      currentPage = 0;
      await initCurrentPage();
      updatePageNav();
    }

    // Initialize words for current page
    async function initCurrentPage() {
      const page = pages[currentPage];
      const text = useCleanText ? page.cleanText : page.dirtyText;


      // Parse words for this page
      const pageWords = [];
      const lines = text.split('\n');
      for (let lineIdx = 0; lineIdx < lines.length; lineIdx++) {
        const line = lines[lineIdx];
        const trimmedLine = line.trim();

        if (trimmedLine === '') {
          if (pageWords.length > 0 && !pageWords[pageWords.length - 1].isParagraph) {
            pageWords.push({ text: '', isWord: false, isParagraph: true, isLine: false });
          }
          continue;
        }

        if (lineIdx > 0 && pageWords.length > 0 && !pageWords[pageWords.length - 1].isParagraph) {
          pageWords.push({ text: '', isWord: false, isParagraph: false, isLine: true });
        }

        // Fix detached punctuation: "word ." -> "word."
        const cleanedLine = trimmedLine.replace(/\s+\./g, '.').replace(/\s+,/g, ',').replace(/\s+:/g, ':').replace(/\s+;/g, ';');
        const tokens = cleanedLine.split(/\s+/).filter(w => w.length > 0);
        tokens.forEach(token => {
          pageWords.push({
            text: token,
            isWord: /[\u0590-\u05FFa-zA-Z]/.test(token),
            isParagraph: false,
            isLine: false
          });
        });
      }

      words = pageWords;
      currentIndex = 0;

      // Show UI
      document.getElementById('inputArea').style.display = 'none';
      document.getElementById('controls').style.display = 'none';
      document.getElementById('textDisplay').style.display = 'block';

      parseSentences();
      markHeadings();
      logState('initCurrentPage done');
      renderText();
      updateWordProgress();
      if (typeof updatePageSlider === 'function') updatePageSlider();
    }

    function updatePageNav() {
      const select = document.getElementById('pageSelect');
      select.innerHTML = pages.map((_, i) =>
        `<option value="${i}" ${i === currentPage ? 'selected' : ''}>עמוד ${i + 1} / ${pages.length}</option>`
      ).join('');
      if (typeof updatePageSlider === 'function') updatePageSlider();
    }

    function goToPage(pageIdx, keepAutoAdvance = false) {
      pageIdx = parseInt(pageIdx);
      if (pageIdx < 0 || pageIdx >= pages.length) return;
      if (autoAdvance && !keepAutoAdvance) toggleAuto();
      currentPage = pageIdx;
      initCurrentPage();
      updatePageNav();
      // Invalidate TTS cache - page changed
      if (ttsCache.size > 0) {
        clearTTSCache();
        document.getElementById('ttsLoadBtn').textContent = 'טען מחדש';
        log('[TTS] Cache cleared - page changed', 'w');
      }
      log(`Jumped to page ${pageIdx + 1}`);
    }

    function nextPage() {
      if (currentPage < pages.length - 1) {
        goToPage(currentPage + 1);
      }
    }

    function prevPage() {
      if (currentPage > 0) {
        goToPage(currentPage - 1);
      }
    }

    async function loadFile(event) {
      const file = event.target.files[0];
      if (!file) return;

      // PDF detection - show helper modal
      if (file.name.match(/\.pdf$/i)) {
        showPdfModal(file.name);
        event.target.value = ''; // Reset input
        return;
      }

      showLoading('קורא קובץ...');

      const reader = new FileReader();
      reader.onload = async (e) => {
        const text = e.target.result;
        document.getElementById('textInput').value = text;

        // Check for page breaks
        hasPages = text.includes('\f');
        log(`loadFile hasPages=${hasPages}`);

        if (hasPages) {
          await loadPagesAsync(text);
        } else {
          dirtyText = text;
          cleanedText = await cleanTextAsync(text);
          await initPacerAsync(useCleanText ? cleanedText : dirtyText);
        }
        hideLoading();
        if (typeof saveState === 'function') saveState();
        
        // Save to library
        if (hasPages) {
          saveToLibrary(text, pages).then(id => {
            currentLibraryId = id;
            log('Saved to library: ' + id);
          });
        } else {
          saveToLibrary(text).then(id => {
            currentLibraryId = id;
            log('Saved to library: ' + id);
          });
        }
      };
      reader.readAsText(file);
    }

    async function loadSampleText() {
      const sample = `ניסויים מדעיים בביולוגיה

אפשר לערוך מחקרים בדרכים רבות, במיוחד בביולוגיה. יש ביולוגים העורכים סקרים; הם עורכים תצפיות מבלי לנסח השערות. יש המעלים השערות ומותירים את ביצוע הניסויים לאחרים. עם זאת, למרות היקפו הרחב של התחום כולו, ניסויים מדעיים מתוכננים בעקביות באותו אופן.

החוקרים בוחרים בכל פעם במשתנה בלתי־תלוי אחד, מנסים לשנות רק אותו בניסוי ורואים מה קורה בעקבות זאת למשתנה תלוי יחיד. כדי להמחיש כיצד נעשים ניסויים בביולוגיה אנו מסכמים כאן שני ניסויים מתוך מחקרים שהתפרסמו בעבר.

טוגנים וכאבי בטן

בשנת 1996 אישרה רשות המזון והתרופות האמריקנית (FDA) את השימוש בחומר Olestra, תחליף שומן המיוצר מסוכר ומשמן צמחי, כתוסף מזון. טוגנים מתפוחי אדמה היו המוצר הראשון שהכיל Olestra ויצא לשוק בארצות הברית.

תוך זמן קצר פרצה מחלוקת עזה סביב תוסף המזון הזה. רבים התלוננו על כאבי בטן לאחר אכילת הטוגנים וחשבו שהאשמה הייתה ב־ Olestra. שנתיים לאחר השקת המוצר, חוקרים מבית הספר לרפואה של אוניברסיטת ג'ונס הופקינס תכננו ניסוי שנועד לבדוק אם התוסף גורם לכאבי בטן.
\f
תכנון הניסוי

על פי החיזוי שניסחו החוקרים, אם Olestra גורם כאבי בטן אז מי שאוכל Olestra צפוי לסבול מהתכווצויות יותר ממי שאינו אוכל את התוסף. כדי לבחון את החיזוי הם השתמשו באולם קולנוע בשיקגו כ"מעבדה".

הם כינסו 1,100 אנשים בגילים שבין 13 ל־ 38 וביקשו מהם לאכול טוגנים בעת צפייה בסרט. כל משתתף בניסוי קיבל שקית לא מסומנת שהכילה כ־ 360 גרם טוגנים.

בניסוי זה, האנשים שקיבלו טוגנים שהכילו Olestra היו קבוצת הניסוי, ואלה שקיבלו טוגנים ללא Olestra היו קבוצת הביקורת. המשתנה הבלתי־תלוי היה נוכחות או היעדר של Olestra בטוגנים.

ימים אחדים לאחר תום הניסוי התקשרו החוקרים לכל המשתתפים ואספו מהם מידע על כל גילוי של בעיה במעיים או בקיבה שסבלו ממנה לאחר הצפייה בסרט.
\f
תוצאות ומסקנות

מבין 563 האנשים שהיו בקבוצת הניסוי, 89 (15.8 אחוזים) התלוננו על כאבי בטן. אבל כך קרה גם ל־ 93 מבין 529 (17.6 אחוזים) האנשים שהיו בקבוצת הביקורת, שאכלו טוגנים רגילים.

הסיכוי של אנשים לסבול מכאבי בטן היה דומה מאוד בלי קשר לטוגנים שאכלו — עם או בלי Olestra. התוצאות האלה לא איששו את החיזוי, והחוקרים הסיקו שאכילת Olestra אינה גורמת להתכווצויות במעיים.

פרפרים וציפורים

פרפר הטווס קיבל את שמו בגלל הכתמים הגדולים והצבעוניים על כנפיו. בשנת 2005 דיווחו חוקרים על תוצאות ניסויים שבדקו אם דפוסי התנהגות מסוימים מסייעים לפרפרי הטווס להתגונן מפני ציפורים הטורפות חרקים.

החוקרים החלו את המחקר בשני ממצאים מתצפיות. האחד: כאשר פרפר טווס נמצא במנוחה הוא מקפל את כנפיו, וכך רק הצד התחתון הכהה גלוי לעין. השני: כאשר פרפר רואה טורף מתקרב הוא פותח וסוגר את כנפיו בתנועות מהירות, ובתוך כך גם מניע את הכנפיים האחוריות באופן שיוצר צליל שריקה וסדרה של נקישות.

החוקרים תהו מדוע פרפר הטווס טופח בכנפיו. לאחר שסקרו מחקרים קודמים הם העלו שתי השערות שעשויות להסביר את ההתנהגות הזו.`;
      document.getElementById('textInput').value = sample;

      // Sample has pages
      hasPages = true;
      await loadPagesAsync(sample);
      hideLoading();
    }

    function toggleClean() {
      log('toggleClean() called, was=' + useCleanText);
      useCleanText = !useCleanText;
      const btn = document.getElementById('cleanBtn');
      btn.classList.toggle('active', useCleanText);
      btn.textContent = useCleanText ? '🧹 נקי' : '📄 מקורי';

      // Re-init with same position ratio
      const ratio = words.length > 0 ? currentIndex / words.length : 0;
      log(`ratio=${ratio.toFixed(3)}`);

      // Get text based on mode (pages or single)
      let text;
      if (hasPages) {
        text = useCleanText ? pages[currentPage].cleanText : pages[currentPage].dirtyText;
      } else {
        text = useCleanText ? cleanedText : dirtyText;
      }

      // Split by lines, preserving breaks (same as initPacer)
      words = [];
      const lines = text.split('\n');
      lines.forEach((line, lineIdx) => {
        const trimmedLine = line.trim();
        if (trimmedLine === '') {
          if (words.length > 0 && !words[words.length - 1].isParagraph) {
            words.push({ text: '', isWord: false, isParagraph: true, isLine: false });
          }
          return;
        }
        if (lineIdx > 0 && words.length > 0 && !words[words.length - 1].isParagraph) {
          words.push({ text: '', isWord: false, isParagraph: false, isLine: true });
        }
        // Fix detached punctuation: "word ." -> "word."
        const cleanedLine = trimmedLine.replace(/\s+\./g, '.').replace(/\s+,/g, ',').replace(/\s+:/g, ':').replace(/\s+;/g, ';');
        const tokens = cleanedLine.split(/\s+/).filter(w => w.length > 0);
        tokens.forEach(token => {
          words.push({
            text: token,
            isWord: /[\u0590-\u05FFa-zA-Z]/.test(token),
            isParagraph: false,
            isLine: false
          });
        });
      });

      currentIndex = Math.min(Math.floor(ratio * words.length), words.length - 1);
      currentIndex = Math.max(0, currentIndex);

      markHeadings();
      logState('after toggleClean');
      renderText();
      updateWordProgress();
    }

    async function initPacerAsync(text) {
      log('initPacerAsync() called with ' + text.length + ' chars');

      // Split by lines, preserving both single and double line breaks
      words = [];
      const lines = text.split('\n');
      const totalLines = lines.length;

      for (let lineIdx = 0; lineIdx < totalLines; lineIdx++) {
        const line = lines[lineIdx];
        const trimmedLine = line.trim();

        // Empty line = paragraph break (from double newlines)
        if (trimmedLine === '') {
          if (words.length > 0 && !words[words.length - 1].isParagraph) {
            words.push({ text: '', isWord: false, isParagraph: true, isLine: false });
          }
          continue;
        }

        // Add line break before this line (unless first line or after paragraph)
        if (lineIdx > 0 && words.length > 0 && !words[words.length - 1].isParagraph) {
          words.push({ text: '', isWord: false, isParagraph: false, isLine: true });
        }

        // Add words from this line
        // Fix detached punctuation: "word ." -> "word."
        const cleanedLine = trimmedLine.replace(/\s+\./g, '.').replace(/\s+,/g, ',').replace(/\s+:/g, ':').replace(/\s+;/g, ';');
        const tokens = cleanedLine.split(/\s+/).filter(w => w.length > 0);
        tokens.forEach(token => {
          words.push({
            text: token,
            isWord: /[\u0590-\u05FFa-zA-Z]/.test(token),
            isParagraph: false,
            isLine: false
          });
        });

        // Yield to UI periodically
        if (lineIdx % 100 === 0) await delay(0);
      }

      currentIndex = 0;
      log('currentIndex set to 0');

      // Update settings
      chunkSize = parseInt(document.getElementById('chunkSize').value) || 1;
      wpm = parseInt(document.getElementById('wpm').value) || 200;

      // Hide input, show pacer
      document.getElementById('inputArea').style.display = 'none';
      document.getElementById('controls').style.display = 'none';
      document.getElementById('textDisplay').style.display = 'block';

      parseSentences();
      markHeadings();
      logState('initPacerAsync done');
      renderText();
      updateWordProgress();
    }

    // Parse sentence boundaries - simple dot to dot
    function parseSentences() {
      sentences = [];
      wordToSentenceMap = null; // Invalidate cache
      let sentenceStart = 0;

      // Check if a period is a decimal point (between two digits like 1.5)
      function isDecimalPoint(text) {
        return /\d\.\d/.test(text);
      }

      for (let i = 0; i < words.length; i++) {
        const w = words[i];

        // Check if token contains a period (but not a decimal point)
        if (w.text && w.text.includes('.') && !isDecimalPoint(w.text)) {
          sentences.push({ startIdx: sentenceStart, endIdx: i + 1 });
          sentenceStart = i + 1;
        }
      }

      // Last chunk if no period at end
      if (sentenceStart < words.length) {
        sentences.push({ startIdx: sentenceStart, endIdx: words.length });
      }

      log(`Parsed ${sentences.length} sentences`);
      currentSentence = 0;
    }

    // Mark short paragraphs (2-9 words) as headings
    function markHeadings() {
      let paraStart = 0;
      let headingCount = 0;

      for (let i = 0; i <= words.length; i++) {
        const w = words[i];
        const isEnd = !w || w.isParagraph;

        if (isEnd) {
          // Count actual words in this paragraph
          let wordCount = 0;
          for (let j = paraStart; j < i; j++) {
            if (words[j].isWord) wordCount++;
          }

          // Mark as heading if 2-9 words
          if (wordCount >= 2 && wordCount <= 9) {
            for (let j = paraStart; j < i; j++) {
              words[j].isHeading = true;
            }
            headingCount++;
          }

          paraStart = i + 1;
        }
      }

      log(`Marked ${headingCount} headings`);
    }

    function toggleMode() {
      const mode = document.getElementById('modeSelect').value;
      sentenceMode = (mode === 'sentences');
      const chunkInput = document.getElementById('chunkSize');
      chunkInput.style.display = sentenceMode ? 'none' : 'inline-block';
      
      // Toggle sentence-mode class for CSS
      const textDisplay = document.getElementById('textDisplay');
      textDisplay.classList.toggle('sentence-mode', sentenceMode);

      if (sentenceMode && sentences.length > 0) {
        // Find which sentence contains current word
        currentSentence = sentences.findIndex(s => currentIndex >= s.startIdx && currentIndex < s.endIdx);
        if (currentSentence < 0) currentSentence = 0;
        currentIndex = sentences[currentSentence].startIdx;
      }

      log(`Mode: ${mode}, sentenceMode=${sentenceMode}`);
      renderText();
      updateWordProgress();
    }

    // VN Mode: batch-based with progressive fade on previous batch
    // Cache for sentence lookup - rebuilt when sentences change
    let wordToSentenceMap = null;
    let cachedCurrentSentenceIdx = -1;
    let cachedCurrentIndex = -1;

    function buildWordToSentenceMap() {
      if (sentences.length === 0) return;
      wordToSentenceMap = new Array(words.length);
      for (let si = 0; si < sentences.length; si++) {
        const s = sentences[si];
        for (let wi = s.startIdx; wi < s.endIdx && wi < words.length; wi++) {
          wordToSentenceMap[wi] = si;
        }
      }
    }

    function getVnFadeClass(wordIdx) {
      if (!vnMode) return '';

      // Build map if needed
      if (!wordToSentenceMap || wordToSentenceMap.length !== words.length) {
        buildWordToSentenceMap();
      }

      // Use cached sentence lookups
      const wordSentence = wordToSentenceMap ? wordToSentenceMap[wordIdx] : -1;

      // Cache currentSentenceIdx - only recalculate when currentIndex changes
      if (cachedCurrentIndex !== currentIndex) {
        cachedCurrentIndex = currentIndex;
        cachedCurrentSentenceIdx = wordToSentenceMap ? wordToSentenceMap[currentIndex] : -1;
      }
      const currentSentenceIdx = cachedCurrentSentenceIdx;

      if (currentSentenceIdx < 0 || wordSentence === undefined) return 'vn-fade-6';

      // Calculate batch system (same as border)
      const currentBatch = Math.floor(currentSentenceIdx / vnSentenceBuffer);
      const wordBatch = Math.floor(wordSentence / vnSentenceBuffer);
      
      const batchStartSentence = currentBatch * vnSentenceBuffer;
      const batchEndSentence = Math.min(sentences.length - 1, batchStartSentence + vnSentenceBuffer - 1);
      
      // How far into current batch we are (word distance from batch start)
      const batchStartWordIdx = sentences[batchStartSentence].startIdx;
      const wordsIntoBatch = currentIndex - batchStartWordIdx;

      // Current chunk boundaries
      const chunkEnd = currentIndex + chunkSize;
      const peekEnd = chunkEnd + chunkSize;

      // CURRENT CHUNK: fully visible
      if (wordIdx >= currentIndex && wordIdx < chunkEnd) {
        return 'vn-fade-0';
      }

      // CURRENT BATCH (already read): fully visible
      if (wordBatch === currentBatch && wordIdx < currentIndex) {
        return 'vn-fade-0';
      }

      // CURRENT BATCH (peek ahead): slightly faded
      if (wordBatch === currentBatch && wordIdx >= chunkEnd && wordIdx < peekEnd) {
        return 'vn-fade-peek';
      }

      // CURRENT BATCH (further ahead): invisible
      if (wordBatch === currentBatch && wordIdx >= peekEnd) {
        return 'vn-fade-6';
      }

      // FUTURE BATCHES: invisible
      if (wordBatch > currentBatch) {
        return 'vn-fade-6';
      }

      // PREVIOUS BATCHES: only immediate previous batch fades, older ones stay invisible
      if (wordBatch < currentBatch) {
        const batchDistance = currentBatch - wordBatch;
        
        // Batches 2+ back: always fully invisible
        if (batchDistance >= 2) {
          return 'vn-fade-6';
        }
        
        // Immediate previous batch (1 back): start at 50%, fade per word
        // fade-1=50%, fade-2=37.5%, fade-3=25%, fade-4=12.5%, fade-5=0%, fade-6=0%
        const progressFade = Math.floor(wordsIntoBatch / 1); // 1 level per word
        const fadeLevel = Math.min(1 + progressFade, 6);
        return 'vn-fade-' + fadeLevel;
      }

      // Fallback
      return 'vn-fade-6';
    }

    // Format word text with half-bold (bold first N letters)
    // For words 6+ chars, use 3 letters; otherwise use 2
    function formatHalfBold(text) {
      if (text.length <= 1) return text;
      const letters = text.length >= 6 ? 3 : 2;
      const prefix = text.slice(0, letters);
      const suffix = text.slice(letters);
      return `<span class="half-bold-prefix">${prefix}</span><span class="half-bold-suffix">${suffix}</span>`;
    }

    // ORP (Optimal Recognition Point) calculation for Spritz-style reading
    function getOrpIndex(word) {
      // Use actual word length (symbols, numbers, letters all count)
      const len = word.length;
      if (len <= 1) return 0;
      if (len <= 3) return 0;       // 1-3 chars: 1st char
      if (len <= 5) return 1;       // 4-5 chars: 2nd char
      if (len <= 9) return 2;       // 6-9 chars: 3rd char
      return 3;                     // 10+ chars: 4th char
    }

    function formatOrpWord(word) {
      // For ORP, treat the whole word as content (don't strip "punctuation")
      // Single symbols like ❹ should be displayed with ORP highlighting
      const cleanWord = word.trim();

      // Check if word is NOT Hebrew - needs dir="ltr" in RTL document
      const isHebrew = /^[\u0590-\u05FF]/.test(cleanWord);
      const dirAttr = !isHebrew ? ' dir="ltr"' : '';

      if (cleanWord.length === 0) return `<span class="orp-word"${dirAttr}>${word}</span>`;

      const orpIdx = getOrpIndex(cleanWord);
      const before = cleanWord.slice(0, orpIdx);
      const orp = cleanWord[orpIdx];
      const after = cleanWord.slice(orpIdx + 1);

      return `<span class="orp-word"${dirAttr}>${before}<span class="orp-letter">${orp}</span>${after}</span>`;
    }

    // Update redicle position - call on layout changes (resize, font, sliders), NOT on word changes
    function updateRediclePosition() {
      const container = document.getElementById('rsvpContent');
      const redicle = document.getElementById('rsvpRedicle');
      const overlay = document.getElementById('rsvpOverlay');
      const wordEl = container?.querySelector('.orp-word');

      if (!redicle || !overlay || !container) return;

      const containerRect = container.getBoundingClientRect();
      const overlayRect = overlay.getBoundingClientRect();

      // X position: container center + horizontal position adjustment
      const horizontalShift = (rsvpTextPosition / 100) * containerRect.width;
      const redicleX = containerRect.left - overlayRect.left + containerRect.width / 2 + horizontalShift;
      redicle.style.setProperty('--redicle-x', redicleX + 'px');

      // Vertical position: based on word if present
      if (wordEl) {
        const wordRect = wordEl.getBoundingClientRect();
        const wordTop = wordRect.top - overlayRect.top;
        const wordBottom = wordRect.bottom - overlayRect.top;
        redicle.style.setProperty('--redicle-top', (wordTop - 5) + 'px');
        redicle.style.setProperty('--redicle-bottom', (wordBottom + 5) + 'px');
      }
    }

    // Position word so ORP letter is at container center - call on every word change
    function positionOrpWord(container) {
      const wordEl = container.querySelector('.orp-word');
      const highlight = container.querySelector('.orp-letter');
      if (!wordEl) return;

      // Reset position first to get accurate measurements
      wordEl.style.left = '0';
      wordEl.style.top = '0';

      // Use getBoundingClientRect for reliable cross-script positioning
      const containerRect = container.getBoundingClientRect();

      // If we have a highlight letter, center on it; otherwise center the whole word
      const targetEl = highlight || wordEl;
      const targetRect = targetEl.getBoundingClientRect();

      // Calculate where target currently is vs where it should be (container center)
      const containerCenter = containerRect.left + containerRect.width / 2;
      const targetCenter = targetRect.left + targetRect.width / 2;
      let offset = containerCenter - targetCenter;

      // Apply horizontal position adjustment
      const horizontalShift = (rsvpTextPosition / 100) * containerRect.width;
      offset += horizontalShift;

      wordEl.style.left = offset + 'px';
      wordEl.style.top = '0';
    }

    // Re-position ORP on window resize
    let orpResizeTimeout;
    window.addEventListener('resize', function() {
      if (rsvpMode && rsvpOrpMode) {
        clearTimeout(orpResizeTimeout);
        orpResizeTimeout = setTimeout(() => {
          const content = document.getElementById('rsvpContent');
          if (content && content.classList.contains('orp-mode')) {
            positionOrpWord(content);
            updateRediclePosition();
          }
        }, 50);
      }
    });

    function joinWithSmartSpacing(wordObjects, startIdx, isCurrentChunk = false, isUnread = false) {
      return wordObjects.map((w, i) => {
        const globalIdx = startIdx + i;
        // Paragraph break (double newline)
        if (w.isParagraph) {
          return '<span class="paragraph-break"></span>';
        }
        // Line break (single newline)
        if (w.isLine) {
          return '<br>';
        }
        // Punctuation/numbers: wrap in span for VN mode fade, plain text otherwise
        if (!w.isWord) {
          if (vnMode) {
            const vnClass = getVnFadeClass(globalIdx);
            return `<span class="${vnClass}">${w.text}</span>`;
          }
          return w.text;
        }
        // Real word: clickable span with space before (unless first or after break)
        const headingClass = w.isHeading ? ' heading' : '';
        const vnClass = getVnFadeClass(globalIdx);
        // Add word-pop class for current chunk words (not in VN mode)
        const popClass = (isCurrentChunk && !vnMode) ? ' word-pop' : '';
        // Apply half-bold formatting to current chunk, and unread text if enabled
        const applyHalfBold = halfBoldMode && (isCurrentChunk || (halfBoldUnread && isUnread));
        const wordContent = applyHalfBold ? formatHalfBold(w.text) : w.text;
        const span = `<span class="word${headingClass}${popClass}${vnClass ? ' ' + vnClass : ''}" onclick="setPosition(${globalIdx})">${wordContent}</span>`;
        const prevIsBreak = i > 0 && (wordObjects[i-1].isParagraph || wordObjects[i-1].isLine);
        return (i > 0 && !prevIsBreak) ? ' ' + span : span;
      }).join('');
    }

    // RSVP mode rendering - show current chunk in center of screen
    function renderRSVP() {
      const overlay = document.getElementById('rsvpOverlay');
      const content = document.getElementById('rsvpContent');
      const progress = document.getElementById('rsvpProgress');
      const grid = document.getElementById('rsvpGrid');

      if (!rsvpMode || words.length === 0) {
        overlay.classList.remove('active');
        document.body.classList.remove('rsvp-active');
        return;
      }

      overlay.classList.add('active');
      document.body.classList.add('rsvp-active');

      // Handle grid visibility
      if (rsvpGrid) {
        grid.classList.remove('hidden');
      } else {
        grid.classList.add('hidden');
      }

      // Determine current chunk boundaries (same logic as renderText)
      let currentEnd;
      if (sentenceMode && sentences.length > 0) {
        const lastSentIdx = Math.min(currentSentence + chunkSize - 1, sentences.length - 1);
        const lastSent = sentences[lastSentIdx];
        currentEnd = lastSent ? lastSent.endIdx : words.length;
      } else {
        currentEnd = Math.min(currentIndex + chunkSize, words.length);
      }

      // Get current chunk words (only actual words, skip breaks)
      const chunkWordsArr = words.slice(currentIndex, currentEnd)
        .filter(w => w.isWord || (!w.isParagraph && !w.isLine));
      const wordCount = chunkWordsArr.filter(w => w.isWord).length;
      const chunkWords = chunkWordsArr
        .map(w => {
          if (halfBoldMode && w.isWord) {
            return formatHalfBold(w.text);
          }
          return w.text;
        })
        .join(' ');

      // Add fake cursor if enabled
      const cursorClass = fakeCursorBlink ? 'fake-cursor blink' : 'fake-cursor';
      const cursor = fakeCursorEnabled ? `<span class="${cursorClass}"></span>` : '';

      // Apply font styles from main text display
      const textDisplay = document.getElementById('textDisplay');
      content.style.fontFamily = textDisplay.style.fontFamily || '';
      content.style.letterSpacing = textDisplay.style.letterSpacing || '';
      content.style.lineHeight = textDisplay.style.lineHeight || '';

      // Dynamic padding based on word count and mode
      content.style.marginTop = rsvpTextHeight + '%';

      // ORP (Spritz) mode - single word with fixed focal point
      const useOrpMode = rsvpOrpMode && wordCount === 1 && !sentenceMode;
      const redicle = document.getElementById('rsvpRedicle');

      if (useOrpMode) {
        content.classList.add('orp-mode');
        content.style.marginLeft = '0';
        const singleWord = chunkWordsArr.find(w => w.isWord || (w.text && /\d/.test(w.text)));
        const orpFormatted = singleWord ? formatOrpWord(singleWord.text) : '';
        content.innerHTML = orpFormatted; // No cursor in Spritz mode
        // Position word so ORP letter is at fixed center
        // Double RAF ensures layout is complete before measuring
        requestAnimationFrame(() => {
          positionOrpWord(content);
          requestAnimationFrame(() => {
            // Update redicle position for first few words after layout change
            if (redicleUpdateCount > 0) {
              updateRediclePosition();
              redicleUpdateCount--;
            }
          });
        });
        // Show redicle, hide regular grid
        redicle.classList.remove('hidden');
        grid.classList.add('hidden');
      } else {
        content.classList.remove('orp-mode');
        content.style.marginLeft = rsvpTextPosition + '%';
        if (sentenceMode) {
          content.style.paddingRight = '0';
          content.style.paddingLeft = '0';
          content.style.width = '90%';
        } else {
          content.style.width = '70%';
          content.style.paddingLeft = '25%';
          if (wordCount === 1) {
            content.style.paddingRight = '12%';
          } else if (wordCount === 2) {
            content.style.paddingRight = '7.5%';
          } else {
            content.style.paddingRight = '0';
          }
        }
        content.innerHTML = chunkWords + cursor;
        // Hide redicle, show regular grid if enabled
        redicle.classList.add('hidden');
        if (rsvpGrid) {
          grid.classList.remove('hidden');
        }
      }

      // Update progress
      const totalWords = words.filter(w => w.isWord).length;
      const readWords = words.slice(0, currentIndex).filter(w => w.isWord).length;
      const percent = totalWords > 0 ? Math.round((readWords / totalWords) * 100) : 0;
      progress.textContent = `${readWords} / ${totalWords} (${percent}%)`;
    }

    // Draw VN border around current + upcoming sentences (the "reading zone")
    function drawVnBorder() {
      const svg = document.getElementById('vnBorderSvg');
      const path = document.getElementById('vnBorderPath');
      
      if (!vnBorder || sentences.length === 0) {
        svg.style.display = 'none';
        return;
      }

      // Find current sentence (use cached map)
      if (!wordToSentenceMap || wordToSentenceMap.length !== words.length) {
        buildWordToSentenceMap();
      }
      const currentSentenceIdx = wordToSentenceMap ? wordToSentenceMap[currentIndex] : -1;
      if (currentSentenceIdx === undefined || currentSentenceIdx < 0) {
        svg.style.display = 'none';
        return;
      }
      
      // Calculate which "batch" of sentences we're in
      // Each batch contains vnSentenceBuffer sentences
      const batchNumber = Math.floor(currentSentenceIdx / vnSentenceBuffer);
      const startSentence = batchNumber * vnSentenceBuffer;
      const endSentence = Math.min(sentences.length - 1, startSentence + vnSentenceBuffer - 1);
      
      // Find all word elements that belong to sentences in our batch
      const allWords = document.querySelectorAll('.word');
      const rects = [];
      
      allWords.forEach(word => {
        // Get word index from onclick attribute
        const onclick = word.getAttribute('onclick');
        if (!onclick) return;
        const match = onclick.match(/setPosition\((\d+)\)/);
        if (!match) return;
        const wordIdx = parseInt(match[1]);

        // Check which sentence this word belongs to (use cached map)
        const wordSentenceIdx = wordToSentenceMap ? wordToSentenceMap[wordIdx] : -1;

        // Only include if word's sentence is in our batch
        if (wordSentenceIdx >= startSentence && wordSentenceIdx <= endSentence) {
          const rect = word.getBoundingClientRect();
          if (rect.width > 0 && rect.height > 0) {
            rects.push({
              left: rect.left,
              right: rect.right,
              top: rect.top,
              bottom: rect.bottom
            });
          }
        }
      });
      
      if (rects.length === 0) {
        svg.style.display = 'none';
        return;
      }
      
      // Group rects by line (similar Y position, within 5px tolerance)
      const lines = [];
      const tolerance = 5;

      rects.forEach(rect => {
        const midY = (rect.top + rect.bottom) / 2;
        let foundLine = lines.find(line => Math.abs(line.midY - midY) < tolerance);
        if (foundLine) {
          foundLine.rects.push(rect);
          foundLine.left = Math.min(foundLine.left, rect.left);
          foundLine.right = Math.max(foundLine.right, rect.right);
          // Keep tracking for midY calculation, but we'll normalize heights later
          foundLine.rawTop = Math.min(foundLine.rawTop, rect.top);
          foundLine.rawBottom = Math.max(foundLine.rawBottom, rect.bottom);
        } else {
          lines.push({
            midY: midY,
            left: rect.left,
            right: rect.right,
            rawTop: rect.top,
            rawBottom: rect.bottom,
            rects: [rect]
          });
        }
      });

      // Sort lines by Y position (top to bottom)
      lines.sort((a, b) => a.rawTop - b.rawTop);

      // Normalize line heights for smooth borders
      // Use consistent height based on average, applied from each line's midpoint
      if (lines.length > 0) {
        const avgHeight = lines.reduce((sum, l) => sum + (l.rawBottom - l.rawTop), 0) / lines.length;
        const halfHeight = avgHeight / 2;
        lines.forEach(line => {
          line.top = line.midY - halfHeight;
          line.bottom = line.midY + halfHeight;
        });
      }
      
      if (lines.length === 0) {
        svg.style.display = 'none';
        return;
      }
      
      // Build the path - trace around the outside
      const padding = 6;
      const radius = 8;
      let pathData = '';
      
      // Start from top-left of first line
      const firstLine = lines[0];
      const startX = firstLine.left - padding;
      const startY = firstLine.top - padding;
      
      // Move to start position
      pathData = `M ${startX + radius} ${startY}`;
      
      // Trace right along top of each line, then down
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const nextLine = lines[i + 1];
        
        // Top-right corner of this line
        pathData += ` L ${line.right + padding - radius} ${line.top - padding}`;
        pathData += ` Q ${line.right + padding} ${line.top - padding} ${line.right + padding} ${line.top - padding + radius}`;
        
        // Right side down
        if (nextLine && nextLine.right < line.right) {
          // Next line is shorter on the right - step in
          pathData += ` L ${line.right + padding} ${line.bottom + padding - radius}`;
          pathData += ` Q ${line.right + padding} ${line.bottom + padding} ${line.right + padding - radius} ${line.bottom + padding}`;
          pathData += ` L ${nextLine.right + padding + radius} ${line.bottom + padding}`;
          pathData += ` Q ${nextLine.right + padding} ${line.bottom + padding} ${nextLine.right + padding} ${nextLine.top - padding + radius}`;
        } else if (nextLine) {
          // Next line is same width or wider - just continue down
          pathData += ` L ${line.right + padding} ${nextLine.top - padding - radius}`;
          pathData += ` Q ${line.right + padding} ${nextLine.top - padding} ${Math.min(line.right, nextLine.right) + padding - radius} ${nextLine.top - padding}`;
        } else {
          // Last line - go to bottom-right corner
          pathData += ` L ${line.right + padding} ${line.bottom + padding - radius}`;
          pathData += ` Q ${line.right + padding} ${line.bottom + padding} ${line.right + padding - radius} ${line.bottom + padding}`;
        }
      }
      
      // Trace left along bottom of each line (reverse order), then up
      for (let i = lines.length - 1; i >= 0; i--) {
        const line = lines[i];
        const prevLine = lines[i - 1];
        
        // Bottom-left corner of this line
        pathData += ` L ${line.left - padding + radius} ${line.bottom + padding}`;
        pathData += ` Q ${line.left - padding} ${line.bottom + padding} ${line.left - padding} ${line.bottom + padding - radius}`;
        
        // Left side up
        if (prevLine && prevLine.left > line.left) {
          // Previous line starts more to the right - step out
          pathData += ` L ${line.left - padding} ${line.top - padding + radius}`;
          pathData += ` Q ${line.left - padding} ${line.top - padding} ${line.left - padding + radius} ${line.top - padding}`;
          pathData += ` L ${prevLine.left - padding - radius} ${line.top - padding}`;
          pathData += ` Q ${prevLine.left - padding} ${line.top - padding} ${prevLine.left - padding} ${prevLine.bottom + padding - radius}`;
        } else if (prevLine) {
          // Previous line starts at same position or more left - just continue up
          pathData += ` L ${line.left - padding} ${prevLine.bottom + padding + radius}`;
          pathData += ` Q ${line.left - padding} ${prevLine.bottom + padding} ${Math.max(line.left, prevLine.left) - padding + radius} ${prevLine.bottom + padding}`;
        } else {
          // First line - close the path
          pathData += ` L ${line.left - padding} ${line.top - padding + radius}`;
          pathData += ` Q ${line.left - padding} ${line.top - padding} ${line.left - padding + radius} ${line.top - padding}`;
        }
      }
      
      pathData += ' Z';
      
      path.setAttribute('d', pathData);
      svg.style.display = 'block';
    }

    function renderText() {
      log(`renderText() idx=${currentIndex} words=${words.length} sentenceMode=${sentenceMode}`);

      // RSVP mode - render in overlay instead
      if (rsvpMode) {
        renderRSVP();
        return;
      }

      const display = document.getElementById('textDisplay');
      let html = '';

      // Full TTS mode: plain text, no highlighting
      if (ttsFullMode && ttsCache.has('__FULL__')) {
        html = joinWithSmartSpacing(words, 0);
        display.innerHTML = html;
        return;
      }

      // Determine current chunk boundaries
      let currentEnd;
      if (sentenceMode && sentences.length > 0) {
        // Highlight chunkSize sentences
        const lastSentIdx = Math.min(currentSentence + chunkSize - 1, sentences.length - 1);
        const lastSent = sentences[lastSentIdx];
        currentEnd = lastSent ? lastSent.endIdx : words.length;
      } else {
        currentEnd = Math.min(currentIndex + chunkSize, words.length);
      }

      // Group words into: read, current, unread
      if (currentIndex > 0) {
        // Read words - skip highlight in VN mode (fading handles it)
        const readContent = joinWithSmartSpacing(words.slice(0, currentIndex), 0);
        if (vnMode) {
          html += readContent + ' ';
        } else {
          const trailingSpace = highlightContinuous ? ' </span>' : '</span> ';
          html += `<span class="highlight-read">${readContent}${trailingSpace}`;
        }
      }

      // Current chunk - continuous highlight
      if (currentIndex < words.length) {
        const currentContent = joinWithSmartSpacing(words.slice(currentIndex, currentEnd), currentIndex, true);
        const cursorClass = fakeCursorBlink ? 'fake-cursor blink' : 'fake-cursor';
        const cursor = fakeCursorEnabled ? `<span class="${cursorClass}"></span>` : '';
        html += `<span class="highlight-current" id="currentChunk">${currentContent}</span>${cursor} `;
      }

      // Remaining words - no highlight (but may have half-bold if enabled)
      if (currentEnd < words.length) {
        const remainingContent = joinWithSmartSpacing(words.slice(currentEnd), currentEnd, false, true);
        html += remainingContent;
      }

      display.innerHTML = html;

      // Smart scroll - only when highlight leaves comfort zone around 25%
      const currentEl = document.getElementById('currentChunk');
      if (currentEl) {
        const rect = currentEl.getBoundingClientRect();
        const viewportHeight = window.innerHeight;
        const targetPos = 0.25; // Fixed at 25% from top
        const tolerance = scrollTolerance / 100;
        const comfortTop = viewportHeight * (targetPos - tolerance);
        const comfortBottom = viewportHeight * (targetPos + tolerance);

        // Only scroll if outside comfort zone
        if (rect.top < comfortTop || rect.bottom > comfortBottom) {
          const targetY = window.scrollY + rect.top - (viewportHeight * targetPos);
          window.scrollTo({ top: targetY, behavior: 'smooth' });
        }
      }
      
      // Draw VN border after DOM update
      requestAnimationFrame(drawVnBorder);
    }

    function setPosition(idx) {
      currentIndex = idx;
      if (sentenceMode) {
        // Find which sentence contains this word
        currentSentence = sentences.findIndex(s => idx >= s.startIdx && idx < s.endIdx);
        if (currentSentence < 0) currentSentence = 0;
        currentIndex = sentences[currentSentence].startIdx;
      }
      renderText();
      updateWordProgress();
    }

    // Skip over line/paragraph breaks to land on actual words
    function skipBreaks(idx, direction = 1) {
      while (idx >= 0 && idx < words.length && (words[idx].isLine || words[idx].isParagraph)) {
        idx += direction;
      }
      return Math.max(0, Math.min(idx, words.length - 1));
    }

    function nextChunk() {
      if (sentenceMode) {
        if (currentSentence + chunkSize < sentences.length) {
          currentSentence += chunkSize;
          currentIndex = sentences[currentSentence].startIdx;
          renderText();
          updateWordProgress();
        } else if (hasPages && currentPage < pages.length - 1) {
          playPageFinishSound();
          goToPage(currentPage + 1, autoAdvance);
        } else if (autoAdvance) {
          toggleAuto();
        }
      } else {
        if (currentIndex + chunkSize < words.length) {
          currentIndex = skipBreaks(currentIndex + chunkSize, 1);
          renderText();
          updateWordProgress();
        } else if (hasPages && currentPage < pages.length - 1) {
          playPageFinishSound();
          goToPage(currentPage + 1, autoAdvance);
        } else if (autoAdvance) {
          toggleAuto();
        }
      }
    }

    function prevChunk() {
      if (sentenceMode) {
        if (currentSentence > 0) {
          currentSentence = Math.max(0, currentSentence - chunkSize);
          currentIndex = sentences[currentSentence].startIdx;
          renderText();
          updateWordProgress();
        } else if (hasPages && currentPage > 0) {
          currentPage--;
          initCurrentPage().then(() => {
            currentSentence = sentences.length - 1;
            currentIndex = sentences[currentSentence].startIdx;
            renderText();
            updateWordProgress();
            updatePageNav();
          });
        }
      } else if (currentIndex > 0) {
        currentIndex = skipBreaks(Math.max(0, currentIndex - chunkSize), -1);
        renderText();
        updateWordProgress();
      } else if (hasPages && currentPage > 0) {
        currentPage--;
        initCurrentPage().then(() => {
          currentIndex = skipBreaks(Math.max(0, words.length - chunkSize), -1);
          renderText();
          updateWordProgress();
          updatePageNav();
        });
      }
    }


    function nextLine() {
      for (let i = currentIndex + 1; i < words.length; i++) {
        if (words[i].isLine || words[i].isParagraph) {
          const nextIdx = skipBreaks(i + 1, 1);
          if (nextIdx < words.length) {
            currentIndex = nextIdx;
            if (sentenceMode) {
              currentSentence = sentences.findIndex(s => currentIndex >= s.startIdx && currentIndex < s.endIdx);
              if (currentSentence < 0) currentSentence = 0;
            }
            renderText();
            updateWordProgress();
          }
          return;
        }
      }
      if (hasPages && currentPage < pages.length - 1) goToPage(currentPage + 1, false);
    }

    function prevLine() {
      let foundBreak = -1;
      for (let i = currentIndex - 1; i >= 0; i--) {
        if (words[i].isLine || words[i].isParagraph) { foundBreak = i; break; }
      }
      if (foundBreak >= 0) {
        let prevBreak = -1;
        for (let i = foundBreak - 1; i >= 0; i--) {
          if (words[i].isLine || words[i].isParagraph) { prevBreak = i; break; }
        }
        currentIndex = prevBreak >= 0 ? skipBreaks(prevBreak + 1, 1) : 0;
        if (sentenceMode) {
          currentSentence = sentences.findIndex(s => currentIndex >= s.startIdx && currentIndex < s.endIdx);
          if (currentSentence < 0) currentSentence = 0;
        }
        renderText();
        updateWordProgress();
      } else if (currentIndex > 0) {
        currentIndex = 0;
        if (sentenceMode) currentSentence = 0;
        renderText();
        updateWordProgress();
      } else if (hasPages && currentPage > 0) {
        currentPage--;
        initCurrentPage().then(() => {
          currentIndex = skipBreaks(words.length - 1, -1);
          renderText();
          updateWordProgress();
          updatePageNav();
        });
      }
    }

    function toggleAuto() {
      autoAdvance = !autoAdvance;
      const btn = document.getElementById('autoBtn');
      const playBtn = document.getElementById('playBtn');

      if (autoAdvance) {
        btn.classList.add('active');
        btn.textContent = '⏸ עצור';
        playBtn.textContent = '⏸';
        startAutoAdvance();
      } else {
        btn.classList.remove('active');
        btn.textContent = '▶ אוטומטי';
        playBtn.textContent = '⟳';
        stopAutoAdvance();
      }
    }

    function getAutoAdvanceInterval() {
      if (sentenceMode && sentences.length > 0) {
        // Sentence mode: calculate based on words in current sentence(s)
        const startSent = currentSentence;
        const endSent = Math.min(currentSentence + chunkSize, sentences.length);
        let wordCount = 0;
        for (let i = startSent; i < endSent; i++) {
          wordCount += sentences[i].endIdx - sentences[i].startIdx;
        }
        const baseTime = (wordCount / wpm) * 60000;
        return baseTime * 1.1; // 10% buffer
      } else {
        // Word mode: fixed interval
        return (chunkSize / wpm) * 60000;
      }
    }

    function scheduleNextChunk() {
      if (!autoAdvance) return;
      
      // Full TTS mode: just play audio, no chunking
      if (ttsFullMode && ttsCache.has('__FULL__')) {
        speakChunk();  // Triggers full audio playback
        return;  // Don't schedule chunk advances
      }
      
      const interval = getAutoAdvanceInterval();
      autoInterval = setTimeout(() => {
        nextChunk();
        scheduleNextChunk();
      }, interval);
    }

    function startAutoAdvance() {
      scheduleNextChunk();
    }

    function stopAutoAdvance() {
      if (autoInterval) {
        clearTimeout(autoInterval);
        autoInterval = null;
      }
      stopTTS();
    }

    function updateSettings() {
      chunkSize = parseInt(document.getElementById('chunkSize').value) || 1;
      wpm = parseInt(document.getElementById('wpm').value) || 200;

      if (autoAdvance) {
        stopAutoAdvance();
        startAutoAdvance();
      }

      renderText();
    }

    function reset() {
      log('reset() called');
      currentIndex = 0;
      currentSentence = 0;
      if (autoAdvance) toggleAuto();

      logState('after reset');
      renderText();
      updateWordProgress();
    }

    function backToInput() {
      log('backToInput() called');
      if (autoAdvance) toggleAuto();
      document.getElementById('inputArea').style.display = 'block';
      document.getElementById('controls').style.display = 'none';
      document.getElementById('textDisplay').style.display = 'none';
    }

    function updateWordProgress() {
      let progressText;
      let percent;
      let visualPercent;
      if (sentenceMode) {
        progressText = `משפט ${currentSentence + 1} / ${sentences.length}`;
        percent = sentences.length > 0 ? ((currentSentence + 1) / sentences.length) * 100 : 0;
        visualPercent = percent;
      } else {
        progressText = `${currentIndex} / ${words.length}`;
        percent = words.length > 0 ? (currentIndex / words.length) * 100 : 0;
        // Use word-based percent (line snapping was causing issues)
        visualPercent = percent;
      }
      if (hasPages) {
        progressText += ` | עמ׳ ${currentPage + 1}/${pages.length}`;
      }
      document.getElementById('progress').textContent = progressText;

      // Update vertical progress bar (use visualPercent for smoother movement)
      const progressBar = document.getElementById('progressBar');
      const progressFill = document.getElementById('progressFill');
      const progressPercent = document.getElementById('progressPercent');
      if (words.length > 0) {
        progressBar.classList.add('visible');
        progressFill.style.height = visualPercent + '%';
        progressPercent.style.top = visualPercent + '%';
        progressPercent.textContent = Math.round(visualPercent) + '%';
      } else {
        progressBar.classList.remove('visible');
      }
    }

    // Progress bar drag functionality
    function initProgressBarDrag() {
      const progressBar = document.getElementById('progressBar');
      const progressPercent = document.getElementById('progressPercent');
      let isDragging = false;

      function getPercentFromY(clientY) {
        const rect = progressBar.getBoundingClientRect();
        const y = clientY - rect.top;
        const percent = Math.max(0, Math.min(100, (y / rect.height) * 100));
        return percent;
      }

      function seekToPercent(percent) {
        if (sentenceMode && sentences.length > 0) {
          const targetSentence = Math.floor((percent / 100) * sentences.length);
          currentSentence = Math.max(0, Math.min(targetSentence, sentences.length - 1));
          currentIndex = sentences[currentSentence].startIdx;
        } else if (words.length > 0) {
          const targetWord = Math.floor((percent / 100) * words.length);
          currentIndex = Math.max(0, Math.min(targetWord, words.length - 1));
        }
        renderText();
        updateWordProgress();
      }

      function onDragStart(e) {
        isDragging = true;
        progressPercent.classList.add('dragging');
        e.preventDefault();
      }

      function onDragMove(e) {
        if (!isDragging) return;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const percent = getPercentFromY(clientY);
        seekToPercent(percent);
      }

      function onDragEnd() {
        if (!isDragging) return;
        isDragging = false;
        progressPercent.classList.remove('dragging');
      }

      progressPercent.addEventListener('mousedown', onDragStart);
      progressPercent.addEventListener('touchstart', onDragStart);
      document.addEventListener('mousemove', onDragMove);
      document.addEventListener('touchmove', onDragMove);
      document.addEventListener('mouseup', onDragEnd);
      document.addEventListener('touchend', onDragEnd);

      // Also allow clicking anywhere on the bar
      progressBar.addEventListener('click', (e) => {
        if (e.target === progressPercent) return;
        const percent = getPercentFromY(e.clientY);
        seekToPercent(percent);
      });
    }

    // Paste modal functions
    function openPasteModal() {
      document.getElementById('pasteModal').classList.add('active');
      document.getElementById('pasteTextarea').focus();
    }

    function closePasteModal() {
      document.getElementById('pasteModal').classList.remove('active');
      document.getElementById('pasteTextarea').value = '';
    }

    async function loadPastedText() {
      const text = document.getElementById('pasteTextarea').value.trim();
      if (!text) return alert('אנא הדבק טקסט');

      closePasteModal();
      document.getElementById('textInput').value = text;

      showLoading('טוען...');
      hasPages = text.includes('\f');

      if (hasPages) {
        await loadPagesAsync(text);
      } else {
        dirtyText = text;
        cleanedText = await cleanTextAsync(text);
        await initPacerAsync(useCleanText ? cleanedText : dirtyText);
      }
      hideLoading();
      if (typeof saveState === 'function') saveState();
      
      // Save to library
      if (hasPages) {
        currentLibraryId = await saveToLibrary(text, pages);
      } else {
        currentLibraryId = await saveToLibrary(text);
      }
      log('Saved to library: ' + currentLibraryId);
    }

    // Drop prompt toggle functions
    function hideDropPrompt() {
      document.querySelector('.drop-prompt').classList.add('hidden');
    }

    function showDropPrompt() {
      document.querySelector('.drop-prompt').classList.remove('hidden');
    }

    // Click outside drop prompt to dismiss
    document.getElementById('inputArea').addEventListener('click', (e) => {
      const prompt = document.querySelector('.drop-prompt');
      if (!prompt.contains(e.target) && !prompt.classList.contains('hidden')) {
        hideDropPrompt();
      }
    });

    // New document button shows input area with drop prompt
    document.getElementById('newDocBtn').addEventListener('click', () => {
      if (autoAdvance) toggleAuto();
      currentLibraryId = null; // Reset so next load creates new library item
      document.getElementById('inputArea').style.display = 'block';
      document.getElementById('textDisplay').style.display = 'none';
      showDropPrompt();
    });

    // PDF modal functions
    let currentPdfFilename = '';

    function showPdfModal(filename) {
      log('showPdfModal() called with: ' + filename, 'i');
      currentPdfFilename = filename;
      document.getElementById('pdfCommand').textContent = `python3 extract_pdf.py "${filename}"`;
      const modal = document.getElementById('pdfModal');
      log('modal element: ' + (modal ? 'found' : 'NOT FOUND'), modal ? 'i' : 'e');
      modal.classList.add('active');
      log('modal classList: ' + modal.classList, 'i');
      enablePdfDropzone();
      log('PDF modal opened for: ' + filename, 'i');
    }

    function closePdfModal() {
      disablePdfDropzone();
      document.getElementById('pdfModal').classList.remove('active');
    }

    function copyPdfCommand() {
      const command = document.getElementById('pdfCommand').textContent;
      navigator.clipboard.writeText(command).then(() => {
        log('Command copied: ' + command, 'i');
        const btn = event.target;
        btn.textContent = '✓';
        setTimeout(() => { btn.textContent = '📋'; }, 1500);
      });
    }

    function copyCdCommand() {
      const command = document.getElementById('cdCommand').textContent;
      navigator.clipboard.writeText(command).then(() => {
        log('CD command copied: ' + command, 'i');
        const btn = event.target;
        btn.textContent = '✓';
        setTimeout(() => { btn.textContent = '📋'; }, 1500);
      });
    }

    // Close modal on background click
    document.getElementById('pdfModal').addEventListener('click', (e) => {
      if (e.target.id === 'pdfModal') closePdfModal();
    });

    // PDF modal dropzone handlers (only active when modal is open)
    async function handlePdfDropzoneDrop(e) {
      e.preventDefault();
      document.getElementById('pdfDropzone').classList.remove('drag-over');
      const file = e.dataTransfer.files[0];
      if (!file) return;

      if (!file.name.match(/\.(txt|md)$/i)) {
        alert('רק קבצי txt או md');
        return;
      }

      closePdfModal();
      showLoading('קורא קובץ...');
      const text = await file.text();
      document.getElementById('textInput').value = text;

      hasPages = text.includes('\f');
      log(`pdfDropzone hasPages=${hasPages}`);

      if (hasPages) {
        await loadPagesAsync(text);
      } else {
        dirtyText = text;
        cleanedText = await cleanTextAsync(text);
        await initPacerAsync(useCleanText ? cleanedText : dirtyText);
      }
      hideLoading();
      if (typeof saveState === 'function') saveState();

      // Save to library
      if (hasPages) {
        currentLibraryId = await saveToLibrary(text, pages);
      } else {
        currentLibraryId = await saveToLibrary(text);
      }
      log('Saved to library: ' + currentLibraryId);

      // Extract images from pending PDF after text is loaded
      if (pendingPdfFile) {
        log('Text loaded via modal, now extracting images from pending PDF', 'i');
        extractPdfPageImages(pendingPdfFile);
        pendingPdfFile = null;
      }
    }

    function handlePdfDropzoneDragover(e) {
      e.preventDefault();
      document.getElementById('pdfDropzone').classList.add('drag-over');
    }

    function handlePdfDropzoneDragleave(e) {
      e.preventDefault();
      document.getElementById('pdfDropzone').classList.remove('drag-over');
    }

    function enablePdfDropzone() {
      const dz = document.getElementById('pdfDropzone');
      dz.addEventListener('dragover', handlePdfDropzoneDragover);
      dz.addEventListener('dragleave', handlePdfDropzoneDragleave);
      dz.addEventListener('drop', handlePdfDropzoneDrop);
    }

    function disablePdfDropzone() {
      const dz = document.getElementById('pdfDropzone');
      dz.removeEventListener('dragover', handlePdfDropzoneDragover);
      dz.removeEventListener('dragleave', handlePdfDropzoneDragleave);
      dz.removeEventListener('drop', handlePdfDropzoneDrop);
    }

    // Drag and drop support
    const inputArea = document.getElementById('inputArea');
    log('inputArea element: ' + (inputArea ? 'found' : 'NOT FOUND'), inputArea ? 'i' : 'e');

    inputArea.addEventListener('dragover', (e) => {
      log('dragover fired', 'i');
      e.preventDefault();
      inputArea.classList.add('drag-over');
    });
    inputArea.addEventListener('dragleave', (e) => {
      log('dragleave fired', 'i');
      e.preventDefault();
      inputArea.classList.remove('drag-over');
    });
    inputArea.addEventListener('drop', async (e) => {
      log('drop fired', 'i');
      e.preventDefault();
      inputArea.classList.remove('drag-over');
      const file = e.dataTransfer.files[0];
      log('file: ' + (file ? file.name : 'no file'), 'i');
      if (!file) return;

      // PDF detection - store for later, show tutorial modal
      if (file.name.match(/\.pdf$/i)) {
        log('PDF detected, storing for image extraction after text loads', 'i');
        pendingPdfFile = file;
        showPdfModal(file.name);
        return;
      }

      // Only allow txt/md
      if (!file.name.match(/\.(txt|md)$/i)) {
        alert('גרור קובץ txt, md או pdf');
        return;
      }

      showLoading('קורא קובץ...');
      const text = await file.text();
      document.getElementById('textInput').value = text;

      // Check for page breaks
      hasPages = text.includes('\f');
      log(`drop hasPages=${hasPages}`);

      if (hasPages) {
        await loadPagesAsync(text);
      } else {
        dirtyText = text;
        cleanedText = await cleanTextAsync(text);
        await initPacerAsync(useCleanText ? cleanedText : dirtyText);
      }
      hideLoading();
      if (typeof saveState === 'function') saveState();

      // Extract images from pending PDF after text is loaded
      if (pendingPdfFile) {
        log('Text loaded, now extracting images from pending PDF', 'i');
        extractPdfPageImages(pendingPdfFile);
        pendingPdfFile = null;
      }
    });

    // Global drag and drop - anywhere on screen
    document.addEventListener('dragover', (e) => {
      e.preventDefault();
    });
    document.addEventListener('drop', async (e) => {
      // Ignore if dropped on inputArea (handled above) or pdfDropzone
      if (e.target.closest('#inputArea') || e.target.closest('#pdfDropzone')) return;

      e.preventDefault();
      const file = e.dataTransfer.files[0];
      if (!file) return;

      // PDF detection
      if (file.name.match(/\.pdf$/i)) {
        log('Global drop: PDF detected', 'i');
        pendingPdfFile = file;
        showPdfModal(file.name);
        return;
      }

      // Only allow txt/md
      if (!file.name.match(/\.(txt|md)$/i)) {
        alert('גרור קובץ txt, md או pdf');
        return;
      }

      showLoading('קורא קובץ...');
      const text = await file.text();
      document.getElementById('textInput').value = text;

      hasPages = text.includes('\f');
      log(`global drop hasPages=${hasPages}`);

      if (hasPages) {
        await loadPagesAsync(text);
      } else {
        dirtyText = text;
        cleanedText = await cleanTextAsync(text);
        await initPacerAsync(useCleanText ? cleanedText : dirtyText);
      }
      hideLoading();
      if (typeof saveState === 'function') saveState();

      // Extract images from pending PDF after text is loaded
      if (pendingPdfFile) {
        log('Text loaded (global), now extracting images from pending PDF', 'i');
        extractPdfPageImages(pendingPdfFile);
        pendingPdfFile = null;
      }
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT' || e.target.isContentEditable) return;

      switch(e.code) {
        case 'Space':
          e.preventDefault();
          toggleAuto();
          break;
        case 'ArrowLeft': // Left = forward in RTL
          e.preventDefault();
          nextChunk();
          break;
        case 'ArrowRight': // Right = back in RTL
          e.preventDefault();
          prevChunk();
          break;
        case 'ArrowDown':
          e.preventDefault();
          nextLine();
          break;
        case 'ArrowUp':
          e.preventDefault();
          prevLine();
          break;
        case 'PageDown':
          e.preventDefault();
          if (hasPages) nextPage();
          break;
        case 'PageUp':
          e.preventDefault();
          if (hasPages) prevPage();
          break;
        case 'KeyR':
          reset();
          break;
        case 'Escape':
          if (rsvpMode) {
            e.preventDefault();
            rsvpMode = false;
            localStorage.setItem('reading-pacer-rsvp', 'false');
            document.getElementById('rsvpOverlay').classList.remove('active');
            document.body.classList.remove('rsvp-active');
            document.getElementById('rsvpModeOn').classList.remove('active');
            document.getElementById('rsvpModeOff').classList.add('active');
            renderText();
          }
          break;
      }
    });

    // RSVP overlay scroll navigation
    document.getElementById('rsvpOverlay').addEventListener('wheel', (e) => {
      e.preventDefault();
      if (e.deltaY > 0) {
        nextChunk();
      } else {
        prevChunk();
      }
    }, { passive: false });

    log('All event listeners initialized', 'i');

    // Settings dropdown toggle
    document.getElementById('styleBtn').addEventListener('click', () => {
      document.getElementById('settingsDropdown').classList.toggle('open');
    });

    // Close settings when clicking outside
    document.addEventListener('click', (e) => {
      const dropdown = document.getElementById('settingsDropdown');
      const styleBtn = document.getElementById('styleBtn');
      if (dropdown.classList.contains('open') &&
          !dropdown.contains(e.target) &&
          !styleBtn.contains(e.target)) {
        dropdown.classList.remove('open');
      }
    });

    // Settings application functions
    const textDisplay = document.getElementById('textDisplay');

    function applyVisualSettings() {
      const settings = getVisualSettings();

      // Font
      textDisplay.style.fontFamily = settings.fontFamily;
      textDisplay.style.fontSize = settings.fontSize + 'px';
      textDisplay.style.fontWeight = settings.fontWeight;

      // Spacing
      textDisplay.style.lineHeight = settings.lineHeight;
      textDisplay.style.letterSpacing = settings.letterSpacing + 'px';

      // Layout
      textDisplay.style.paddingLeft = settings.margins + 'px';
      textDisplay.style.paddingRight = settings.margins + 'px';
      if (settings.textAlign === 'center-right') {
        textDisplay.style.textAlign = 'right';
        textDisplay.classList.add('centered-block');
      } else {
        textDisplay.style.textAlign = settings.textAlign;
        textDisplay.classList.remove('centered-block');
      }

      // Highlights are now handled by applyHighlightColors() with opacity sliders

      // Paragraph spacing (applied via CSS class)
      document.documentElement.style.setProperty('--paragraph-spacing', settings.paragraphSpacing + 'px');

      saveVisualSettings(settings);

      // Re-render RSVP if active to apply font changes
      if (rsvpMode && words.length > 0) renderRSVP();
    }

    function getVisualSettings() {
      return {
        fontFamily: document.getElementById('settingsFont').value,
        fontSize: parseInt(document.getElementById('settingsFontSize').value),
        fontWeight: document.getElementById('fontWeightBold').classList.contains('active') ? 'bold' : 'normal',
        lineHeight: parseFloat(document.getElementById('settingsLineHeight').value),
        letterSpacing: parseFloat(document.getElementById('settingsLetterSpacing').value),
        paragraphSpacing: parseInt(document.getElementById('settingsParagraphSpacing').value),
        margins: parseInt(document.getElementById('settingsMargins').value),
        textAlign: document.getElementById('alignCenter').classList.contains('active') ? 'center' :
                   document.getElementById('alignJustify').classList.contains('active') ? 'justify' :
                   document.getElementById('alignCenterRight').classList.contains('active') ? 'center-right' : 'right',
        highlightRead: document.getElementById('settingsHighlightRead').value,
        highlightCurrent: document.getElementById('settingsHighlightCurrent').value,
        popSize: parseInt(document.getElementById('settingsPopSize').value),
        animSpeed: parseInt(document.getElementById('settingsAnimSpeed').value),
        volume: parseInt(document.getElementById('settingsVolume').value)
      };
    }

    function saveVisualSettings(settings) {
      localStorage.setItem('reading-pacer-visual', JSON.stringify(settings));
    }

    function loadVisualSettings() {
      const saved = localStorage.getItem('reading-pacer-visual');
      if (!saved) return;

      try {
        const settings = JSON.parse(saved);

        // Apply to form elements
        if (settings.fontFamily) document.getElementById('settingsFont').value = settings.fontFamily;
        if (settings.fontSize) {
          document.getElementById('settingsFontSize').value = settings.fontSize;
          document.getElementById('fontSizeValue').textContent = settings.fontSize + 'px';
        }
        if (settings.fontWeight === 'bold') {
          document.getElementById('fontWeightNormal').classList.remove('active');
          document.getElementById('fontWeightBold').classList.add('active');
        }
        if (settings.lineHeight) {
          document.getElementById('settingsLineHeight').value = settings.lineHeight;
          document.getElementById('lineHeightValue').textContent = settings.lineHeight;
        }
        if (settings.letterSpacing !== undefined) {
          document.getElementById('settingsLetterSpacing').value = settings.letterSpacing;
          document.getElementById('letterSpacingValue').textContent = settings.letterSpacing + 'px';
        }
        if (settings.paragraphSpacing !== undefined) {
          document.getElementById('settingsParagraphSpacing').value = settings.paragraphSpacing;
          document.getElementById('paragraphSpacingValue').textContent = settings.paragraphSpacing + 'px';
        }
        if (settings.margins) {
          document.getElementById('settingsMargins').value = settings.margins;
          document.getElementById('marginsValue').textContent = settings.margins + 'px';
        }
        if (settings.textAlign) {
          document.querySelectorAll('#alignRight, #alignCenter, #alignJustify, #alignCenterRight').forEach(b => b.classList.remove('active'));
          if (settings.textAlign === 'center') document.getElementById('alignCenter').classList.add('active');
          else if (settings.textAlign === 'justify') document.getElementById('alignJustify').classList.add('active');
          else if (settings.textAlign === 'center-right') document.getElementById('alignCenterRight').classList.add('active');
          else document.getElementById('alignCenterRight').classList.add('active');
        }
        if (settings.highlightRead) document.getElementById('settingsHighlightRead').value = settings.highlightRead;
        if (settings.highlightCurrent) document.getElementById('settingsHighlightCurrent').value = settings.highlightCurrent;

        // Animation settings
        if (settings.popSize !== undefined) {
          document.getElementById('settingsPopSize').value = settings.popSize;
          document.getElementById('popSizeValue').textContent = settings.popSize + '%';
          document.documentElement.style.setProperty('--pop-scale', 1 + settings.popSize / 100);
        }
        if (settings.animSpeed !== undefined) {
          document.getElementById('settingsAnimSpeed').value = settings.animSpeed;
          document.getElementById('animSpeedValue').textContent = (settings.animSpeed / 100).toFixed(2) + 's';
          document.documentElement.style.setProperty('--anim-speed', (settings.animSpeed / 100) + 's');
        }

        // Volume
        if (settings.volume !== undefined) {
          document.getElementById('settingsVolume').value = settings.volume;
          document.getElementById('volumeValue').textContent = settings.volume + '%';
        }

        applyVisualSettings();
      } catch (e) {
        log('Failed to load visual settings: ' + e.message, 'e');
      }
    }

    function hexToRgba(hex, alpha) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    // Wire up all settings controls
    document.getElementById('settingsFont').addEventListener('change', applyVisualSettings);

    document.getElementById('settingsFontSize').addEventListener('input', function() {
      document.getElementById('fontSizeValue').textContent = this.value + 'px';
      applyVisualSettings();
    });

    document.getElementById('fontWeightNormal').addEventListener('click', function() {
      document.getElementById('fontWeightBold').classList.remove('active');
      this.classList.add('active');
      applyVisualSettings();
    });
    document.getElementById('fontWeightBold').addEventListener('click', function() {
      document.getElementById('fontWeightNormal').classList.remove('active');
      this.classList.add('active');
      applyVisualSettings();
    });

    document.getElementById('settingsLineHeight').addEventListener('input', function() {
      document.getElementById('lineHeightValue').textContent = this.value;
      applyVisualSettings();
    });

    document.getElementById('settingsLetterSpacing').addEventListener('input', function() {
      document.getElementById('letterSpacingValue').textContent = this.value + 'px';
      applyVisualSettings();
    });

    document.getElementById('settingsParagraphSpacing').addEventListener('input', function() {
      document.getElementById('paragraphSpacingValue').textContent = this.value + 'px';
      applyVisualSettings();
    });

    document.getElementById('settingsMargins').addEventListener('input', function() {
      document.getElementById('marginsValue').textContent = this.value + 'px';
      applyVisualSettings();
    });

    ['alignRight', 'alignCenter', 'alignJustify', 'alignCenterRight'].forEach(id => {
      document.getElementById(id).addEventListener('click', function() {
        document.querySelectorAll('#alignRight, #alignCenter, #alignJustify, #alignCenterRight').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        applyVisualSettings();
      });
    });

    document.getElementById('settingsHighlightRead').addEventListener('input', applyHighlightColors);
    document.getElementById('settingsHighlightCurrent').addEventListener('input', applyHighlightColors);

    // Highlight opacity sliders
    document.getElementById('highlightReadOpacity').addEventListener('input', function() {
      document.getElementById('highlightReadOpacityValue').textContent = this.value + '%';
      localStorage.setItem('reading-pacer-highlight-read-opacity', this.value);
      applyHighlightColors();
    });
    document.getElementById('highlightCurrentOpacity').addEventListener('input', function() {
      document.getElementById('highlightCurrentOpacityValue').textContent = this.value + '%';
      localStorage.setItem('reading-pacer-highlight-current-opacity', this.value);
      applyHighlightColors();
    });

    // Apply highlight colors with opacity
    function applyHighlightColors() {
      const readColor = document.getElementById('settingsHighlightRead').value;
      const currentColor = document.getElementById('settingsHighlightCurrent').value;
      const readOpacity = parseInt(document.getElementById('highlightReadOpacity').value);
      const currentOpacity = parseInt(document.getElementById('highlightCurrentOpacity').value);

      document.documentElement.style.setProperty('--highlight-read', hexToRgba(readColor, readOpacity / 100));
      document.documentElement.style.setProperty('--highlight-current', hexToRgba(currentColor, currentOpacity / 100));
      document.documentElement.style.setProperty('--highlight-current-border', hexToRgba(currentColor, Math.min(1, currentOpacity / 100 + 0.3)));

      // Save opacity values
      localStorage.setItem('reading-pacer-highlight-read-opacity', readOpacity);
      localStorage.setItem('reading-pacer-highlight-current-opacity', currentOpacity);

      // Save colors too
      const settings = getVisualSettings();
      saveVisualSettings(settings);
    }

    // Continuous highlight toggle
    document.getElementById('highlightContinuousOn').addEventListener('click', function() {
      document.getElementById('highlightContinuousOff').classList.remove('active');
      this.classList.add('active');
      highlightContinuous = true;
      localStorage.setItem('reading-pacer-highlight-continuous', 'true');
      document.getElementById('textDisplay').classList.add('highlight-continuous');
    });
    document.getElementById('highlightContinuousOff').addEventListener('click', function() {
      document.getElementById('highlightContinuousOn').classList.remove('active');
      this.classList.add('active');
      highlightContinuous = false;
      localStorage.setItem('reading-pacer-highlight-continuous', 'false');
      document.getElementById('textDisplay').classList.remove('highlight-continuous');
    });

    // Metronome toggle
    document.getElementById('metronomeOn').addEventListener('click', function() {
      document.getElementById('metronomeOff').classList.remove('active');
      this.classList.add('active');
      metronomeEnabled = true;
      localStorage.setItem('reading-pacer-metronome', 'true');
    });
    document.getElementById('metronomeOff').addEventListener('click', function() {
      document.getElementById('metronomeOn').classList.remove('active');
      this.classList.add('active');
      metronomeEnabled = false;
      localStorage.setItem('reading-pacer-metronome', 'false');
    });

    // TTS toggle
    document.getElementById('ttsOn').addEventListener('click', function() {
      document.getElementById('ttsOff').classList.remove('active');
      this.classList.add('active');
      ttsEnabled = true;
      localStorage.setItem('reading-pacer-tts', 'true');
      document.querySelector('.tts-controls').style.display = 'flex';
    });
    document.getElementById('ttsOff').addEventListener('click', function() {
      document.getElementById('ttsOn').classList.remove('active');
      this.classList.add('active');
      ttsEnabled = false;
      localStorage.setItem('reading-pacer-tts', 'false');
      stopTTS();
      clearTTSCache();
      document.querySelector('.tts-controls').style.display = 'none';
    });

    // TTS Load button
    document.getElementById('ttsLoadBtn').addEventListener('click', async function() {
      if (words.length === 0) {
        alert('אנא טען טקסט קודם');
        return;
      }
      
      const btn = this;
      btn.disabled = true;
      btn.textContent = 'טוען...';

      showLoading('טוען הקראה...');

      // Reset to start so currentIndex aligns with cached chunks
      currentIndex = 0;
      if (sentenceMode) currentSentence = 0;
      renderText();

      await pregenerateTTS();
      
      hideLoading();
      btn.disabled = false;
      btn.textContent = ttsCache.size > 0 ? 'נטען ✓ (' + ttsCache.size + ')' : 'טען הקראה';
    });

    // TTS Full mode toggle
    document.getElementById('ttsFullToggle').addEventListener('click', function() {
      ttsFullMode = !ttsFullMode;
      this.classList.toggle('active', ttsFullMode);
      // Clear cache when mode changes
      if (ttsCache.size > 0) {
        clearTTSCache();
        document.getElementById('ttsLoadBtn').textContent = 'טען מחדש';
        log('[TTS] Cache cleared - mode changed', 'w');
      }
      // Re-render to update highlighting state
      if (words.length > 0) renderText();
    });

    // TTS Speed menu
    document.getElementById('ttsSpeedBtn').addEventListener('click', function(e) {
      e.stopPropagation();
      document.getElementById('ttsSpeedMenu').classList.toggle('open');
    });
    document.querySelectorAll('.tts-speed-option').forEach(opt => {
      opt.addEventListener('click', function() {
        const speed = parseFloat(this.dataset.speed);
        ttsPlaybackRate = speed;
        localStorage.setItem('reading-pacer-tts-speed', speed);
        document.getElementById('ttsSpeedBtn').textContent = this.textContent;
        document.querySelectorAll('.tts-speed-option').forEach(o => o.classList.remove('selected'));
        this.classList.add('selected');
        document.getElementById('ttsSpeedMenu').classList.remove('open');
        // Invalidate cache - speed affects generation
        if (ttsCache.size > 0) {
          clearTTSCache();
          document.getElementById('ttsLoadBtn').textContent = 'טען מחדש';
          log('[TTS] Cache cleared - speed changed', 'w');
        }
      });
    });
    // Close menu when clicking outside
    document.addEventListener('click', function() {
      document.getElementById('ttsSpeedMenu').classList.remove('open');
    });
    // Initialize speed button text from saved value
    const savedSpeed = localStorage.getItem('reading-pacer-tts-speed');
    if (savedSpeed) {
      document.getElementById('ttsSpeedBtn').textContent = savedSpeed + 'x';
      document.querySelectorAll('.tts-speed-option').forEach(o => {
        o.classList.toggle('selected', o.dataset.speed === savedSpeed);
      });
    }

    // VN Mode toggle
    document.getElementById('vnModeOn').addEventListener('click', function() {
      document.getElementById('vnModeOff').classList.remove('active');
      this.classList.add('active');
      vnMode = true;
      document.body.classList.add('vn-mode');
      localStorage.setItem('reading-pacer-vnmode', 'true');
      if (words.length > 0) renderText();
    });
    document.getElementById('vnModeOff').addEventListener('click', function() {
      document.getElementById('vnModeOn').classList.remove('active');
      this.classList.add('active');
      vnMode = false;
      document.body.classList.remove('vn-mode');
      localStorage.setItem('reading-pacer-vnmode', 'false');
      if (words.length > 0) renderText();
    });

    // VN Radius slider
    document.getElementById('settingsVnRadius').addEventListener('input', function() {
      vnRadius = parseInt(this.value);
      document.getElementById('vnRadiusValue').textContent = this.value;
      localStorage.setItem('reading-pacer-vnradius', this.value);
      if (vnMode && words.length > 0) renderText();
    });

    // VN Sentence Buffer slider
    document.getElementById('settingsVnSentenceBuffer').addEventListener('input', function() {
      vnSentenceBuffer = parseInt(this.value);
      document.getElementById('vnSentenceBufferValue').textContent = this.value;
      localStorage.setItem('reading-pacer-vnsentencebuffer', this.value);
      if (vnMode && words.length > 0) renderText();
    });

    // Sentence Border toggle
    document.getElementById('vnBorderOn').addEventListener('click', function() {
      document.getElementById('vnBorderOff').classList.remove('active');
      this.classList.add('active');
      vnBorder = true;
      localStorage.setItem('reading-pacer-vnborder', 'true');
      if (words.length > 0) drawVnBorder();
    });
    document.getElementById('vnBorderOff').addEventListener('click', function() {
      document.getElementById('vnBorderOn').classList.remove('active');
      this.classList.add('active');
      vnBorder = false;
      localStorage.setItem('reading-pacer-vnborder', 'false');
      drawVnBorder(); // Will hide the SVG
    });

    // Sentence Border color
    document.getElementById('borderColor').addEventListener('input', function() {
      borderColor = this.value;
      localStorage.setItem('reading-pacer-border-color', this.value);
      document.documentElement.style.setProperty('--border-color', this.value);
    });

    // Sentence Border opacity
    document.getElementById('borderOpacity').addEventListener('input', function() {
      borderOpacity = parseInt(this.value);
      document.getElementById('borderOpacityValue').textContent = this.value + '%';
      localStorage.setItem('reading-pacer-border-opacity', this.value);
      document.documentElement.style.setProperty('--border-opacity', this.value / 100);
    });

    // Sentence Border width
    document.getElementById('borderWidth').addEventListener('input', function() {
      borderWidth = parseInt(this.value);
      document.getElementById('borderWidthValue').textContent = this.value + 'px';
      localStorage.setItem('reading-pacer-border-width', this.value);
      document.documentElement.style.setProperty('--border-width', this.value);
    });

    // Half-bold mode toggle (הדגשת חצי)
    document.getElementById('halfBoldModeOn').addEventListener('click', function() {
      document.getElementById('halfBoldModeOff').classList.remove('active');
      this.classList.add('active');
      halfBoldMode = true;
      document.getElementById('textDisplay').classList.add('half-bold-mode');
      document.documentElement.style.setProperty('--half-bold-color', halfBoldColor);
      localStorage.setItem('reading-pacer-halfbold', 'true');
      if (words.length > 0) renderText();
    });
    document.getElementById('halfBoldModeOff').addEventListener('click', function() {
      document.getElementById('halfBoldModeOn').classList.remove('active');
      this.classList.add('active');
      halfBoldMode = false;
      document.getElementById('textDisplay').classList.remove('half-bold-mode');
      localStorage.setItem('reading-pacer-halfbold', 'false');
      if (words.length > 0) renderText();
    });

    // Half-bold color picker
    document.getElementById('settingsHalfBoldColor').addEventListener('input', applyHalfBoldColor);

    // Half-bold color opacity slider
    document.getElementById('halfBoldColorOpacity').addEventListener('input', function() {
      document.getElementById('halfBoldColorOpacityValue').textContent = this.value + '%';
      localStorage.setItem('reading-pacer-halfbold-opacity', this.value);
      applyHalfBoldColor();
    });

    // Half-bold font size slider
    document.getElementById('halfBoldFontSize').addEventListener('input', function() {
      document.getElementById('halfBoldFontSizeValue').textContent = this.value + '%';
      localStorage.setItem('reading-pacer-halfbold-fontsize', this.value);
      document.documentElement.style.setProperty('--half-bold-font-size', this.value + '%');
    });

    // Half-bold unread text toggle
    document.getElementById('halfBoldUnreadOn').addEventListener('click', function() {
      document.getElementById('halfBoldUnreadOff').classList.remove('active');
      this.classList.add('active');
      halfBoldUnread = true;
      localStorage.setItem('reading-pacer-halfbold-unread', 'true');
      if (words.length > 0) renderText();
    });
    document.getElementById('halfBoldUnreadOff').addEventListener('click', function() {
      document.getElementById('halfBoldUnreadOn').classList.remove('active');
      this.classList.add('active');
      halfBoldUnread = false;
      localStorage.setItem('reading-pacer-halfbold-unread', 'false');
      if (words.length > 0) renderText();
    });

    // Fake cursor toggle
    document.getElementById('fakeCursorOn').addEventListener('click', function() {
      document.getElementById('fakeCursorOff').classList.remove('active');
      this.classList.add('active');
      fakeCursorEnabled = true;
      localStorage.setItem('reading-pacer-fakecursor', 'true');
      if (words.length > 0) renderText();
    });
    document.getElementById('fakeCursorOff').addEventListener('click', function() {
      document.getElementById('fakeCursorOn').classList.remove('active');
      this.classList.add('active');
      fakeCursorEnabled = false;
      localStorage.setItem('reading-pacer-fakecursor', 'false');
      if (words.length > 0) renderText();
    });

    // Fake cursor color
    document.getElementById('fakeCursorColor').addEventListener('input', function() {
      fakeCursorColor = this.value;
      localStorage.setItem('reading-pacer-fakecursor-color', this.value);
      document.documentElement.style.setProperty('--fake-cursor-color', this.value);
    });

    // Fake cursor blink toggle
    document.getElementById('fakeCursorBlinkOn').addEventListener('click', function() {
      document.getElementById('fakeCursorBlinkOff').classList.remove('active');
      this.classList.add('active');
      fakeCursorBlink = true;
      localStorage.setItem('reading-pacer-fakecursor-blink', 'true');
      if (words.length > 0) renderText();
    });
    document.getElementById('fakeCursorBlinkOff').addEventListener('click', function() {
      document.getElementById('fakeCursorBlinkOn').classList.remove('active');
      this.classList.add('active');
      fakeCursorBlink = false;
      localStorage.setItem('reading-pacer-fakecursor-blink', 'false');
      if (words.length > 0) renderText();
    });

    // RSVP mode toggle
    document.getElementById('rsvpModeOn').addEventListener('click', function() {
      document.getElementById('rsvpModeOff').classList.remove('active');
      this.classList.add('active');
      rsvpMode = true;
      localStorage.setItem('reading-pacer-rsvp', 'true');
      if (words.length > 0) renderText();
    });
    document.getElementById('rsvpModeOff').addEventListener('click', function() {
      document.getElementById('rsvpModeOn').classList.remove('active');
      this.classList.add('active');
      rsvpMode = false;
      localStorage.setItem('reading-pacer-rsvp', 'false');
      document.getElementById('rsvpOverlay').classList.remove('active');
      document.body.classList.remove('rsvp-active');
      if (words.length > 0) renderText();
    });

    // RSVP font size slider
    document.getElementById('rsvpFontSize').addEventListener('input', function() {
      rsvpFontSize = parseInt(this.value);
      document.getElementById('rsvpFontSizeValue').textContent = this.value + '%';
      localStorage.setItem('reading-pacer-rsvp-fontsize', this.value);
      document.documentElement.style.setProperty('--rsvp-font-size', (this.value / 100) + 'em');
      redicleUpdateCount = 2;
      if (rsvpMode && words.length > 0) renderRSVP();
    });

    // RSVP grid toggle
    document.getElementById('rsvpGridOn').addEventListener('click', function() {
      document.getElementById('rsvpGridOff').classList.remove('active');
      this.classList.add('active');
      rsvpGrid = true;
      localStorage.setItem('reading-pacer-rsvp-grid', 'true');
      document.getElementById('rsvpGrid').classList.remove('hidden');
    });
    document.getElementById('rsvpGridOff').addEventListener('click', function() {
      document.getElementById('rsvpGridOn').classList.remove('active');
      this.classList.add('active');
      rsvpGrid = false;
      localStorage.setItem('reading-pacer-rsvp-grid', 'false');
      document.getElementById('rsvpGrid').classList.add('hidden');
    });

    // RSVP grid opacity slider
    document.getElementById('rsvpGridOpacity').addEventListener('input', function() {
      rsvpGridOpacity = parseInt(this.value);
      document.getElementById('rsvpGridOpacityValue').textContent = this.value + '%';
      localStorage.setItem('reading-pacer-rsvp-grid-opacity', this.value);
      document.documentElement.style.setProperty('--rsvp-grid-opacity', this.value / 100);
    });

    // RSVP text height slider
    document.getElementById('rsvpTextHeight').addEventListener('input', function() {
      rsvpTextHeight = parseInt(this.value);
      document.getElementById('rsvpTextHeightValue').textContent = this.value + '%';
      localStorage.setItem('reading-pacer-rsvp-text-height', this.value);
      redicleUpdateCount = 2;
      if (rsvpMode && words.length > 0) renderRSVP();
    });

    // RSVP text horizontal position slider
    document.getElementById('rsvpTextPosition').addEventListener('input', function() {
      rsvpTextPosition = parseInt(this.value);
      document.getElementById('rsvpTextPositionValue').textContent = this.value + '%';
      localStorage.setItem('reading-pacer-rsvp-text-position', this.value);
      redicleUpdateCount = 2;
      if (rsvpMode && words.length > 0) renderRSVP();
    });

    // RSVP ORP (Spritz) mode toggle
    document.getElementById('rsvpOrpOn').addEventListener('click', function() {
      rsvpOrpMode = true;
      redicleUpdateCount = 2;
      localStorage.setItem('reading-pacer-rsvp-orp', 'true');
      document.getElementById('rsvpOrpOn').classList.add('active');
      document.getElementById('rsvpOrpOff').classList.remove('active');
      if (rsvpMode && words.length > 0) renderRSVP();
    });
    document.getElementById('rsvpOrpOff').addEventListener('click', function() {
      rsvpOrpMode = false;
      localStorage.setItem('reading-pacer-rsvp-orp', 'false');
      document.getElementById('rsvpOrpOff').classList.add('active');
      document.getElementById('rsvpOrpOn').classList.remove('active');
      if (rsvpMode && words.length > 0) renderRSVP();
    });

    // Global brightness slider
    document.getElementById('globalBrightness').addEventListener('input', function() {
      globalBrightness = parseInt(this.value);
      document.getElementById('globalBrightnessValue').textContent = this.value + '%';
      localStorage.setItem('reading-pacer-brightness', this.value);
      applyGlobalFilters();
    });

    // Global contrast slider
    document.getElementById('globalContrast').addEventListener('input', function() {
      globalContrast = parseInt(this.value);
      document.getElementById('globalContrastValue').textContent = this.value + '%';
      localStorage.setItem('reading-pacer-contrast', this.value);
      applyGlobalFilters();
    });

    function applyHalfBoldColor() {
      const color = document.getElementById('settingsHalfBoldColor').value;
      const opacityVal = parseInt(document.getElementById('halfBoldColorOpacity').value);
      const opacity = opacityVal / 100;
      localStorage.setItem('reading-pacer-halfbold-color', color);
      localStorage.setItem('reading-pacer-halfbold-opacity', opacityVal);

      if (opacity === 0) {
        document.documentElement.style.setProperty('--half-bold-color', 'inherit');
      } else {
        document.documentElement.style.setProperty('--half-bold-color', hexToRgba(color, opacity));
      }
      if (halfBoldMode && words.length > 0) renderText();
    }

    document.getElementById('settingsVolume').addEventListener('input', function() {
      document.getElementById('volumeValue').textContent = this.value + '%';
      applyVisualSettings();
    });

    // Animation settings
    document.getElementById('settingsPopSize').addEventListener('input', function() {
      const val = this.value;
      document.getElementById('popSizeValue').textContent = val + '%';
      document.documentElement.style.setProperty('--pop-scale', 1 + val / 100);
      applyVisualSettings();
    });

    document.getElementById('settingsAnimSpeed').addEventListener('input', function() {
      const val = this.value;
      document.getElementById('animSpeedValue').textContent = (val / 100).toFixed(2) + 's';
      document.documentElement.style.setProperty('--anim-speed', (val / 100) + 's');
      applyVisualSettings();
    });

    // Initialize animation CSS vars
    document.documentElement.style.setProperty('--pop-scale', 1.08);
    document.documentElement.style.setProperty('--anim-speed', '0.15s');

    // Web Audio API - zero latency sound
    // Pattern: click1, click2, click2, click2, repeat (metronome pattern)
    let audioCtx = null;
    let clickBuffers = [null, null];
    let pageFinishBuffer = null;
    let clickPattern = 0;
    let audioReady = false;
    let metronomeEnabled = localStorage.getItem('reading-pacer-metronome') !== 'false';

    // TTS (Text-to-Speech) state - uses local edge-tts server
    let ttsEnabled = localStorage.getItem('reading-pacer-tts') === 'true';

    // TTS initialization (uses local edge-tts server on port 5111)
    function initTTS() {
      // Check if TTS server is available
      fetch('http://127.0.0.1:5111/', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text: 'test' })
      })
      .then(() => log('TTS: server connected (edge-tts)', 'i'))
      .catch(() => log('TTS: server not running - launch with ./launch.sh', 'w'));
    }

    // TTS audio system with pre-generation using Web Audio API for zero latency
    let ttsCache = new Map();  // text -> AudioBuffer
    let ttsGenerating = false;
    let ttsCancelled = false;
    let ttsGenerationProgress = 0;
    let ttsTotalChunks = 0;
    let ttsCurrentSource = null;  // Current playing BufferSource
    let ttsPlaybackRate = parseFloat(localStorage.getItem('reading-pacer-tts-speed')) || 1;
    let ttsFullMode = false;

    // Get TTS rate string from user-selected speed (e.g. 1.5 -> "+50%")
    function calculateTTSRate() {
      const ratePercent = Math.round((ttsPlaybackRate - 1) * 100);
      return ratePercent >= 0 ? `+${ratePercent}%` : `${ratePercent}%`;
    }

    // Calculate and show recommended TTS speed based on WPM and chunk size
    function updateRecommendedSpeed() {
      const timePerChunk = (chunkSize / wpm) * 60;
      const estimatedSpeakTime = chunkSize * 0.40; // ~0.40s per Hebrew word
      const speedMultiplier = estimatedSpeakTime / timePerChunk;
      const recommended = Math.max(0.5, Math.min(4, speedMultiplier));
      const el = document.getElementById('ttsSpeedRec');
      if (el) el.textContent = 'מומלץ: ' + recommended.toFixed(1) + 'x';
    }

    // Get text for a specific chunk index
    function getChunkText(startIdx) {
      let chunkEnd;
      if (sentenceMode) {
        const sentIdx = sentences.findIndex(s => startIdx >= s.startIdx && startIdx < s.endIdx);
        if (sentIdx < 0) return '';
        const lastSentIdx = Math.min(sentIdx + chunkSize - 1, sentences.length - 1);
        const lastSent = sentences[lastSentIdx];
        chunkEnd = lastSent ? lastSent.endIdx : words.length;
      } else {
        chunkEnd = Math.min(startIdx + chunkSize, words.length);
      }
      const chunkWords = words.slice(startIdx, chunkEnd)
        .filter(w => !w.isLine && !w.isParagraph)
        .map(w => typeof w === 'string' ? w : (w.text || w.word || String(w)));
      return chunkWords.join(' ').trim();
    }

    // Get all chunk indices (simulating actual playback traversal with skipBreaks)
    function getAllChunkIndices() {
      const indices = [];
      if (sentenceMode) {
        for (let i = 0; i < sentences.length; i += chunkSize) {
          indices.push(sentences[i].startIdx);
        }
      } else {
        // Simulate actual nextChunk() traversal which uses skipBreaks
        let idx = 0;
        while (idx < words.length) {
          indices.push(idx);
          idx = skipBreaks(idx + chunkSize, 1);
          // Prevent infinite loop if skipBreaks returns same index
          if (indices.length > 0 && idx <= indices[indices.length - 1]) break;
        }
      }
      return indices;
    }

    // Pre-generate all TTS audio for current text
    async function pregenerateTTS() {
      if (!ttsEnabled || ttsGenerating || words.length === 0) return;
      
      // Ensure audioCtx is initialized (same as metronome uses)
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)({
          latencyHint: 'interactive',
          sampleRate: 44100
        });
      }
      if (audioCtx.state === 'suspended') {
        await audioCtx.resume();
      }
      
      ttsGenerating = true;
      ttsCache.clear();
      
      const rate = calculateTTSRate();
      const TTS_PORTS = [5111, 5112, 5113, 5114, 5115];
      
      if (ttsFullMode) {
        // Full mode: generate one audio for entire text
        const fullText = words
          .filter(w => !w.isLine && !w.isParagraph)
          .map(w => typeof w === 'string' ? w : (w.text || w.word || String(w)))
          .join(' ').trim();
        
        ttsTotalChunks = 1;
        ttsGenerationProgress = 0;
        log('TTS: Generating full page audio...', 'i');
        updateTTSProgress();
        
        try {
          const response = await fetch(`http://127.0.0.1:${TTS_PORTS[0]}/`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ text: fullText, rate })
          });
          if (response.ok) {
            const arrayBuffer = await response.arrayBuffer();
            const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
            ttsCache.set('__FULL__', audioBuffer);
          }
        } catch (e) {
          log('TTS gen error: ' + e.message, 'e');
        }
        ttsGenerationProgress = 1;
        updateTTSProgress();
      } else {
        // Normal mode: generate per chunk
        const indices = getAllChunkIndices();
        ttsTotalChunks = indices.length;
        ttsGenerationProgress = 0;
        
        log('TTS: Pre-generating ' + ttsTotalChunks + ' chunks...', 'i');
        updateTTSProgress();
        
        const promises = indices.map(async (idx, i) => {
          const text = getChunkText(idx);
          if (!text) return;
          
          const port = TTS_PORTS[i % TTS_PORTS.length];
          
          try {
            const response = await fetch(`http://127.0.0.1:${port}/`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ text, rate })
            });
            if (response.ok) {
              const arrayBuffer = await response.arrayBuffer();
              const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
              ttsCache.set(text, audioBuffer);
            }
          } catch (e) {
            log('TTS gen error port ' + port + ': ' + e.message, 'e');
          }
          
          ttsGenerationProgress++;
          updateTTSProgress();
        });
        
        await Promise.all(promises);
      }
      
      ttsGenerating = false;
      log('TTS: Ready! ' + ttsCache.size + ' chunks cached', 'i');
      updateTTSProgress();
      
      // Re-render to show plain text in full mode
      if (ttsFullMode) {
        renderText();
      }
    }

    // Update progress indicator
    function updateTTSProgress() {
      const loadBtn = document.getElementById('ttsLoadBtn');
      const loadingEl = document.getElementById('loadingText');
      if (!loadBtn) return;
      
      const pct = Math.round((ttsGenerationProgress / ttsTotalChunks) * 100);
      
      if (ttsGenerating) {
        if (ttsFullMode) {
          loadBtn.textContent = 'טוען...';
          if (loadingEl) loadingEl.textContent = 'טוען הקראה מלאה...';
        } else {
          loadBtn.textContent = 'טוען ' + pct + '%';
          if (loadingEl) loadingEl.textContent = 'טוען הקראה... ' + pct + '%';
        }
      }
    }

    // Speak the current chunk (instant from cache via Web Audio API)
    let ttsFullPlaying = false;  // Track if full mode audio is already playing
    
    function speakChunk() {
      if (!ttsEnabled) return;
      if (ttsCache.size === 0) return;  // No loaded audio
      
      // Full mode: play entire audio once, ignore chunk calls
      if (ttsFullMode) {
        if (ttsFullPlaying) return;  // Already playing
        if (ttsCache.has('__FULL__')) {
          log('[TTS] Playing full page audio', 'i');
          ttsFullPlaying = true;
          playTTSBuffer(ttsCache.get('__FULL__'));
        }
        return;
      }
      
      // Use currentIndex directly - must match pre-generation indices
      const text = getChunkText(currentIndex);
      if (!text) return;
      
      log('[TTS] idx=' + currentIndex + ' cache:' + ttsCache.has(text), 'i');
      
      // Stop previous audio
      if (ttsCurrentSource) {
        try { ttsCurrentSource.stop(); } catch(e) {}
        ttsCurrentSource = null;
      }
      
      if (ttsCache.has(text)) {
        // Cache hit - play instantly via Web Audio API
        log('[TTS] CACHE HIT', 'i');
        playTTSBuffer(ttsCache.get(text));
      } else if (!ttsGenerating) {
        log('[TTS] CACHE MISS - fetching', 'w');
        // Cache miss - generate on demand as fallback
        fetch('http://127.0.0.1:5111/', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text, rate: calculateTTSRate() })
        })
        .then(r => r.arrayBuffer())
        .then(arrayBuffer => audioCtx.decodeAudioData(arrayBuffer))
        .then(audioBuffer => {
          ttsCache.set(text, audioBuffer);
          playTTSBuffer(audioBuffer);
        })
        .catch(() => {});
      }
    }
    
    // Play AudioBuffer via Web Audio API (zero latency, silence trimmed)
    async function playTTSBuffer(buffer) {
      log('[TTS] play buffer ' + buffer.duration.toFixed(3) + 's', 'i');
      
      if (!audioCtx) {
        log('[TTS] ERROR: audioCtx null!', 'e');
        return;
      }
      if (audioCtx.state === 'suspended') {
        log('[TTS] resuming audioCtx...', 'i');
        await audioCtx.resume();
        log('[TTS] resumed: ' + audioCtx.state, 'i');
      }
      
      // Find where actual audio starts (skip leading silence)
      const channelData = buffer.getChannelData(0);
      const threshold = 0.05;
      let startSample = 0;
      
      for (let i = 0; i < channelData.length - 100; i++) {
        if (Math.abs(channelData[i]) > threshold) {
          startSample = Math.max(0, i - 200);
          break;
        }
      }
      
      const startOffset = startSample / buffer.sampleRate;
      log('[TTS] trim: ' + startOffset.toFixed(3) + 's', 'i');
      console.log('[TTS] Silence trimmed:', startOffset.toFixed(3) + 's, playing now');
      
      ttsCurrentSource = audioCtx.createBufferSource();
      ttsCurrentSource.buffer = buffer;
      ttsCurrentSource.connect(audioCtx.destination);
      ttsCurrentSource.onended = () => { log('[TTS] audio ended', 'i'); ttsFullPlaying = false; };
      log('[TTS] STARTING audio now, offset=' + startOffset.toFixed(3), 'i');
      ttsCurrentSource.start(0, startOffset);
    }

    // Stop TTS
    function stopTTS() {
      if (ttsCurrentSource) {
        try { ttsCurrentSource.stop(); } catch(e) {}
        ttsCurrentSource = null;
      }
    }

    // Clear TTS cache (call when text changes)
    function clearTTSCache() {
      ttsCache.clear();
      ttsGenerationProgress = 0;
      ttsFullPlaying = false;
    }

    // Initialize TTS on load
    initTTS();

    // Restore metronome toggle UI state
    if (!metronomeEnabled) {
      document.getElementById('metronomeOn').classList.remove('active');
      document.getElementById('metronomeOff').classList.add('active');
    }

    // Restore TTS toggle UI state
    if (ttsEnabled) {
      document.getElementById('ttsOff').classList.remove('active');
      document.getElementById('ttsOn').classList.add('active');
      document.querySelector('.tts-controls').style.display = 'flex';
    }
    updateRecommendedSpeed();

    // Restore VN mode toggle UI state
    if (vnMode) {
      document.getElementById('vnModeOff').classList.remove('active');
      document.getElementById('vnModeOn').classList.add('active');
      document.body.classList.add('vn-mode');
    }

    // Restore VN radius slider
    document.getElementById('settingsVnRadius').value = vnRadius;
    document.getElementById('vnRadiusValue').textContent = vnRadius;

    // Restore VN sentence buffer slider
    document.getElementById('settingsVnSentenceBuffer').value = vnSentenceBuffer;
    document.getElementById('vnSentenceBufferValue').textContent = vnSentenceBuffer;

    // Restore sentence border settings
    if (vnBorder) {
      document.getElementById('vnBorderOff').classList.remove('active');
      document.getElementById('vnBorderOn').classList.add('active');
    }
    document.getElementById('borderColor').value = borderColor;
    document.documentElement.style.setProperty('--border-color', borderColor);
    document.getElementById('borderOpacity').value = borderOpacity;
    document.getElementById('borderOpacityValue').textContent = borderOpacity + '%';
    document.documentElement.style.setProperty('--border-opacity', borderOpacity / 100);
    document.getElementById('borderWidth').value = borderWidth;
    document.getElementById('borderWidthValue').textContent = borderWidth + 'px';
    document.documentElement.style.setProperty('--border-width', borderWidth);

    // Restore continuous highlight setting
    if (highlightContinuous) {
      document.getElementById('highlightContinuousOff').classList.remove('active');
      document.getElementById('highlightContinuousOn').classList.add('active');
      document.getElementById('textDisplay').classList.add('highlight-continuous');
    }

    // Restore half-bold mode settings (הדגשת חצי)
    if (halfBoldMode) {
      document.getElementById('halfBoldModeOff').classList.remove('active');
      document.getElementById('halfBoldModeOn').classList.add('active');
      document.getElementById('textDisplay').classList.add('half-bold-mode');
    }
    if (halfBoldColor) {
      document.getElementById('settingsHalfBoldColor').value = halfBoldColor;
      document.documentElement.style.setProperty('--half-bold-color', halfBoldColor);
    }
    if (halfBoldUnread) {
      document.getElementById('halfBoldUnreadOff').classList.remove('active');
      document.getElementById('halfBoldUnreadOn').classList.add('active');
    }

    // Restore fake cursor settings
    if (fakeCursorEnabled) {
      document.getElementById('fakeCursorOff').classList.remove('active');
      document.getElementById('fakeCursorOn').classList.add('active');
    }
    if (fakeCursorColor) {
      document.getElementById('fakeCursorColor').value = fakeCursorColor;
      document.documentElement.style.setProperty('--fake-cursor-color', fakeCursorColor);
    }
    if (fakeCursorBlink) {
      document.getElementById('fakeCursorBlinkOff').classList.remove('active');
      document.getElementById('fakeCursorBlinkOn').classList.add('active');
    }

    // Restore brightness/contrast
    document.getElementById('globalBrightness').value = globalBrightness;
    document.getElementById('globalBrightnessValue').textContent = globalBrightness + '%';
    document.getElementById('globalContrast').value = globalContrast;
    document.getElementById('globalContrastValue').textContent = globalContrast + '%';
    applyGlobalFilters();

    // Restore RSVP settings
    if (rsvpMode) {
      document.getElementById('rsvpModeOff').classList.remove('active');
      document.getElementById('rsvpModeOn').classList.add('active');
    }
    document.getElementById('rsvpFontSize').value = rsvpFontSize;
    document.getElementById('rsvpFontSizeValue').textContent = rsvpFontSize + '%';
    document.documentElement.style.setProperty('--rsvp-font-size', (rsvpFontSize / 100) + 'em');
    if (rsvpGrid) {
      document.getElementById('rsvpGridOff').classList.remove('active');
      document.getElementById('rsvpGridOn').classList.add('active');
    } else {
      document.getElementById('rsvpGrid').classList.add('hidden');
    }
    document.getElementById('rsvpGridOpacity').value = rsvpGridOpacity;
    document.getElementById('rsvpGridOpacityValue').textContent = rsvpGridOpacity + '%';
    document.documentElement.style.setProperty('--rsvp-grid-opacity', rsvpGridOpacity / 100);
    document.getElementById('rsvpTextHeight').value = rsvpTextHeight;
    document.getElementById('rsvpTextHeightValue').textContent = rsvpTextHeight + '%';
    document.getElementById('rsvpTextPosition').value = rsvpTextPosition;
    document.getElementById('rsvpTextPositionValue').textContent = rsvpTextPosition + '%';
    if (rsvpOrpMode) {
      document.getElementById('rsvpOrpOn').classList.add('active');
      document.getElementById('rsvpOrpOff').classList.remove('active');
    }

    // Update VN border on scroll
    let vnBorderScrollTimeout;
    window.addEventListener('scroll', function() {
      if (vnBorder) {
        clearTimeout(vnBorderScrollTimeout);
        vnBorderScrollTimeout = setTimeout(drawVnBorder, 16); // ~60fps throttle
      }
    });

    // Embedded audio as base64
    const CLICK1_B64 = '//OEZAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAADAAAFcABcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFzCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsL///////////////////////////////////////////8AAABQTEFNRTMuMTAwBHgAAAAAAAAAADUIJAJcLQAB4AAABXB6+3Z4AAAAAAAAAAAAAAAAAAAA//PUZAAI8E97f6CMABabBlZfQSgAuJdmjACcgfl2UAAZAAAAFyAAAF/oiJuAAAgaD4fwfB/WD4fdWD4OHMHwQOYOAg78oGK0p//KBjo5QEP/1g+flwf5v///5cH5bI1EA5eDBAMYxvgGMY+QBjyApoQhCEoIB8XcQDgoRvOc5znIQhCEIQhznO5znOQhG+/+QhEb/8hzoIBwOBwjIT/////znOf5CEJ//5CCAcDjCYAAQOEwyJw+hnSpOnDgAAAlCYAsQADgNAGijNkEgjoRLlpGpzGRSBAy2xFm/YUFCzxgVgQBQ9wpGXlWi3QRABqsLbr4LnI1A0HEwxQ0VqGAOBuYgQqBqQCYq1mAsAoYIoZZjMkuAoHkCgKAgAcvymUYr4Q5gWAUFtm3ZkYtoIA8AanE0yfQxTpaIraoK+hCAEl+MgDIhMzQ+IgARIAdOFhy1WRsBWLFHRXbAsMvg7bwOVJmsuFQXb8ttS6NLlZbVYCXdWkYAAJZgMgDQDFtRB+kMjANAcMLAFkxJQA0EtbuWE6SAJGDeFYYQ4ESZxMAaFwAC5qCrsLRRVZq0lUrObYQ//PkZPkw5htbf8z4JBhapn7/j1AADCvqCoHdqVXa0kruS7JQABDc5zmGGeHcO1aXtWl7MxnNeIEACHgGVTONKoas4444zUjpZcnoYGoKQCA0FgFnsu0HP//7l+dC3sq1M/8a1Ko1yVRr60axuSqryJRGWvV//J7dM+0GQNfvQW/s1fj1qUvs6KgohAOvc+VSrCjwi1DKrV/DsrjspkMolc1DuZux4p2p0AAB+kdAFtAiVxiDbN98TZJ63jbBG9EechrLoYErcMdY55L7/RKnnGLs5j/8z6qa/T8fDomfqFUt/Nbf756XS5yPNR2oqU9v+UEke/1nqTugVRf/l6v9dWZzK3EaSEggJKRH8cDAIlszMpGkUWJVVYcSSeSIBCSiOaRgX+BuIRsAsFAyiEDSIwDiQEAYGGDgKARlAyMKWE2hYSIJF8ipOmqi8Xi8ykieTLpdNW1GReIsXjZ6ki8XjZJKkZF4vJUS6XXWijSS6KLVJVEyQEgpqZF4zICOafJkc0ipqkXi8bIt1JJJekkkkkj/rRRRR9aKKKKP0UUUUUUXWYkyRUusXiLF01RpJJJEWLpqj1oo0WUkXknWkkklRRRRSSSSSSrRSSSSSdExLqT0UWUXi8xkXi8bJPqSNhsU//OkZNsbehEtD+NQAIwQAjGdwAAAFGog4FyfhWCoKuKhqDTg79axE8SnesFYl/4lBXKgqd1gqd/iU7/WdywNf5b+Iga/kUxBTUUzLjEwMKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq';
    const PAGE_FINISH_B64 = '//uUxAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAAuAAAlgAAVFSUlMDA6OkVFUFBQWFheXmZmbGxycnl5eYCAhoaMjJGRmJicnJyhoaWlqamsrLCwtLS0t7e6ur6+wMDExMTIyMvLzs7S0tXV2NjY3Nzg4OPj5ubq6u3t7fDw9PT29vz8//8AAABQTEFNRTMuMTAwBLkAAAAAAAAAABUgJAO4gQAB4AAAJYBn3bqeAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//vUxAAABuQDTfQQACNwL2g/MZAAEQE0SJRNrU5NxwQBAwBwfe9K1g+8H5QEMEDmXB8/5c5ggCYPg+X/4nBAMf/+CAA/n/WD4Pg+CBgKmMS5sIuaoahUiclszmYqQ6tUbIvCCaMiQBoEiOARsWKhC+wRJB4PIYijSm70KRBjiMrZIwxf8aADAPSdRebTGTtAd6vEnefRhn35BImuQqLyqAYShLkcSenUfduMw3Xf6xRPbL4vBsCwIwC5GZdKJJL6Cpdl8jsv/GtSSxjUhtddHLollTSuKWOdlcqoLkD9rcjdetFZvCtJLGWV7V+xnV5ju/e+tVqyvPuUVt95f7Kb//fqXpfUxs38oxjhf5K45AUM0FethWi0l7nQ5356c7zWef0eP/////SqIgR1qaQzIRVUidcsu211lGiicGFBgxLGWk2Og44CKQKNTDSdMnvwIB5js0GSEQfNiJsROHMK2ZIER4LVDlORMC1Yl8d6xsQmEmaqQMNQChQQwBWHmQUiuX1OYxQ0DAmrMCTSqQZaJvxkAi70MgdaIUkvkw0JheVYFJMWYYAPAiAFJJ6hYZF1VEWRa5wswkmmo3N/IKVymSzpOoeJVKm23rPXlaxSq7RTcVicBpG0zkOMjcthIUdAL0qIjhSLLGJxzXbvK0hcNkim7+Okkw+I0Q6LF3KXQk8/0qbA38TXpDqHJ7v25jS2or+gmmdPv6trUY5LE8qjFKPOL7fVhbwoPtWgCUPA2Z2BAFqW6t2gwSGYhFXIm4bZhVjNdx0lCYyLvs0h/GPVgqKlbewov////////////////////mu//9CwbTDyiqjkcIvh8LJrkQ0IMMmNhCgQ6AVzzPiTFAwEDNWjNIUMtUMmXWsEJjEFmegAsQm1DmGgMj8GlKcKDbT3tyL1uAaQH2RdJQ5FWIq8uw+aEgEplMl5AzfNzTEi5hKZRl+4NawlFAQmpEGERpp7sQ3113YZkgAeRFMQCdktkX1za9LOUmF57X7v8cNnbrlvHNX00lxy//u0xOuAJ/3BN/nMgAQer2x/NYIAEDMFMwHmkz5g28coqRr78Po4iKax37fhONijHDuV74m+CFO5+JyP+dpNTEoilWNy+HIxOO41h/ozt/IGhMYZzAVIyy/BVmvb3fpKjW5fxXluewUEil6y5cvw/qW5lCnG+r80uoZpJRA9JK///Kf/+fr4yaZFIQKAIQfQiBC1CSbz8YN43JqojHgI6g+o4YMCqB21U2WxVlyyxNrbAcmEvuH2m16q7uVpcIa50wjte2MZp21gj+kfDM7bHPGcw58xca9d4lr7btjWfXfrU/MTafRmeHBi5xn1rR7G966////38Wtu39rett/WqZmxNFYYL2JAhWj4XIVgtSis9njQYMTwGd6hs2dQmaNHVcBDlPGhPs/WYt9y21VnFk1UYgASRoWSqhgbGjC3ctKsRL8xrgRDqyJOoyDdGK2wsIQ8TMnEaIsQx7DLxHiq0JmG5P+75VcU6uib6kKoX4Svzv3LISr2ZsidLp4+tEiRoHdKJQLqyLGyZ3q6RAkUkVJrbVSZFSDNup1nEq9dW61o2TpIHHAXGMlGTsrWVmI0xPGKzJi8M8Paa0jqFVJB0T5ia8FmkjMxAAAAgdg4FxQhQokV6UBpKQjEOjiyf7FdPEyb5VSw9T030kdkHztNnqglVaW4xIiomjRWXEakjU6ZFdB5mThRKx9RRcmWRSNkFK0EDBaJkkySbFg1HkmwEgkBumxASLDupHFspE2ZE2MT5dQNmLzaLdbJorOHmNDd//uUxN0AFNmBcf2ngAJYsC49hMH8H9NJAmGorRVLxFB0ihQEpxSpXYhykzllCE+Sj4ErE6EVFBTREqYmWZrVZProZY3PKGSiIAHSsKslehikhgiSAAwAEmFhh5ALA4oDX9pYFrsZuXYOhiO8oaOW5XO/Yn85M/Wtof0v47qba2VrLD8Y9YU1eIx2MRnfuq7qmuxXqtrPZnutYpLOVN7L4gcB7ot5lFpZZrWuZf9bmE3AlnXe4Y/n3mH/rD9z3N8z5Lv33///ufjuzhlQUuOrURjsBnMyNJwijj85Kb9eri8zDpbHb8Vo3JpKStWgevAWOr367+rVPyjV9s1aYAAAAA8CiAckGEcpFI8TdwQErEQEK8T6VHDawi1Havz0nldqxHrnI9Gf5EJJbp3dlNYRGRevXv4ZSsLJBUMZYVI/YzTaWKWxHludSVhvXcevveWZi1aezPbsxbC9D0AiACbkbGMKUCwk9ygL6JdU2EzfsductyJwalnly1r7t69du9uf//uUxPQAlV2BZexRN+LVsCv9pmcUldvb1jWrY373N0nNx3DVTWF7LVvlV05QyJVIw6kBQc4kuVRlDtU0v1Way8r5LNj8I5C7jeuG6DjU7UojEZ39Wt40strRZ0hoZUUAfMkCcgOfOIGRkRw9Eks+ajiPMFPmnm8cMv0n3yaYcSLTm5T5xZ42wVpueAd4Sc1PA34DFPCvK3qBdMFG1SRihLrI7iyt1oMsWtW+Jv+mP9mbEaitDeLN7PgHRnGijhN/VinLc/X7+u1ZmDr1THDfP/G/l/bmtVt61lbucz5e33l25dwt7q186XOvL4IUqdZnAROK1Td6K/Yeu5IN6cCSPfJ+U2rsLkLfMBy+pO0t7///rcu2VXJ1hCNDQAAAAd/hGZWkABX6MrUKR5XoCAvurOt2Pt0c6LVI/BzvO13J8UxmXxSX2N4yncCXJsQ2kz7zGfOyd67it+okNknl1EKtUsl8SNkfV5aWgPrSRnkXHWV2nj8++kXMEAFAikXFAAWC//uUxPkA2ZGBVay/eKLnMCp5l+n82RI/yltaWNvrjjz/52gtXr+Wfc9V8P3hveNbGr/1O5dy7+s/1uhqzuOVWPSPkDsrjrKcjCp8FALgT0xegqnn7eT0QbIYZov1jVlsfjWWoasos1pkzKIIH4IySYRTkiXGHVzGQ4OgkJNVYRWvLlG1mzdpZyW7bBtqN/eX93/Y3brBSGfpq2v/WPcL9m84tPJapJAogElRZh3Z28TmKmlrY7PICKDYBuUMyB5gwf0L0C0iZsPI5Dkoe+mdNkjZNdB1a9GmYn1NrOP0rrSUlRRl44OcH4ibSTDUgM0KCis+gO88WEnMERQY6T38okRVe7z2m4ZiEyGR4yVcQgMzTiIIYFKCCYpDJ5XwR2SZ081MwJ/vwiNzCVSqORavV3vn8sTdYhEtYf//32WKokmeagVcDQWp1sf/e314p+i7uWyqHfH0AfshwuUXsmCdIs5d/NCeNjx9E7R9uup7df/oL9Tolw+K4ATodhdXUYrV//uUxOsAl21rT+w/eKJvrGo9k1NMcjz6LueyywkAJJzJgNiYdQfOQdS9NQACBl/5GCRELMKrmSyGKLsWzziEWgqzTfbu51alHBNEQEs0ocP/f7DTiuFWsOEtNA+tLyhf1INU21bGqjUU0YInwNXgdiEHDjg65eNiJEyXTa/pKdN66f/ZVX//rpVJMkRQujyBhyG8j0bFQyLbjl0k3/RlQBAEEpUIOCYpwDyXaIyDHVSLHfVQ9qFFVKALtRaopR4t1IkU/v5JgKRcoFpEVFu/c8taicSOkck5uSjEk6Nb+p0Wc1TPdBZgTo3RsAmoaIG1JuHGA0KO9RiSabfqSUh/+91sp///rZM2L5fHJKpdAzfDtnlmqho2Um/+Z0YSBEcKAG2E+RMwACDkQWt4KoQQOLRpnaIIAIWPQBvvD7QPsomvXRGXFPGyBoCYo5BH9JE+6j5sThPMYzAtkwbu9Nd71vRS+kYGRsJ5GgLWFvACjwaIguOaG1k4Q44mk31LST/q//t0xPSAEBVPWeyaeKIMqGk5lM8Jvo2tfr7//QWkTLk8Q4CiYLuKpFjV1Wf/+6VjMAFgQB9QLeB1WnBBqFylqg0RUoWsglA6gDQMVTDjRNcWieshWmr3a5ABWRiAZ1wPBi3mO6TzR1mDppFw4mhM12W1Ru23rTLA3hqCfQaiyYBSsIDAsTEQE5EcYo/6kl/9fQp0qX//90EkCgcNQMGAGIW59P7t7GczCsMLYgSUiBImj5F08ZuenTVwLGo4wRNC69kqbGjmKvUT46RkQMY1Fwu3ZkDB9jsxNGYsoFytU2/Zp/66RJi8IGIVGSClAM7BQMKWJ8jSi3///720///9HQSJwY0IBpOpHHXM/MCs11IjYFAByi2wkaBVCpbrnf/9//tkxPgAD5FBRcwybQn3KCh5hNGYe2VTRUzjSmMwi7ylg+x3OQ9/eq8orv2ayLfou//ufhPbtpe0fJpEFzt/UjW/6DmpFg5xAg24DmUL0i4AvyNoihmpX///0b1W///9EumRDQusKs1q/8ACq53AnATAAcGutPhEqluNUbPYvZwdaKy8VEtaBHm4e8BpBA4DVraEyeySKZvSdQ+h3H0jD/19DnzYhxDRqAkGGGBhnQBI0L2hrBR5EDhih+q3r/9VaTf//9FAuEcQUCBwnjpeStmqz/4A3giAP0JgDQpUCT9YdBcaLfuGYKUf4kE5yCwa//t0xOgADvE/Q+yyiwGcJ+h5hlC43ULwmA7YAX8UU39FJvY8somFi6ihv/6L/XULWoQ0GgAOiAxl0GhUPUl4bIhcfQ0j7r84+tTo/+lXf///rOE0kQ0OLDwl88o/7AAD+DgAHlDoFiRi+6vrGqQU/+Ui+eSNT/rF2PgegN4LFjMn61t5g62NajR//9b1/mJeHGEgQl4GzdDmgsFFLk+OwOUHwPZikv8/Wii3/////9a0FhfFOhz+ANwMkC8BsAMROlvmSpvMtg+z9QEM/1Q5SzeYjPCvCCgGTQwHiGIkiq/5ys2LcwRUr//f9bi8JcRgBEGBZYBtArgGhcCQhAsHBHYeAP3FCF5rP////7t//+iakWG4AYAhAxVaMObdhdVU//tUxP4ADTk5Q+waeEmhp+i9gFCVgbgFAFRs0ajonKAs6ATDv+c8rT6lhsvUssCEo/hc6BmAjAWDoxDU+zoIL913QlI2UY//1v+mXBLiPAwCAwKhoAYNAKroGAYPqBiUBhfMN9EJBQxour////6Lf//WolC8JAASChYCLmhr/KUMqoAJmZA3AAAOsTMBKNntRCanl+TzUwpFUwXdjMG3hyQLAMDVbnC+YZg6p1HVqdOrQWhVcYX/9n+fQHwPghQM//tkxOoBDKE/ReyqheFiJyg9J9AIPAABIiAwWOQO7IwA0ggOAoGGhoCAAilgu0dRIf///////9ZeKzCzAAQ+HSkTIj/xCETIAAACgTgBhOCfQCg8FvIgkOkZIx///1J1oDpAwIFxjBMgOQRIBQrg4IlZF2Umo862W6NHUZiwI//qf//yr1plPQw+KAQDDF4uOmtkwCIzAImMeCcCARSQE4GJLG7////////5GihTETcAJMCwxolRKgmocAAAUA8AAAxc2TG4iChkNUdoz3eumaUDccwDBYODLQCwMA3qjQWEAbaRhmpNBB6vUfqWswHJ//tkxPiADLU9P+wKp6nAJ6c9gdS8V/+o/+ggMyDgKAIRQEAAA4ZgawZAGBBaDQIAo4wLA4EIAAUEI5JaRf///////+6JZLwfkAkcB0woEnVhUzAQASwF4CAB0rSNBSUv9Qxa0jcX/IEZCXIZamIcCIAjIg1AoGQkABhYAjiLqSLl1SL92U1SVys//6j/8sDkEaQYCIFBwKAxOlxJQAQ2A0dwupDFQ3SiaoP////+n0//9dJAsgsChAp1dS27AAkMgDhiMAPdioG6DhXCh2RWf/+rkHNWJR7UedFWUhCQCqHED352pqmRb///qf+cOFME//tkxPsAThU9M+yGp2HHJ6W9Xk/ExoGBFgFLgNNcAJGg3uBjgQwyDkEJpbf////0H0v//RRJUOqYoHd1DxVTQH8DBB5WvYDdUGYiw4avRduDsJFS1WO0jtajEOaRcORAgsgs0eS6lILR7P+3/9T/zjFMAwDgYVEoW/AZTQYJBsLFwMUAcXhgMBaH////////0TxKhtg7hCpczAoMwMA4AogAwpA3KRPDtLps+l+GTkRX9FUzQ5wbRZHOBJqJ8t0FO1TW+pCOgAECDBQGilDrC4xwQKTY7zSpL///////X9RktEMgE4dZLiAAJoKAPgQA//tkxPcADm0/K+yCqSGoJ6X9kVT0AOSjyKMOFK//huyNS/Mjil9IRoYibQMzYFURBH/p/9af/W3////VmgHBAOFwUumj3ZhxoDjZaCYbmBvsn//////+/6OgLJbJcIgImIAngYQP0sMiB21b3l/4tJPK9GtJTajocuQAFgUBipViHDAfrTemsYz/xyP6k1t/5wipmCYcAYIQWBAzpFgMClQDBYGDUwLCYMBDMG6k/////1//NKL/Wi5KCFTb3f/64dwAAZggB9BAAA8jEvJJf/u/71rb/1VSYcoORDD+gvk0G1j32oZgKR/8Vup/3OMv//tUxPWACz07N+zWieF1JyZ9g9S1/nC8WgmJgGi8BiUAAa3vIIDYBgwLh+If4L4iYG5gy///63/0P/u3t8hxGFbzafznWvZVgAAAAABwJ4CAA42gtk1aywIuLWAcIwBESDgQVWta+kIJJf6yKE+zetDMP+cLJMBloFgeG9gZ6iQGFR2BiAdgKB0Fg4MI3RW///71tq///+l7nDZnV3bm+mQAAAAgIAHoZARNf//qb3VPGncQAHAGJANHGD9yILV6//tUxO8ACdk9O+oCmmFBJyZ9TavEHNf+oslxvrRzdv//+vlVRuMFmGAhic6KMZgJiyVA2sJCCDPiAZ/97N/////mE3/9XoWgAAAAsIAfogQGb//zo/qh3Xoi5yeJIDPJRYzV/mTb/+pn/6H////7mIdchYM28MmEH3ntgdprNf///noAAAAiAgAdhgBH//ygSX6KRdG31lgLQCNDeQM1p4LHR7PKbrb/+kbmH+pv///Ve5EmaKLkooHlpmIwCgBC//tkxPUADIk5L+yioSGHpyV9LdaM9qfQKZjfGjv5F//////4s3t+V35VgAAAC4pwPoEAH//8WpPrQW7JD2ruJTNAuuBtPZNlb3mhv/7f+S///94duPqlm7Zx5GWRZA/bz9T////6QaAUA+PqP/rZZCr1FkR4Q4FAiBj1FANAI1dv6//y4j/Uk3/dof0LpBq0DaR0BuMUgOkTvEz////+v//5JcAAAAuwhDjhgALmsyK37S4NpWsoCdx9iCQGgHh0js+YKRVKJp///0mT/+YhewcwDx0xBAQiGQIOAv////sywAAAKtwOOIACHkvnq/oJ//tExP8ACwk3LeECo+FFJyX9TZfE6kvcYw8JCBLGTZovppqqLpr//6/6l/6yMIaG3gbycSQipKFlIv2wAAALgDjiAA0uPNrD2+q65qVpqX1i1uK4ANtE1NX+vf////f/WcFvD0AMvBFJkIVi66u0AAAAEwBxjZrkJEr2Xaxir0BPBsKmBxXwnAzV0FOtNv//q//+gURmA64BlIG5AYSJ1A/VnLkAAACg//tExPOAB3i9OeFTFSFIJyX9XZfEOAAAAJoEBLtfalpueyJRNX5kOsqhcyBrI4caXkUtCjRT/////+5oPsMXAYSmAMDC/ZUKTzmAAAAVjHAEAAuPGhkZtVcK9RqmYGalnB9kMNxmgRHwuuWnbTTVV//////c4MqBlVQX0FKFeyhauAAACKA4AAAAMgKJYk6Xo6bfUgpaz/cuCWkWC6QHg3BqgpnFqWlT//s0xPYCR4i/NeoHeKDxF+Y8EFQsQf/////+xqLIA7E0Bo2FsiKEv//////7yqAAIgKgFFI8DNkRU3+2r1G53UtLWUg0YugLBQP23BERIkapcwZ//8wDjgOikCzAnUx///TVnauwCaywOAAAAMyRBEcEJRZ109f9Temh2N+ZjdNRngNcPEPNH6af//VFhAPq//s0xPcAB6i9OeSCgWDRl6d88FBtRc3W5AACQCgMODEakWTV/+r/rUj0SUJ4gQGdcCyjFS9Kk3/9mDpgGKw4jB1aqAAHAIA4AAACNSHmRiii//q/6jMy1kogTooUCyQdUkjztUpFP/+WC8F9QGtoYVKLRlgABMhLHABtiDgRETJFv/qb/09Ah4zRVE8gZN+I//skxPuARny/Pe2ChWjNF+c9sFB0PLifTdD//TPCPgL+DfiJKrmAAAAAcDgAAAROCRY5Y/rW2kYhkErA1JAej8BIUTqSOlZv/////8xJIMsgNeQUCiDf///////6MAAAAAAsBo4a////apAy1nBGSZFwGR4Zgrs+//s0xPkABzy/N+yCh2DcF2d9oFCtgg7//1LHKB7xJyFq6gAAAACgOAAAAM0BKC////1HX7jpNQ6oGiLkepfTTv//oGoDYHAqqkAAAAJg4ADNzYzLbf//+s4ipZkLSKmJ2LwVGCwiqk2fWr//yuALjpLTVbywAACgYDgAAA3kYEfLM0h20mr/OvzAkTMP0Awk//skxP4AyAi7MeeChyDTl2Z5QFNMIOwbs+gpP//////1ERCAYLmM72ZAACAgaKXMNZ3Ayst6z4f/XSE8GvSFbF0gwGlzjMpL6art//////sI6AIPjImSlXcAAHZAOAAAALAQ9EEKMOabLdv/K3f5D21EqFrpSBCB//skxPSAxei5PeoCemCmF2c5QFNMA+3IHIiRNm06aLf/qWERIGnpCPl////Z///6VKTDxAADs8EkQIAISIeaJMn/zh/60ThgMi+mXA+I2GqBxQ4eoZqtMEU0P/9IL4AaiSMqv///////+qqqipgKgIA4AAAL46gM//skxPmARiS7NemCmmC0Fyc9QE9MWkDQl1igE00/x8H/0ywHvkCP9IiJVD8QBAQg1JfUk3//QFxAZ1gQxU1FyAS9QkYkBNHnAKgDRX8lH6y/LhgHKMWesibjkBCpGK33//9MZ0Dl8jUadwiHCHqAOAAAHrblMq3///skxPuAxwi7MewChaCYFyb5QE9MMkPE6D8QMh4XzUXeobCYSCAUyC2J+lX//3IYB78TQc////////TEBASDhLmA9ftnSf63/IedHEYCbibNuoZpZPAJqi2petv//cpAcGxq86j9dZgAeggIQDgAABi+r9Aa5Nc0//sUxP2ARNi5OeoCOmCpl2a9MENMP/UcM0VF00fUdHCcHWBjnQmp5+62//10gLQ0Q5///////9if2Zm6oAsjgEAADnCgAwQCxHwrr1NYmRBiLyl/6Y5wZCQ6BJJLBqAS//skxPoAxei5NewChSC9lyZ5sFDccX6H//50NsFvuagLcAlwOAAAAL1wLgRRlFgOAOcTwCwZb/dkVVIlNDpEENRaQAQwMikvroN//1gG46P///////QlVD04BMAAmRYgupJ4uhZt1JOGOBxt/6LJsmRdA8/WM2o6//s0xPwAx8S5K+oCmmDglyW5QFNMBjnIxWfrpL//5QARQ4WVS8qbCAqwOAAAAG2Q3w5o5woUA0IdNlJBMEafX1pmhcRGVKiSXkQqAwbI0/b//5kBFUt0EzMTlAGkBmQvkIQkOBQLqUL5FTdnzQwCAMGkSHHquoroogGISRf1f//mYI4bqgmZeoeqgDgAAAnJ//skxP4AxqS5MeoCmmCtlyZ5QE9MOuVCZOCtvdjnirJIs+frfwUsSKR6CQD9lqzfqBRC+BhVQwzz9LSb//////mINyzL///////6ymIWGjJgwBtMpp3BCzIrrfxK1/P+3hBR+ysS+0JGtDNevsOe5QA5RJxf9Fv///sUxP8AhqS3L+oCemCtF2Y5QEtM////+oQULv///////9OKmgCbiKA4EDAAUjCHDZJ4qAOIm6XpayQJEfIY20A2Y2S1/IAtADHhiRf1///WNQeh5H0//+489XBmgF5n//s0xPQABpC3L+oCGmDCFub9UENMZxwACsR3LAQhCS+3eTAEgpac6K1NU+3mdQXCv//zMKMs////f9fXmM7FVdrMAAzNADgQUAA/ROugiCeR3of1GApMTgS5keOBMQeD/ly4GUxt9///1Aehff//Yq1pFMO7W6Fht3THAYABDR2uwrwGKAaEa6j3GcJYMWhp//skxP8AxwS3L+qCGmDAlyX5QEtMpTZRdAeUiL6/UOWtAAYJa+r//9YK+YKZmQgIiKA4AAAZFJaAXPJJ9+GQBoGo8jFWozC3Iw0U6DdZDJkAfIk29b///hIF/u5mZXVZAAXAAHUWAOAjNEidICgyaS1JVBkw8qGd//skxPwAxiy3M+oCGmC7Fua5QDdMEKI1CMBtdXzOoLrK//8C9PqgKXXV79y7uMvAABAADlAhDA4CzKIGBfqrLqXe7euY5PRZ+Zd3VAOSHpNFlHvOVhmm////////rFsRj9zL3s7EABQAAAwJNACARCxdMkUUKFFz//s0xP0AyCi5LewekmDqlyW5jMy0gd4ljek6jEgKT6387iDX//8Ejj7u3N7N1gAUcAHhy4zAUxlLX2h180ebZBgHFu3qtynyvWVOcBNH////////6wuJ3/9viChP/cze7tAAGAAA4VUUETwbg02fkaW2RCBMxYARe9hRd1j11BSN////////UF6VC928y8yw//skxPyAhwS3M+oBumC8oOg9QDcUABwAAGwVQbnBcyI6DVpEhnXRImggcfTGEednUc0UH85hY+///KgDUDl3N5t1JzC2AqVMobPWeu3sBxXRGAECOIohrvCqmrYzbyjgFw////////6JgKEOulVay7jNu7QAHAAO//skxPoABoy3OemBumDJFuc9MDdMsEWCByKmzEWnQzIp29+pDg6RNDRIuHmpe0e3WAot46qgFbQ////////qEpmSG2bq7vMsDimExWotDseTQkoYom5TE+qIcgPKo+xxedRryGorAaAL//8PJqqsuq2pnLIAGAAA//skxPgABcS3MemBumDIFuf9QCsUy3AZKFlQzJJosiyxFA+86m3N6yVDsMo0QtXl5JIGzZW//6AEjuvLDdAN2gAcAAAyHJdZcWvlgenJUY7+YDtemWT+p1DMssLON//1AZWGcAVwaHA4EAABEJLzrJF/e6xYepbx//skxPkABsC3O+7iAcCsFug9QB8Q+H4iDMRyl+LKnANTRKrelrdBBBv/ghReTJ//2f////6FiJ3h4iIeVAHtQAm5qWe8bz3Iw7koZxOu25cHuAxCUuQ7ktXO1cVEBxE5Xdx/Ibt5Siy1mJuya3z7PJXl9/Cm6U97//skxPoABoC1Qeyhp6C1Fqh9lDT04oqGA6HTGo51YrKqyJ395GSJV5TMO0Sl70znfzTAKVUXntEZu9AXoT/l////2q1qd4h3h3dQB6iADeMpEkJQI+hDkePkhTOQUWE+AcxYjtEJMouohqBH0LknyUktXYtpLZE8//skxPqAxby1PeiBWKDBlyb5l8g85MLCmgJED6rSCnDInmaVijQXurW2K6PUryClhXidI5Smi7EIIuFRMuFSVMUmVhU08485++FAIiEgaKu//9NMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//skxPyAxui3N+ymTqCvFyc5QDcUVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//sUxPyABeC3N+mBWKCgFue9ACsUVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//tUxPaABwi5J+oBumHAmmT9l4scVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//s0xPeDzhy3Jeek3CAAAD/AAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV';
    const CLICK2_B64 = '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';

    function b64ToArrayBuffer(b64) {
      const binary = atob(b64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes.buffer;
    }

    // Init audio on every play attempt until ready
    async function initAudio() {
      if (audioReady) return true;
      if (audioCtx) return false; // already trying

      log('Audio: initializing...', 'i');
      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)({
          latencyHint: 'interactive'
        });
        log('Audio: ctx state=' + audioCtx.state, 'i');

        const buf1 = b64ToArrayBuffer(CLICK1_B64);
        const buf2 = b64ToArrayBuffer(CLICK2_B64);
        log('Audio: decoded base64', 'i');

        clickBuffers[0] = await audioCtx.decodeAudioData(buf1);
        clickBuffers[1] = await audioCtx.decodeAudioData(buf2);
        const bufPage = b64ToArrayBuffer(PAGE_FINISH_B64);
        pageFinishBuffer = await audioCtx.decodeAudioData(bufPage);
        log('Audio: buffers ready ' + clickBuffers[0].duration.toFixed(3) + 's', 'i');

        audioReady = true;
        log('Audio: READY!', 'i');
        return true;
      } catch (e) {
        log('Audio: ERROR ' + e.message, 'e');
        audioCtx = null;
        return false;
      }
    }

    async function playClick() {
      if (!metronomeEnabled) return;
      if (!audioReady) {
        await initAudio();
        if (!audioReady) return;
      }
      if (audioCtx.state === 'suspended') {
        await audioCtx.resume();
      }

      const buffer = clickPattern === 0 ? clickBuffers[0] : clickBuffers[1];
      clickPattern = (clickPattern + 1) % 4;

      const source = audioCtx.createBufferSource();
      source.buffer = buffer;
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'highshelf';
      filter.frequency.value = 2000;
      filter.gain.value = -12;
      const gain = audioCtx.createGain();
      gain.gain.value = parseInt(document.getElementById('settingsVolume').value) / 100;
      source.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);
      source.start(0);
    }

    function playWordSound() { log('playWordSound called', 'i'); playClick(); }
    async function playPageFinishSound() {
      if (!audioReady) {
        await initAudio();
        if (!audioReady) return;
      }
      if (audioCtx.state === 'suspended') {
        await audioCtx.resume();
      }
      const source = audioCtx.createBufferSource();
      source.buffer = pageFinishBuffer;
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'highshelf';
      filter.frequency.value = 2000;
      filter.gain.value = -12;
      const gain = audioCtx.createGain();
      gain.gain.value = parseInt(document.getElementById('settingsVolume').value) / 100;
      source.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);
      source.start(0);
    }


    // ==================== LIBRARY SYSTEM ====================
    
    // IndexedDB setup
    const LIBRARY_DB_NAME = 'ReadingPacerLibrary';
    const LIBRARY_DB_VERSION = 1;
    let libraryDB = null;

    function openLibraryDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(LIBRARY_DB_NAME, LIBRARY_DB_VERSION);
        
        request.onerror = () => reject(request.error);
        request.onsuccess = () => {
          libraryDB = request.result;
          resolve(libraryDB);
        };
        
        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains('items')) {
            const store = db.createObjectStore('items', { keyPath: 'id' });
            store.createIndex('lastAccess', 'lastAccess', { unique: false });
          }
        };
      });
    }

    // Get library metadata from localStorage
    function getLibraryMeta() {
      try {
        return JSON.parse(localStorage.getItem('libraryMeta') || '[]');
      } catch (e) {
        return [];
      }
    }

    // Save library metadata to localStorage
    function saveLibraryMeta(meta) {
      localStorage.setItem('libraryMeta', JSON.stringify(meta));
    }

    // Generate unique ID
    function generateId() {
      return Date.now().toString(36) + Math.random().toString(36).substr(2);
    }

    // Extract name from first sentence
    function extractName(text) {
      const cleaned = text.replace(/\s+/g, ' ').trim();
      const firstSentence = cleaned.split(/[.!?]/)[0];
      return firstSentence.substring(0, 50) + (firstSentence.length > 50 ? '...' : '');
    }

    // Save item to library
    async function saveToLibrary(text, pagesData = null) {
      if (!libraryDB) await openLibraryDB();
      
      const id = generateId();
      const name = extractName(text);
      const now = Date.now();
      
      // Save heavy data to IndexedDB
      const item = {
        id,
        text,
        pages: pagesData,
        createdAt: now
      };
      
      await new Promise((resolve, reject) => {
        const tx = libraryDB.transaction('items', 'readwrite');
        const store = tx.objectStore('items');
        const request = store.put(item);
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
      
      // Save metadata to localStorage
      const meta = getLibraryMeta();
      meta.unshift({
        id,
        name,
        lastAccess: now,
        createdAt: now,
        currentIndex: 0,
        currentPage: 0,
        hasPages: !!pagesData,
        totalPages: pagesData ? pagesData.length : 1
      });
      saveLibraryMeta(meta);
      
      renderLibrary();
      return id;
    }

    // Update library item access time and position
    function updateLibraryItem(id, updates) {
      const meta = getLibraryMeta();
      const idx = meta.findIndex(m => m.id === id);
      if (idx >= 0) {
        Object.assign(meta[idx], updates, { lastAccess: Date.now() });
        // Move to top (most recent)
        const item = meta.splice(idx, 1)[0];
        meta.unshift(item);
        saveLibraryMeta(meta);
      }
    }

    // Load item from library
    async function loadFromLibrary(id) {
      if (!libraryDB) await openLibraryDB();
      
      const item = await new Promise((resolve, reject) => {
        const tx = libraryDB.transaction('items', 'readonly');
        const store = tx.objectStore('items');
        const request = store.get(id);
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
      
      if (!item) return null;
      
      const meta = getLibraryMeta().find(m => m.id === id);
      updateLibraryItem(id, {});
      
      return { ...item, meta };
    }

    // Delete item from library
    async function deleteFromLibrary(id) {
      if (!libraryDB) await openLibraryDB();
      
      // Delete from IndexedDB
      await new Promise((resolve, reject) => {
        const tx = libraryDB.transaction('items', 'readwrite');
        const store = tx.objectStore('items');
        const request = store.delete(id);
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
      
      // Delete from metadata
      const meta = getLibraryMeta().filter(m => m.id !== id);
      saveLibraryMeta(meta);
      
      // Also update cached list
      if (cachedLibraryList) {
        cachedLibraryList = cachedLibraryList.filter(m => m.id !== id);
      }
      
      renderLibrary();
    }

    // Rename library item
    function renameLibraryItem(id, newName) {
      const meta = getLibraryMeta();
      const item = meta.find(m => m.id === id);
      if (item) {
        item.name = newName;
        saveLibraryMeta(meta);
      }
    }

    // Current active library item
    let currentLibraryId = null;
    let cachedLibraryList = null;

    // Render library sidebar
    function renderLibrary() {
      const list = document.getElementById('libraryList');
      // Use cached list if available (keeps order stable while browsing)
      if (!cachedLibraryList) {
        cachedLibraryList = getLibraryMeta();
      }
      const meta = cachedLibraryList;
      
      if (meta.length === 0) {
        list.innerHTML = '<div class="library-empty">אין פריטים בספרייה</div>';
        return;
      }
      
      list.innerHTML = meta.map(item => {
        const date = new Date(item.lastAccess).toLocaleDateString('he-IL');
        const activeClass = item.id === currentLibraryId ? 'active' : '';
        const pageInfo = item.hasPages ? ` • עמוד ${(item.currentPage || 0) + 1}/${item.totalPages || '?'}` : '';
        return `
          <div class="library-item ${activeClass}" data-id="${item.id}">
            <div class="library-item-content">
              <div class="library-item-name">${item.name}</div>
              <div class="library-item-meta">${date}${pageInfo}</div>
            </div>
            <button class="library-item-rename" title="שנה שם">✏️</button>
            <button class="library-item-delete" title="מחק">🗑️</button>
          </div>
        `;
      }).join('');
      
      // Add event listeners
      list.querySelectorAll('.library-item').forEach(el => {
        const id = el.dataset.id;
        
        // Click to load
        el.addEventListener('click', async (e) => {
          if (e.target.classList.contains('library-item-delete')) return;
          if (e.target.classList.contains('library-item-name') && 
              e.target.contentEditable === 'true') return;
          
          const item = await loadFromLibrary(id);
          if (item) {
            currentLibraryId = id;
            
            // Load the text/pages
            if (item.pages && item.pages.length > 0) {
              pages = item.pages;
              hasPages = true;
              currentPage = item.meta?.currentPage || 0;
              initCurrentPage().then(() => {
                currentIndex = item.meta?.currentIndex || 0;
                renderText();
                updateWordProgress();
              });
              document.getElementById('inputArea').style.display = 'none';
              document.getElementById('textDisplay').style.display = 'block';
              updatePageNav();
            } else {
              document.getElementById('textInput').value = item.text;
              dirtyText = item.text;
              cleanTextAsync(item.text).then(clean => {
                cleanedText = clean;
                initPacerAsync(useCleanText ? cleanedText : dirtyText).then(() => {
                  currentIndex = item.meta?.currentIndex || 0;
                  renderText();
                  updateWordProgress();
                });
              });
            }
            
            renderLibrary();
          }
        });
        
        // Double-click to rename
        const nameEl = el.querySelector('.library-item-name');
        nameEl.addEventListener('dblclick', (e) => {
          e.stopPropagation();
          nameEl.contentEditable = 'true';
          nameEl.focus();
          
          // Select all text
          const range = document.createRange();
          range.selectNodeContents(nameEl);
          const sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(range);
        });
        
        nameEl.addEventListener('blur', () => {
          nameEl.contentEditable = 'false';
          renameLibraryItem(id, nameEl.textContent.trim());
        });
        
        nameEl.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            nameEl.blur();
          }
          if (e.key === 'Escape') {
            nameEl.contentEditable = 'false';
            renderLibrary(); // Restore original name
          }
        });
        
        // Rename button
        el.querySelector('.library-item-rename').addEventListener('click', (e) => {
          e.stopPropagation();
          nameEl.contentEditable = 'true';
          nameEl.focus();
          const range = document.createRange();
          range.selectNodeContents(nameEl);
          const sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(range);
        });

        // Delete button
        el.querySelector('.library-item-delete').addEventListener('click', (e) => {
          e.stopPropagation();
          if (confirm('למחוק את הפריט מהספרייה?')) {
            deleteFromLibrary(id);
            if (currentLibraryId === id) currentLibraryId = null;
          }
        });
      });
    }

    // Toggle library sidebar
    function toggleLibrary() {
      const sidebar = document.getElementById('librarySidebar');
      if (sidebar.classList.contains('open')) {
        closeLibrary();
      } else {
        openLibrary();
      }
    }

    function openLibrary() {
      document.getElementById('librarySidebar').classList.add('open');
      document.getElementById('libraryOverlay').classList.add('open');
      cachedLibraryList = null; // Force refresh on open
      renderLibrary();
    }

    function closeLibrary() {
      document.getElementById('librarySidebar').classList.remove('open');
      document.getElementById('libraryOverlay').classList.remove('open');
    }

    // Library button handlers
    document.getElementById('libraryBtn').addEventListener('click', toggleLibrary);
    document.getElementById('libraryClose').addEventListener('click', closeLibrary);
    document.getElementById('libraryOverlay').addEventListener('click', closeLibrary);

    // Save current position periodically
    setInterval(() => {
      if (currentLibraryId && words.length > 0) {
        updateLibraryItem(currentLibraryId, {
          currentIndex,
          currentPage: hasPages ? currentPage : 0
        });
      }
    }, 5000);

    // Initialize library DB on load
    openLibraryDB().then(() => {
      log('Library DB initialized');
      renderLibrary();
    });

    // ==================== END LIBRARY SYSTEM ====================


    // Load visual settings on startup
    loadVisualSettings();

    // Restore opacity values from localStorage and apply colors
    const savedReadOpacity = localStorage.getItem('reading-pacer-highlight-read-opacity');
    const savedCurrentOpacity = localStorage.getItem('reading-pacer-highlight-current-opacity');
    const savedHalfBoldOpacity = localStorage.getItem('reading-pacer-halfbold-opacity');

    if (savedReadOpacity !== null) {
      document.getElementById('highlightReadOpacity').value = savedReadOpacity;
      document.getElementById('highlightReadOpacityValue').textContent = savedReadOpacity + '%';
    }
    if (savedCurrentOpacity !== null) {
      document.getElementById('highlightCurrentOpacity').value = savedCurrentOpacity;
      document.getElementById('highlightCurrentOpacityValue').textContent = savedCurrentOpacity + '%';
    }
    if (savedHalfBoldOpacity !== null) {
      document.getElementById('halfBoldColorOpacity').value = savedHalfBoldOpacity;
      document.getElementById('halfBoldColorOpacityValue').textContent = savedHalfBoldOpacity + '%';
    }

    // Restore half-bold font size
    const savedHalfBoldFontSize = localStorage.getItem('reading-pacer-halfbold-fontsize');
    if (savedHalfBoldFontSize !== null) {
      document.getElementById('halfBoldFontSize').value = savedHalfBoldFontSize;
      document.getElementById('halfBoldFontSizeValue').textContent = savedHalfBoldFontSize + '%';
      document.documentElement.style.setProperty('--half-bold-font-size', savedHalfBoldFontSize + '%');
    }

    // Apply highlight colors with opacity
    applyHighlightColors();
    applyHalfBoldColor();

    // Sync JS variables from input values (respects browser cache)
    chunkSize = parseInt(document.getElementById('chunkSizeInput').value) || 1;
    wpm = parseInt(document.getElementById('wpmInput').value) || 200;
    // scrollTolerance restored from localStorage
    document.getElementById('chunkSize').value = chunkSize;
    document.getElementById('wpm').value = wpm;

    // Save state to localStorage
    function saveState() {
      const state = {
        text: document.getElementById('textInput').value,
        currentPage: currentPage,
        currentIndex: currentIndex,
        currentSentence: currentSentence,
        useCleanText: useCleanText,
        sentenceMode: sentenceMode
      };
      localStorage.setItem('reading-pacer-state', JSON.stringify(state));
    }

    // Restore state from localStorage
    async function restoreState() {
      const saved = localStorage.getItem('reading-pacer-state');
      if (!saved) {
        loadSampleText();
        return;
      }

      try {
        const state = JSON.parse(saved);
        if (!state.text || state.text.trim().length === 0) {
          loadSampleText();
          return;
        }

        showLoading('טוען מסמך קודם...');

        document.getElementById('textInput').value = state.text;
        useCleanText = state.useCleanText !== undefined ? state.useCleanText : true;
        sentenceMode = state.sentenceMode || false;

        hasPages = state.text.includes('\f');

        if (hasPages) {
          await loadPagesAsync(state.text);
          if (state.currentPage !== undefined && state.currentPage < pages.length) {
            currentPage = state.currentPage;
            await initCurrentPage();
            updatePageNav();
          }
        } else {
          dirtyText = state.text;
          cleanedText = await cleanTextAsync(state.text);
          await initPacerAsync(useCleanText ? cleanedText : dirtyText);
        }

        // Restore position
        if (state.currentIndex !== undefined) {
          currentIndex = Math.min(state.currentIndex, words.length - 1);
        }
        if (state.currentSentence !== undefined) {
          currentSentence = Math.min(state.currentSentence, sentences.length - 1);
        }

        renderText();
        updateWordProgress();
        hideLoading();
        log('State restored from localStorage');
      } catch (e) {
        log('Failed to restore state: ' + e.message, 'e');
        hideLoading();
        loadSampleText();
      }
    }

    // Save state on navigation + play sounds
    const originalNextChunk = nextChunk;
    nextChunk = function() {
      const prevPage = currentPage;
      originalNextChunk();
      saveState();
      playWordSound();
      speakChunk();
    };

    const originalPrevChunk = prevChunk;
    prevChunk = function() {
      originalPrevChunk();
      saveState();
      playWordSound();
      speakChunk();
    };

    const originalGoToPage = goToPage;
    goToPage = function(pageIdx, keepAutoAdvance) {
      originalGoToPage(pageIdx, keepAutoAdvance);
      saveState();
    };

    const originalSetPosition = setPosition;
    setPosition = function(idx) {
      originalSetPosition(idx);
      saveState();
      playWordSound();
      speakChunk();
    };

    // ============================================
    // FIGURES PANEL FUNCTIONALITY
    // ============================================

    let figureImages = [];  // Array of image URLs/paths per page
    let figuresLoaded = false;
    let currentFigurePage = 0;
    let pendingPdfFile = null;  // Store PDF for image extraction after text loads

    // Toggle figures panel
    document.getElementById('figuresBtn').addEventListener('click', () => {
      const panel = document.getElementById('figuresPanel');
      const progressBar = document.getElementById('progressBar');
      panel.classList.toggle('open');
      document.body.classList.toggle('figures-panel-open', panel.classList.contains('open'));
      if (progressBar) progressBar.classList.toggle('figures-open', panel.classList.contains('open'));
      localStorage.setItem('reading-pacer-panel-open', panel.classList.contains('open'));
      if (panel.classList.contains('open') && figuresLoaded) {
        updateFiguresDisplay();
      }
    });

    function closeFiguresPanel() {
      document.getElementById('figuresPanel').classList.remove('open');
      document.body.classList.remove('figures-panel-open');
      const progressBar = document.getElementById('progressBar');
      if (progressBar) progressBar.classList.remove('figures-open');
      localStorage.setItem('reading-pacer-panel-open', 'false');
    }

    // Restore panel state
    function restorePanelState() {
      const wasOpen = localStorage.getItem('reading-pacer-panel-open') === 'true';
      if (wasOpen) {
        document.getElementById('figuresPanel').classList.add('open');
        document.body.classList.add('figures-panel-open');
        const progressBar = document.getElementById('progressBar');
        if (progressBar) progressBar.classList.add('figures-open');
      }
    }

    // Convert file to base64 data URL
    function fileToDataURL(file) {
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => resolve(null);
        reader.readAsDataURL(file);
      });
    }

    // Extract page images from PDF using PDF.js (images only, not text)
    async function extractPdfPageImages(file) {
      log('extractPdfPageImages starting', 'i');
      showLoading('מחלץ עמודים מ-PDF...');

      try {
        // Set PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // Read file as ArrayBuffer
        const arrayBuffer = await file.arrayBuffer();
        log('PDF loaded into memory', 'i');

        // Load the PDF document
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        const numPages = pdf.numPages;
        log(`PDF has ${numPages} pages`, 'i');

        // Render pages to images
        figureImages = [];
        const scale = 1.5; // Render at 1.5x for decent quality

        for (let pageNum = 1; pageNum <= numPages; pageNum++) {
          showLoading(`מחלץ עמוד ${pageNum}/${numPages}...`);
          const page = await pdf.getPage(pageNum);

          // Render page to canvas
          const viewport = page.getViewport({ scale });
          const canvas = document.createElement('canvas');
          canvas.width = viewport.width;
          canvas.height = viewport.height;
          const ctx = canvas.getContext('2d');

          await page.render({
            canvasContext: ctx,
            viewport: viewport
          }).promise;

          // Convert to data URL
          const dataUrl = canvas.toDataURL('image/jpeg', 0.8);
          figureImages.push({
            url: dataUrl,
            name: `page-${String(pageNum).padStart(2, '0')}.jpg`
          });

          log(`Page ${pageNum} rendered`, 'i');
        }

        // Setup figures
        figuresLoaded = figureImages.length > 0;
        if (figuresLoaded) {
          currentFigurePage = 0;
          updateFiguresDisplay();
          await saveFigures();

          // Open figures panel
          const panel = document.getElementById('figuresPanel');
          if (panel && !panel.classList.contains('open')) {
            panel.classList.add('open');
            document.body.classList.add('figures-panel-open');
            localStorage.setItem('reading-pacer-panel-open', 'true');
          }
        }

        hideLoading();
        log(`PDF page images extracted: ${figureImages.length} pages`, 'i');

      } catch (e) {
        hideLoading();
        log(`PDF image extraction error: ${e.message}`, 'e');
        alert('שגיאה בחילוץ עמודים מה-PDF: ' + e.message);
      }
    }

    // Load figures from dropped folder or file input
    async function loadFiguresFromFiles(files) {
      log(`loadFiguresFromFiles called with ${files.length} files`, 'i');

      figureImages = [];
      const imageFiles = Array.from(files).filter(f => {
        const isImage = f.type.startsWith('image/') || /\.(png|jpg|jpeg|gif|webp)$/i.test(f.name);
        return isImage;
      });

      log(`Filtered to ${imageFiles.length} image files`, 'i');

      // Sort by filename (expecting page-01.png, page-02.png, etc.)
      imageFiles.sort((a, b) => a.name.localeCompare(b.name, undefined, {numeric: true}));

      // Convert to base64 for persistence
      for (let idx = 0; idx < imageFiles.length; idx++) {
        const file = imageFiles[idx];
        const dataUrl = await fileToDataURL(file);
        if (dataUrl) {
          figureImages[idx] = {
            url: dataUrl,
            name: file.name
          };
        }
      }

      figuresLoaded = figureImages.length > 0;
      log(`figuresLoaded = ${figuresLoaded}, count = ${figureImages.length}`, 'i');

      if (figuresLoaded) {
        // Clamp to valid range
        const textPage = typeof currentPage !== 'undefined' ? currentPage : 0;
        currentFigurePage = Math.min(textPage, figureImages.length - 1);
        currentFigurePage = Math.max(0, currentFigurePage);
        updateFiguresDisplay();
        saveFigures();
      } else {
        log('No images loaded!', 'w');
      }
    }

    // IndexedDB for large figure storage
    const DB_NAME = 'reading-pacer-db';
    const DB_VERSION = 1;
    const STORE_NAME = 'figures';

    function openDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            db.createObjectStore(STORE_NAME);
          }
        };
      });
    }

    // Save figures to IndexedDB
    async function saveFigures() {
      if (!figuresLoaded || figureImages.length === 0) return;
      try {
        const db = await openDB();
        const tx = db.transaction(STORE_NAME, 'readwrite');
        const store = tx.objectStore(STORE_NAME);
        store.put(figureImages, 'pages');
        await new Promise((resolve, reject) => {
          tx.oncomplete = resolve;
          tx.onerror = () => reject(tx.error);
        });
        db.close();
        log(`Saved ${figureImages.length} figures to IndexedDB`, 'i');
      } catch (e) {
        log(`Failed to save figures: ${e.message}`, 'e');
      }
    }

    // Restore figures from IndexedDB
    async function restoreFigures() {
      try {
        const db = await openDB();
        const tx = db.transaction(STORE_NAME, 'readonly');
        const store = tx.objectStore(STORE_NAME);
        const request = store.get('pages');

        const saved = await new Promise((resolve, reject) => {
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        });
        db.close();

        if (!saved || !Array.isArray(saved)) return;

        figureImages = saved;
        figuresLoaded = figureImages.length > 0;

        if (figuresLoaded) {
          const textPage = typeof currentPage !== 'undefined' ? currentPage : 0;
          currentFigurePage = Math.min(textPage, figureImages.length - 1);
          currentFigurePage = Math.max(0, currentFigurePage);
          updateFiguresDisplay();
          log(`Restored ${figureImages.length} figures from IndexedDB`, 'i');
        }
      } catch (e) {
        log(`Failed to restore figures: ${e.message}`, 'e');
      }
    }

    // Update figures display - show all pages as thumbnails
    function updateFiguresDisplay() {
      log(`updateFiguresDisplay called`, 'i');
      const content = document.getElementById('figuresContent');

      if (!figuresLoaded || figureImages.length === 0) {
        content.innerHTML = `
          <div class="figures-placeholder">
            <p>גרור תיקיית תמונות</p>
          </div>`;
        return;
      }

      // Build thumbnails for all pages
      let html = '';
      figureImages.forEach((fig, idx) => {
        const isActive = idx === currentFigurePage ? 'active' : '';
        html += `
          <div class="page-thumb ${isActive}" data-page="${idx}" onclick="goToPageFromThumb(${idx})" ondblclick="openLightbox('${fig.url}')">
            <img src="${fig.url}" alt="Page ${idx + 1}">
            <span class="page-thumb-label">${idx + 1}</span>
          </div>`;
      });

      content.innerHTML = html;
      log(`  Rendered ${figureImages.length} thumbnails`, 'i');

      // Position current page as second from top
      setTimeout(() => {
        updateActiveThumb();
      }, 50);
    }

    // Update just the active state without rebuilding
    function updateActiveThumb() {
      const thumbs = document.querySelectorAll('.page-thumb');
      const content = document.getElementById('figuresContent');

      thumbs.forEach((thumb, idx) => {
        thumb.classList.toggle('active', idx === currentFigurePage);
      });

      // Position: previous page at top, current page second
      if (currentFigurePage > 0 && thumbs.length > 1) {
        const prevThumb = thumbs[currentFigurePage - 1];
        if (prevThumb) {
          // Scroll so previous page is at the very top
          content.scrollTo({
            top: prevThumb.offsetTop - content.offsetTop,
            behavior: 'smooth'
          });
        }
      } else {
        // First page - just scroll to top
        content.scrollTo({ top: 0, behavior: 'smooth' });
      }
    }

    // Click thumbnail to navigate
    function goToPageFromThumb(pageIdx) {
      if (typeof goToPage === 'function' && hasPages) {
        goToPage(pageIdx);
      }
      currentFigurePage = pageIdx;
      updateActiveThumb();
    }

    // Lightbox with zoom/pan
    let lbZoom = 1;
    let lbPanX = 0;
    let lbPanY = 0;
    let lbDragging = false;
    let lbLastX = 0;
    let lbLastY = 0;

    function openLightbox(src) {
      const lightbox = document.getElementById('figureLightbox');
      const img = document.getElementById('lightboxImg');
      img.src = src;
      lbZoom = 1;
      lbPanX = 0;
      lbPanY = 0;
      updateLightboxTransform();
      lightbox.classList.add('active');
      lightbox.classList.remove('zoomed');
    }

    function closeLightbox() {
      const lightbox = document.getElementById('figureLightbox');
      lightbox.classList.remove('active', 'zoomed', 'dragging');
      lbZoom = 1;
      lbPanX = 0;
      lbPanY = 0;
    }

    function updateLightboxTransform() {
      const img = document.getElementById('lightboxImg');
      img.style.transform = `translate(${lbPanX}px, ${lbPanY}px) scale(${lbZoom})`;
    }

    // Zoom with scroll wheel
    document.getElementById('figureLightbox').addEventListener('wheel', (e) => {
      e.preventDefault();
      const lightbox = document.getElementById('figureLightbox');
      const img = document.getElementById('lightboxImg');
      const rect = img.getBoundingClientRect();

      // Mouse position relative to image center
      const imgCenterX = rect.left + rect.width / 2;
      const imgCenterY = rect.top + rect.height / 2;
      const mouseX = e.clientX - imgCenterX;
      const mouseY = e.clientY - imgCenterY;

      // Zoom factor
      const delta = e.deltaY > 0 ? 0.9 : 1.1;
      const newZoom = Math.max(0.5, Math.min(10, lbZoom * delta));

      // Adjust pan to zoom toward cursor
      const zoomRatio = newZoom / lbZoom;
      lbPanX = mouseX - (mouseX - lbPanX) * zoomRatio;
      lbPanY = mouseY - (mouseY - lbPanY) * zoomRatio;

      lbZoom = newZoom;
      lightbox.classList.toggle('zoomed', lbZoom > 1.05);
      updateLightboxTransform();
    }, { passive: false });

    // Pan with mouse drag
    document.getElementById('figureLightbox').addEventListener('mousedown', (e) => {
      if (lbZoom > 1.05) {
        lbDragging = true;
        lbLastX = e.clientX;
        lbLastY = e.clientY;
        document.getElementById('figureLightbox').classList.add('dragging');
        e.preventDefault();
      }
    });

    document.addEventListener('mousemove', (e) => {
      if (lbDragging) {
        lbPanX += e.clientX - lbLastX;
        lbPanY += e.clientY - lbLastY;
        lbLastX = e.clientX;
        lbLastY = e.clientY;
        updateLightboxTransform();
      }
    });

    document.addEventListener('mouseup', () => {
      if (lbDragging) {
        lbDragging = false;
        document.getElementById('figureLightbox').classList.remove('dragging');
      }
    });

    // Click to close only if not zoomed
    document.getElementById('figureLightbox').addEventListener('click', (e) => {
      if (lbZoom <= 1.05 && e.target.id === 'figureLightbox') {
        closeLightbox();
      }
    });

    // Double-click to reset zoom or close
    document.getElementById('figureLightbox').addEventListener('dblclick', () => {
      if (lbZoom > 1.05) {
        lbZoom = 1;
        lbPanX = 0;
        lbPanY = 0;
        updateLightboxTransform();
        document.getElementById('figureLightbox').classList.remove('zoomed');
      } else {
        closeLightbox();
      }
    });

    // Close lightbox on Escape, cancel TTS loading
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Escape') {
        closeLightbox();
        closeFiguresPanel();
        // Cancel TTS loading
        if (ttsGenerating) {
          ttsCancelled = true;
          ttsGenerating = false;
          hideLoading();
          document.getElementById('ttsLoadBtn').disabled = false;
          document.getElementById('ttsLoadBtn').textContent = 'טען';
          log('[TTS] Generation cancelled', 'w');
        }
      }
    });

    // Drag & drop for figures panel
    const figuresContentEl = document.getElementById('figuresContent');
    let dragCounter = 0;

    figuresContentEl.addEventListener('dragenter', (e) => {
      e.preventDefault();
      e.stopPropagation();
      dragCounter++;
      figuresContentEl.classList.add('drag-over');
      log('Figures drag enter', 'i');
    });

    figuresContentEl.addEventListener('dragleave', (e) => {
      e.preventDefault();
      e.stopPropagation();
      dragCounter--;
      if (dragCounter === 0) {
        figuresContentEl.classList.remove('drag-over');
      }
    });

    figuresContentEl.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.stopPropagation();
      e.dataTransfer.dropEffect = 'copy';
    });

    figuresContentEl.addEventListener('drop', (e) => {
      e.preventDefault();
      e.stopPropagation();
      dragCounter = 0;
      figuresContentEl.classList.remove('drag-over');
      log('Figures drop event', 'i');

      // Handle dropped files or folder
      const items = e.dataTransfer.items;
      const droppedFiles = e.dataTransfer.files;

      // Try webkitGetAsEntry for folder support
      if (items && items.length > 0 && items[0].webkitGetAsEntry) {
        const files = [];
        const processEntry = (entry) => {
          return new Promise((resolve) => {
            if (entry.isFile) {
              entry.file(f => {
                files.push(f);
                resolve();
              }, () => resolve());
            } else if (entry.isDirectory) {
              const reader = entry.createReader();
              const readEntries = () => {
                reader.readEntries(async (entries) => {
                  if (entries.length === 0) {
                    resolve();
                  } else {
                    for (const ent of entries) {
                      await processEntry(ent);
                    }
                    readEntries(); // Continue reading (folders can have >100 entries)
                  }
                }, () => resolve());
              };
              readEntries();
            } else {
              resolve();
            }
          });
        };

        const promises = [];
        for (let i = 0; i < items.length; i++) {
          const entry = items[i].webkitGetAsEntry();
          if (entry) {
            promises.push(processEntry(entry));
          }
        }

        Promise.all(promises).then(() => {
          log(`Processed ${files.length} files from drop`, 'i');
          if (files.length > 0) {
            loadFiguresFromFiles(files);
          }
        });
      } else if (droppedFiles && droppedFiles.length > 0) {
        // Fallback: direct file drop (no folder support)
        log(`Fallback: ${droppedFiles.length} files dropped`, 'i');
        loadFiguresFromFiles(droppedFiles);
      }
    });

    // Sync figures with page changes
    const originalGoToPageForFigures = goToPage;
    goToPage = function(pageIdx, keepAutoAdvance) {
      originalGoToPageForFigures(pageIdx, keepAutoAdvance);
      if (figuresLoaded) {
        currentFigurePage = Math.min(pageIdx, figureImages.length - 1);
        if (document.getElementById('figuresPanel').classList.contains('open')) {
          updateActiveThumb();
        }
      }
    };

    // Restore state on load instead of sample text
    restoreState();

    // Init progress bar drag
    initProgressBarDrag();

    // Restore panel state and figures
    restorePanelState();
    setTimeout(restoreFigures, 100);
  </script>
</body>
</html>

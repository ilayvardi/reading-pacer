<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Reading Pacer</title>
  <!-- PDF.js for browser-based PDF processing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <style>
    * { box-sizing: border-box; }

    :root {
      /* Default: Sweet Mars */
      --bg-primary: #1a1a2e;
      --bg-secondary: #252540;
      --bg-tertiary: #151525;
      --text-primary: #eee;
      --text-secondary: #aaa;
      --text-muted: #888;
      --accent: #0a84ff;
      --accent-hover: #0070e0;
      --border: #3a3a5c;
      --btn-bg: #3a3a5c;
      --btn-hover: #4a4a6c;
      --highlight-read: rgba(100, 200, 100, 0.25);
      --highlight-current: rgba(255, 200, 0, 0.5);
      --highlight-current-border: rgba(255, 180, 0, 0.8);
    }

    /* Catppuccin Mocha */
    .theme-catppuccin {
      --bg-primary: #1e1e2e;
      --bg-secondary: #313244;
      --bg-tertiary: #181825;
      --text-primary: #cdd6f4;
      --text-secondary: #bac2de;
      --text-muted: #6c7086;
      --accent: #89b4fa;
      --accent-hover: #74a8f7;
      --border: #45475a;
      --btn-bg: #45475a;
      --btn-hover: #585b70;
      --highlight-read: rgba(166, 227, 161, 0.25);
      --highlight-current: rgba(249, 226, 175, 0.5);
      --highlight-current-border: rgba(249, 226, 175, 0.8);
    }

    /* Dracula */
    .theme-dracula {
      --bg-primary: #282a36;
      --bg-secondary: #44475a;
      --bg-tertiary: #21222c;
      --text-primary: #f8f8f2;
      --text-secondary: #d4d4d4;
      --text-muted: #6272a4;
      --accent: #bd93f9;
      --accent-hover: #a77bf3;
      --border: #44475a;
      --btn-bg: #44475a;
      --btn-hover: #6272a4;
      --highlight-read: rgba(80, 250, 123, 0.25);
      --highlight-current: rgba(255, 121, 198, 0.4);
      --highlight-current-border: rgba(255, 121, 198, 0.8);
    }

    /* Nord */
    .theme-nord {
      --bg-primary: #2e3440;
      --bg-secondary: #3b4252;
      --bg-tertiary: #272c36;
      --text-primary: #eceff4;
      --text-secondary: #d8dee9;
      --text-muted: #4c566a;
      --accent: #88c0d0;
      --accent-hover: #8fbcbb;
      --border: #4c566a;
      --btn-bg: #4c566a;
      --btn-hover: #5e6779;
      --highlight-read: rgba(163, 190, 140, 0.25);
      --highlight-current: rgba(235, 203, 139, 0.4);
      --highlight-current-border: rgba(235, 203, 139, 0.8);
    }

    /* Gruvbox Dark */
    .theme-gruvbox {
      --bg-primary: #282828;
      --bg-secondary: #3c3836;
      --bg-tertiary: #1d2021;
      --text-primary: #ebdbb2;
      --text-secondary: #d5c4a1;
      --text-muted: #665c54;
      --accent: #fe8019;
      --accent-hover: #d65d0e;
      --border: #504945;
      --btn-bg: #504945;
      --btn-hover: #665c54;
      --highlight-read: rgba(184, 187, 38, 0.25);
      --highlight-current: rgba(250, 189, 47, 0.4);
      --highlight-current-border: rgba(250, 189, 47, 0.8);
    }

    /* Tokyo Night */
    .theme-tokyo {
      --bg-primary: #1a1b26;
      --bg-secondary: #24283b;
      --bg-tertiary: #16161e;
      --text-primary: #c0caf5;
      --text-secondary: #a9b1d6;
      --text-muted: #565f89;
      --accent: #7aa2f7;
      --accent-hover: #5d87e8;
      --border: #3b4261;
      --btn-bg: #3b4261;
      --btn-hover: #4a5274;
      --highlight-read: rgba(158, 206, 106, 0.25);
      --highlight-current: rgba(224, 175, 104, 0.4);
      --highlight-current-border: rgba(224, 175, 104, 0.8);
    }

    /* Solarized Dark */
    .theme-solarized {
      --bg-primary: #002b36;
      --bg-secondary: #073642;
      --bg-tertiary: #00212b;
      --text-primary: #93a1a1;
      --text-secondary: #839496;
      --text-muted: #586e75;
      --accent: #268bd2;
      --accent-hover: #1a6fa3;
      --border: #094959;
      --btn-bg: #094959;
      --btn-hover: #0a5a6b;
      --highlight-read: rgba(133, 153, 0, 0.3);
      --highlight-current: rgba(181, 137, 0, 0.4);
      --highlight-current-border: rgba(181, 137, 0, 0.8);
    }

    /* ===== LIGHT THEMES ===== */

    /* Classic Light */
    .theme-light {
      --bg-primary: #ffffff;
      --bg-secondary: #f5f5f5;
      --bg-tertiary: #e8e8e8;
      --text-primary: #1a1a1a;
      --text-secondary: #4a4a4a;
      --text-muted: #888888;
      --accent: #0066cc;
      --accent-hover: #0052a3;
      --border: #d0d0d0;
      --btn-bg: #e0e0e0;
      --btn-hover: #d0d0d0;
      --highlight-read: rgba(100, 180, 100, 0.2);
      --highlight-current: rgba(255, 200, 50, 0.5);
      --highlight-current-border: rgba(230, 160, 0, 0.8);
    }

    /* Solarized Light */
    .theme-solarized-light {
      --bg-primary: #fdf6e3;
      --bg-secondary: #eee8d5;
      --bg-tertiary: #f5efdc;
      --text-primary: #657b83;
      --text-secondary: #586e75;
      --text-muted: #93a1a1;
      --accent: #268bd2;
      --accent-hover: #1a6fa3;
      --border: #d3cbb7;
      --btn-bg: #eee8d5;
      --btn-hover: #ddd6c3;
      --highlight-read: rgba(133, 153, 0, 0.2);
      --highlight-current: rgba(181, 137, 0, 0.35);
      --highlight-current-border: rgba(181, 137, 0, 0.7);
    }

    /* GitHub Light */
    .theme-github-light {
      --bg-primary: #ffffff;
      --bg-secondary: #f6f8fa;
      --bg-tertiary: #eaeef2;
      --text-primary: #24292f;
      --text-secondary: #57606a;
      --text-muted: #8b949e;
      --accent: #0969da;
      --accent-hover: #0550ae;
      --border: #d0d7de;
      --btn-bg: #f3f4f6;
      --btn-hover: #e5e7eb;
      --highlight-read: rgba(46, 160, 67, 0.2);
      --highlight-current: rgba(255, 200, 50, 0.45);
      --highlight-current-border: rgba(210, 150, 0, 0.8);
    }

    /* ===== DARK THEMES ===== */

    /* Pure Dark (OLED) */
    .theme-pure-dark {
      --bg-primary: #000000;
      --bg-secondary: #0d0d0d;
      --bg-tertiary: #000000;
      --text-primary: #e0e0e0;
      --text-secondary: #b0b0b0;
      --text-muted: #666666;
      --accent: #6eb5ff;
      --accent-hover: #4a9eff;
      --border: #222222;
      --btn-bg: #1a1a1a;
      --btn-hover: #2a2a2a;
      --highlight-read: rgba(100, 200, 100, 0.2);
      --highlight-current: rgba(255, 200, 0, 0.4);
      --highlight-current-border: rgba(255, 180, 0, 0.7);
    }

    /* One Dark */
    .theme-one-dark {
      --bg-primary: #282c34;
      --bg-secondary: #21252b;
      --bg-tertiary: #1e2227;
      --text-primary: #abb2bf;
      --text-secondary: #9da5b4;
      --text-muted: #636d83;
      --accent: #61afef;
      --accent-hover: #4d9fe0;
      --border: #3e4451;
      --btn-bg: #3e4451;
      --btn-hover: #4d5566;
      --highlight-read: rgba(152, 195, 121, 0.25);
      --highlight-current: rgba(229, 192, 123, 0.4);
      --highlight-current-border: rgba(229, 192, 123, 0.8);
    }

    /* Monokai Pro */
    .theme-monokai {
      --bg-primary: #2d2a2e;
      --bg-secondary: #403e41;
      --bg-tertiary: #221f22;
      --text-primary: #fcfcfa;
      --text-secondary: #c1c0c0;
      --text-muted: #727072;
      --accent: #ffd866;
      --accent-hover: #e6c25a;
      --border: #525053;
      --btn-bg: #403e41;
      --btn-hover: #525053;
      --highlight-read: rgba(169, 220, 118, 0.25);
      --highlight-current: rgba(255, 216, 102, 0.4);
      --highlight-current-border: rgba(255, 216, 102, 0.8);
    }

    /* Ayu Dark */
    .theme-ayu {
      --bg-primary: #0b0e14;
      --bg-secondary: #1f2430;
      --bg-tertiary: #0d1017;
      --text-primary: #bfbdb6;
      --text-secondary: #9c9a93;
      --text-muted: #565b66;
      --accent: #e6b450;
      --accent-hover: #d4a43e;
      --border: #2d3640;
      --btn-bg: #1f2430;
      --btn-hover: #2d3640;
      --highlight-read: rgba(170, 217, 76, 0.2);
      --highlight-current: rgba(230, 180, 80, 0.4);
      --highlight-current-border: rgba(230, 180, 80, 0.8);
    }

    /* Palenight */
    .theme-palenight {
      --bg-primary: #292d3e;
      --bg-secondary: #343b51;
      --bg-tertiary: #232635;
      --text-primary: #a6accd;
      --text-secondary: #959dcb;
      --text-muted: #676e95;
      --accent: #82aaff;
      --accent-hover: #6699ff;
      --border: #444b6a;
      --btn-bg: #343b51;
      --btn-hover: #444b6a;
      --highlight-read: rgba(195, 232, 141, 0.2);
      --highlight-current: rgba(255, 203, 107, 0.4);
      --highlight-current-border: rgba(255, 203, 107, 0.8);
    }

    /* Ros√© Pine */
    .theme-rose-pine {
      --bg-primary: #191724;
      --bg-secondary: #1f1d2e;
      --bg-tertiary: #13111e;
      --text-primary: #e0def4;
      --text-secondary: #c4a7e7;
      --text-muted: #6e6a86;
      --accent: #ebbcba;
      --accent-hover: #e0a8a6;
      --border: #403d52;
      --btn-bg: #26233a;
      --btn-hover: #403d52;
      --highlight-read: rgba(156, 207, 216, 0.2);
      --highlight-current: rgba(246, 193, 119, 0.4);
      --highlight-current-border: rgba(246, 193, 119, 0.8);
    }

    /* Everforest Dark */
    .theme-everforest {
      --bg-primary: #2d353b;
      --bg-secondary: #3d484d;
      --bg-tertiary: #272e33;
      --text-primary: #d3c6aa;
      --text-secondary: #c5b992;
      --text-muted: #7a8478;
      --accent: #a7c080;
      --accent-hover: #93b571;
      --border: #4f5b58;
      --btn-bg: #3d484d;
      --btn-hover: #4f5b58;
      --highlight-read: rgba(167, 192, 128, 0.2);
      --highlight-current: rgba(219, 188, 127, 0.4);
      --highlight-current-border: rgba(219, 188, 127, 0.8);
    }

    /* Kanagawa */
    .theme-kanagawa {
      --bg-primary: #1f1f28;
      --bg-secondary: #2a2a37;
      --bg-tertiary: #16161d;
      --text-primary: #dcd7ba;
      --text-secondary: #c8c093;
      --text-muted: #727169;
      --accent: #7e9cd8;
      --accent-hover: #6a8bc9;
      --border: #3d3d50;
      --btn-bg: #2a2a37;
      --btn-hover: #3d3d50;
      --highlight-read: rgba(152, 187, 108, 0.2);
      --highlight-current: rgba(226, 194, 144, 0.4);
      --highlight-current-border: rgba(226, 194, 144, 0.8);
    }


    body {
      font-family: 'David', 'Noto Sans Hebrew', system-ui, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      margin: 0;
      padding: 20px;
      min-height: 100vh;
    }

    .container {
      max-width: 1400px;
      width: calc(100% - 80px);
      margin: 0 auto;
      transition: margin 0.3s ease;
    }

    h1 {
      text-align: center;
      color: var(--text-primary);
      margin-bottom: 20px;
    }

    /* Control Panel */
    .controls {
      background: var(--bg-secondary);
      padding: 16px 24px;
      border-radius: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      justify-content: center;
      margin-bottom: 20px;
      position: sticky;
      top: 10px;
      z-index: 100;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }

    button {
      background: var(--btn-bg);
      border: none;
      color: var(--text-primary);
      padding: 10px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 16px;
      transition: background 0.2s;
      user-select: none;
    }

    button:hover { background: var(--btn-hover); }
    button.active { background: var(--accent); }
    button.primary { background: var(--accent); }
    button.primary:hover { background: var(--accent-hover); }

    label {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--text-secondary);
    }

    input[type="number"], select {
      width: 70px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      color: var(--text-primary);
      padding: 8px;
      border-radius: 6px;
      font-size: 14px;
    }

    select {
      width: auto;
      cursor: pointer;
    }

    .progress {
      color: var(--text-muted);
      font-size: 14px;
      width: 200px;
      flex-shrink: 0;
      text-align: center;
      font-variant-numeric: tabular-nums;
    }

    .page-nav {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .page-nav select {
      width: auto;
      min-width: 100px;
    }

    .separator {
      color: var(--text-muted);
      margin: 0 4px;
    }

    /* Text Display */
    .text-display {
      background: transparent;
      padding: 15px 30px;
      padding-bottom: 220px; /* Space for bottom bar so end of page text stays visible */
      min-height: 400px;
      font-size: 22px;
      line-height: 2;
      direction: rtl;
      text-align: right;
    }

    .text-display.centered-block {
      max-width: 800px;
      margin: 0 auto;
    }

    .word {
      display: inline;
      cursor: pointer;
      padding: 0;
      margin: 0;
    }

    .word:hover {
      background: var(--btn-bg);
    }

    .highlight-read {
      background: var(--highlight-read);
      border-radius: 4px;
    }

    .highlight-current {
      background: var(--highlight-current);
      border-radius: 4px;
      box-shadow: 0 0 0 2px var(--highlight-current-border);
    }

    /* Half-bold mode (◊î◊ì◊í◊©◊™ ◊ó◊¶◊ô) - bold first letters instead of highlight for current chunk */
    .half-bold-mode .highlight-current {
      background: none;
      box-shadow: none;
    }
    .half-bold-prefix {
      font-weight: bold;
      color: var(--half-bold-color, inherit);
      font-size: var(--half-bold-font-size, 1em);
    }
    .half-bold-suffix {
      font-weight: normal;
    }

    /* Vertical Progress Bar */
    .progress-bar-container {
      position: fixed;
      right: 20px;
      top: 80px;
      bottom: 20%;
      width: 5px;
      background: var(--btn-bg);
      border-radius: 4px;
      opacity: 0;
      transition: opacity 0.3s ease, right 0.3s ease;
      z-index: 100;
    }
    .progress-bar-container.visible {
      opacity: 1;
    }
    /* Move left when figures panel is open */
    .progress-bar-container.figures-open {
      right: 1px;
    }
    .progress-bar-fill {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      background: var(--highlight-current-border);
      opacity: 0.5;
      border-radius: 4px;
      transition: height 0.2s ease;
    }
    .progress-bar-percent {
      position: absolute;
      left: 50%;
      transform: translateX(-50%) translateY(-50%);
      font-size: 11px;
      font-weight: bold;
      color: var(--text);
      background: var(--bg-secondary);
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.5);
      border: 2px solid var(--highlight-current-border);
      top: 0;
      transition: top 0.2s ease;
      cursor: grab;
      user-select: none;
    }
    .progress-bar-percent:active {
      cursor: grabbing;
    }
    .progress-bar-percent.dragging {
      transition: none;
    }

    /* Per-word pop animation (not in VN or sentence mode) */
    .text-display:not(.vn-mode):not(.sentence-mode) .word-pop {
      display: inline-block;
      transform-origin: center center;
      animation: word-pop var(--anim-speed, 0.15s) ease-out;
    }

    @keyframes word-pop {
      0% { transform: scale(1); opacity: 0; }
      50% { transform: scale(var(--pop-scale, 1.08)); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }

    /* VN Fade Mode - opacity based on sentence distance */
    .vn-mode .vn-fade-0 { opacity: 1; transition: opacity 0.5s ease; }
    .vn-mode .vn-fade-1 { opacity: 0.50; transition: opacity 0.5s ease; }
    .vn-mode .vn-fade-2 { opacity: 0.375; transition: opacity 0.5s ease; }
    .vn-mode .vn-fade-3 { opacity: 0.25; transition: opacity 0.5s ease; }
    .vn-mode .vn-fade-4 { opacity: 0.125; transition: opacity 0.5s ease; }
    .vn-mode .vn-fade-5 { opacity: 0; transition: opacity 0.5s ease; }
    .vn-mode .vn-fade-6 { opacity: 0; transition: opacity 0.5s ease; }
    .vn-mode .vn-fade-peek { opacity: 0.08; transition: opacity 0.5s ease; }

    /* VN Border - SVG overlay */
    #vnBorderSvg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1000;
    }
    #vnBorderPath {
      fill: none;
      stroke: var(--text-color, #e0e0e0);
      stroke-width: 2;
      stroke-linejoin: round;
      stroke-linecap: round;
      opacity: 0.6;
    }

    /* Current chunk fade-in animation */
    .vn-mode .vn-fade-in {
      animation: vnFadeIn 0.3s ease forwards;
    }

    @keyframes vnFadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .heading {
      font-weight: bold;
      text-decoration: underline;
      font-size: 1.3em;
    }

    .paragraph-break {
      display: block;
      height: var(--paragraph-spacing, 16px);
    }

    /* Top Bar */
    .top-bar {
      position: fixed;
      top: 0;
      left: 0;
      right: 1px;
      height: 50px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 16px;
      z-index: 1000;
    }

    .top-bar-left,
    .top-bar-right {
      display: flex;
      gap: 8px;
    }

    .top-bar-title {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      margin: 0;
      font-size: 22px;
      font-weight: 600;
      color: var(--text-primary);
      letter-spacing: 1px;
    }

    .top-btn {
      background: transparent;
      border: none;
      font-size: 20px;
      padding: 8px;
      cursor: pointer;
      border-radius: 8px;
      transition: background 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .top-btn:hover {
      background: var(--bg-tertiary);
    }

    /* Library Sidebar */
    .library-sidebar {
      position: fixed;
      top: 50px;
      left: 0;
      bottom: 0;
      width: 300px;
      background: var(--bg-secondary);
      border-right: 1px solid var(--border);
      transform: translateX(-100%);
      transition: transform 0.3s ease;
      z-index: 100;
      display: flex;
      flex-direction: column;
    }

    .library-sidebar.open {
      transform: translateX(0);
    }

    .library-header {
      padding: 15px;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .library-header h2 {
      margin: 0;
      font-size: 18px;
      color: var(--text-primary);
    }

    .library-close {
      background: transparent;
      border: none;
      font-size: 20px;
      cursor: pointer;
      color: var(--text-muted);
    }

    .library-list {
      flex: 1;
      overflow-y: auto;
      overscroll-behavior: contain;
      padding: 10px;
    }

    .library-item {
      display: flex;
      align-items: center;
      padding: 12px;
      margin-bottom: 8px;
      background: var(--bg-tertiary);
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .library-item:hover {
      background: var(--bg-primary);
    }

    .library-item.active {
      border: 2px solid var(--accent);
    }

    .library-item-content {
      flex: 1;
      min-width: 0;
    }

    .library-item-name {
      font-size: 14px;
      color: var(--text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      direction: rtl;
    }

    .library-item-name[contenteditable="true"] {
      background: var(--bg-secondary);
      padding: 2px 6px;
      border-radius: 4px;
      outline: 1px solid var(--accent);
    }

    .library-item-meta {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 4px;
    }

    .library-item-rename,
    .library-item-delete {
      background: transparent;
      border: none;
      font-size: 16px;
      cursor: pointer;
      color: var(--text-muted);
      padding: 4px 8px;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .library-item:hover .library-item-rename,
    .library-item-delete {
      opacity: 1;
    }

    .library-item-delete:hover {
      color: #ff6b6b;
    }

    .library-empty {
      text-align: center;
      padding: 40px 20px;
      color: var(--text-muted);
    }

    .library-overlay {
      position: fixed;
      top: 50px;
      left: 0;
      right: 1px;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s;
      z-index: 99;
    }

    .library-overlay.open {
      opacity: 1;
      visibility: visible;
    }


    /* Offset container for fixed top bar */
    .container {
      padding-top: 60px;
    }

    /* Drop Zone */
    .drop-zone {
      position: fixed;
      top: 50px;
      left: 0;
      right: 1px;
      bottom: 0;
      overflow: hidden;
      cursor: pointer;
      transition: background 0.2s;
    }

    .drop-zone:hover,
    .drop-zone.drag-over {
      border-color: var(--accent);
      background: var(--bg-tertiary);
    }

    .sample-text-bg {
      position: absolute;
      top: 0;
      left: 0;
      right: 1px;
      bottom: 0;
      padding: 20px 60px 40px 60px;
      font-size: 20px;
      line-height: 1.8;
      color: var(--text-primary);
      opacity: 0.12;
      direction: rtl;
      text-align: right;
      pointer-events: none;
      overflow: hidden;
      transition: opacity 0.3s;
    }

    .sample-text-bg p {
      margin: 0 0 0.6em 0;
    }

    .sample-text-bg p:first-child {
      font-size: 1.2em;
      font-weight: 600;
      margin-bottom: 0.8em;
    }

    .drop-prompt {
      position: absolute;
      top: calc(50% - 70px);
      left: 50%;
      transform: translate(-50%, -50%) scale(1);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 16px;
      z-index: 1;
      background: var(--bg-secondary);
      backdrop-filter: blur(8px);
      border: 2px dashed var(--border);
      border-radius: 16px;
      padding: 50px 80px;
      cursor: default;
      opacity: 1;
      transition: opacity 0.25s ease, transform 0.25s ease;
    }

    .drop-prompt.hidden {
      opacity: 0;
      transform: translate(-50%, -50%) scale(0.95);
      pointer-events: none;
    }

    /* When prompt is hidden, sample text becomes full opacity and interactive */
    .drop-zone:has(.drop-prompt.hidden) .sample-text-bg {
      opacity: 1;
      pointer-events: auto;
      cursor: text;
      overflow-y: auto;
      overscroll-behavior: contain;
    }

    /* When prompt is visible, clicking the zone dismisses it */
    .drop-zone:has(.drop-prompt:not(.hidden))::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 1px;
      bottom: 0;
      z-index: 0;
    }

    .drop-icon {
      font-size: 64px;
      opacity: 0.6;
    }

    .drop-text {
      font-size: 20px;
      color: var(--text-primary);
    }

    .drop-or {
      color: var(--text-muted);
      font-size: 14px;
    }

    .paste-btn {
      background: var(--accent);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      transition: opacity 0.2s;
    }

    .paste-btn:hover {
      opacity: 0.9;
    }

    /* Settings row */
    .settings {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
    }

    /* Loading Overlay */
    #loadingOverlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 1px;
      bottom: 0;
      background: rgba(0,0,0,0.85);
      display: none;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      gap: 20px;
      z-index: 10000;
    }
    #loadingOverlay.active { display: flex; }
    #loadingSpinner {
      width: 40px;
      height: 40px;
      border: 4px solid var(--bg-tertiary);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    #loadingText {
      color: var(--text-primary);
      font-size: 18px;
    }

    /* PDF Helper Modal */
    #pdfModal {
      position: fixed;
      top: 0;
      left: 0;
      right: 1px;
      bottom: 0;
      background: rgba(0,0,0,0.85);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10001;
    }
    #pdfModal.active { display: flex; }
    .pdf-modal-content {
      background: var(--bg-secondary);
      border-radius: 16px;
      padding: 30px;
      max-width: 550px;
      width: 90%;
      text-align: center;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
    }
    .pdf-modal-content h2 {
      color: var(--text-primary);
      margin: 0 0 16px 0;
      font-size: 24px;
    }
    .pdf-modal-content p {
      color: var(--text-secondary);
      margin: 12px 0;
      line-height: 1.6;
    }
    .pdf-command-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 10px 0;
    }

    .pdf-command {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px 16px;
      font-family: monospace;
      font-size: 14px;
      color: var(--accent);
      direction: ltr;
      text-align: left;
      word-break: break-all;
      flex: 1;
    }
    .pdf-modal-buttons {
      display: flex;
      gap: 12px;
      justify-content: center;
      margin-top: 20px;
    }
    .pdf-steps {
      text-align: right;
      background: var(--bg-tertiary);
      border-radius: 8px;
      padding: 16px;
      margin: 16px 0;
    }
    .pdf-steps ol {
      margin: 0;
      padding-right: 24px;
    }
    .pdf-steps li {
      margin: 12px 0;
      color: var(--text-secondary);
    }
    .pdf-steps li .pdf-command-row {
      margin-top: 6px;
    }
    .pdf-steps a {
      color: var(--accent);
    }
    .pdf-dropzone {
      border: 2px dashed var(--border);
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      color: var(--text-muted);
      margin: 16px 0;
      transition: all 0.2s;
    }
    .pdf-dropzone.drag-over {
      border-color: var(--accent);
      background: var(--bg-tertiary);
      color: var(--accent);
    }
    .pdf-filename {
      color: var(--accent);
      font-weight: bold;
    }
    .pdf-note {
      font-size: 12px;
      color: var(--text-muted);
      margin: 4px 0;
    }
    .pdf-example-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 6px;
      font-size: 13px;
      color: var(--text-muted);
    }
    .pdf-example-row code {
      background: var(--bg-tertiary);
      color: var(--accent);
      padding: 4px 8px;
      border-radius: 4px;
      font-family: monospace;
      direction: ltr;
    }
    .pdf-example-row button {
      padding: 4px 8px;
      font-size: 12px;
    }
    .pdf-install-note {
      font-size: 13px;
      color: var(--text-muted);
      margin-top: 16px;
    }
    .pdf-install-note a {
      color: var(--accent);
    }

    /* Paste Modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 1px;
      bottom: 0;
      background: rgba(0,0,0,0.85);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10001;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.25s ease, visibility 0.25s ease;
    }
    .modal-overlay.active {
      opacity: 1;
      visibility: visible;
    }
    .paste-modal-content {
      background: var(--bg-secondary);
      border-radius: 16px;
      padding: 30px;
      max-width: 600px;
      width: 90%;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
      transform: scale(0.95) translateY(-10px);
      transition: transform 0.25s ease;
    }
    .modal-overlay.active .paste-modal-content {
      transform: scale(1) translateY(0);
    }
    .paste-modal-content h2 {
      color: var(--text-primary);
      margin: 0 0 16px 0;
      font-size: 20px;
      text-align: right;
    }
    .paste-modal-content textarea {
      width: 100%;
      height: 200px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-primary);
      padding: 16px;
      border-radius: 8px;
      font-size: 16px;
      font-family: inherit;
      resize: vertical;
    }
    .paste-modal-content textarea::placeholder {
      color: var(--text-muted);
    }
    .paste-modal-buttons {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      margin-top: 16px;
    }

    /* Bottom Control Bar */
    .bottom-bar {
      position: fixed;
      bottom: 81px;
      left: 50%;
      transform: translateX(-50%);
      width: 85%;
      max-width: 900px;
      min-height: 84px;
      background: var(--bg-secondary);
      border: 2px solid var(--border);
      border-radius: 16px;
      padding: 16px 32px;
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .play-btn {
      position: absolute;
      top: 2px;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: var(--accent);
      border: none;
      color: white;
      font-size: 42px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1;
      transition: background 0.2s, transform 0.1s;
    }
    .play-btn:hover {
      background: var(--accent-hover);
      transform: translate(-50%, -50%) scale(1.05);
    }

    .wing {
      position: absolute;
      top: 8px;
      transform: translateY(-50%);
      height: 50px;
      background: var(--bg-tertiary);
      border: 2px solid var(--border);
      width: 125px;
      z-index: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 50px;
      padding-bottom: 10px;
      color: var(--text-secondary);
      cursor: pointer;
      transition: background 0.2s;
      user-select: none;
    }
    .wing:hover {
      background: var(--btn-hover);
    }
    .wing-left {
      right: calc(50% - 20px);
      transform: translateY(-50%) skewX(20deg);
      border-radius: 6px 0 0 6px;
      padding-right: 50px;
      padding-left: 0;
    }
    .wing-right {
      left: calc(50% - 20px);
      transform: translateY(-50%) skewX(-20deg);
      border-radius: 0 6px 6px 0;
      padding-left: 50px;
      padding-right: 1px;
    }

    .wing-outer {
      position: absolute;
      top: 0;
      height: 33px;
      background: var(--bg-tertiary);
      border: 2px solid var(--border);
      width: 81px;
      z-index: -1;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      padding-bottom: 8px;
      color: var(--text-secondary);
      cursor: pointer;
      transition: background 0.2s;
      user-select: none;
    }
    .wing-outer:hover {
      background: var(--btn-hover);
    }
    .wing-outer-left {
      right: calc(50% + 95px);
      transform: skewX(20deg);
      border-radius: 6px 0 0 6px;
      border-right: none;
      padding-right: 8px;
    }
    .wing-outer-right {
      left: calc(50% + 95px);
      transform: skewX(-20deg);
      border-radius: 0 6px 6px 0;
      border-left: none;
      padding-left: 8px;
    }

    .bar-inputs {
      position: absolute;
      bottom: 6px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 40px;
      direction: rtl;
    }
    .bar-input-group {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--text-secondary);
      font-size: 14px;
      white-space: nowrap;
    }
    .bar-input-group span {
      min-width: 95px;
      text-align: right;
    }
    .bar-input-group input[type="number"] {
      width: 68px;
      padding: 6px 8px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-primary);
      font-size: 14px;
      text-align: center;
      margin-right: -16px;
    }
    #wpmInput {
      margin-right: -20px;
    }
    .bar-input-group:last-child {
      margin-right: -20px;
    }
    .bar-input-group input[type="number"]::-webkit-inner-spin-button,
    .bar-input-group input[type="number"]::-webkit-outer-spin-button {
      opacity: 1;
      height: 24px;
    }

    .bar-buttons-right {
      position: absolute;
      top: 7.5px;
      right: 26px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .bar-buttons-right .bar-btn {
      width: 100px;
    }
    .bar-buttons-right .bar-input-group {
      margin-right: 0px;
    }
    .bar-buttons-right .bar-input-group span {
      margin-right: 1px;
    }
    .bar-buttons-right .bar-input-group input[type="number"] {
      margin-right: -40px;
    }
    .bar-buttons-left {
      position: absolute;
      bottom: 10px;
      left: 26px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .bar-btn {
      min-width: 100px;
      height: 28px;
      padding: 0 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-secondary);
      font-size: 13px;
      cursor: pointer;
      transition: background 0.2s;
      white-space: nowrap;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .bar-btn:hover {
      background: var(--btn-hover);
    }
    .bar-btn.active {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }

    .page-slider-wrapper {
      position: fixed;
      bottom: 48px;
      left: 50%;
      transform: translateX(-50%);
      width: 70%;
      max-width: 750px;
      z-index: 5;
    }
    .page-slider-container {
      width: 100%;
      padding: 14px 24px;
      background: var(--btn-bg);
      clip-path: polygon(0% 0%, 100% 0%, 95% 100%, 5% 100%);
    }
    .page-slider-container::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: var(--btn-hover);
      clip-path: polygon(0% 0%, 100% 0%, 95% 100%, 5% 100%);
      z-index: -1;
    }
    .page-slider-track {
      width: 100%;
      height: 6px;
      background: var(--bg-tertiary);
      border-radius: 3px;
    }
    .page-slider-thumb {
      position: absolute;
      top: 17px;
      left: 24px;
      transform: translate(-50%, -50%);
      min-width: 50px;
      height: 24px;
      padding: 0 10px;
      background: var(--bg-secondary);
      border: 2px solid var(--border);
      border-radius: 6px;
      cursor: grab;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      color: var(--text-secondary);
      user-select: none;
      z-index: 10;
    }
    .page-slider-thumb:active {
      cursor: grabbing;
    }

    /* Debug Icon & Panel */
    #debugIcon {
      position: fixed;
      bottom: 12px;
      right: 12px;
      width: 28px;
      height: 28px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      opacity: 0.5;
      transition: opacity 0.2s;
      z-index: 9998;
    }
    #debugIcon:hover { opacity: 1; }
    #debugPanel {
      position: fixed;
      bottom: 48px;
      right: 12px;
      width: 400px;
      max-width: calc(100vw - 24px);
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      z-index: 9999;
      display: flex;
      flex-direction: column;
      box-shadow: 0 -4px 20px rgba(0,0,0,0.3);
      opacity: 0;
      visibility: hidden;
      transform: translateY(10px);
      transition: opacity 0.2s ease, visibility 0.2s ease, transform 0.2s ease;
    }
    #debugPanel.open {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }
    #debugHeader {
      background: var(--bg-secondary);
      color: var(--text-secondary);
      padding: 8px 12px;
      font-family: monospace;
      font-size: 12px;
      display: flex;
      justify-content: flex-end;
      gap: 12px;
      border-bottom: 1px solid var(--border);
      border-radius: 8px 8px 0 0;
    }
    #debugHeader span {
      cursor: pointer;
      opacity: 0.7;
    }
    #debugHeader span:hover { opacity: 1; }
    #debugLog {
      height: 200px;
      overflow-y: auto;
      overscroll-behavior: contain;
      padding: 8px;
      font-family: monospace;
      font-size: 11px;
      color: var(--text-muted);
      background: var(--bg-tertiary);
      white-space: pre-wrap;
      user-select: text;
      border-radius: 0 0 8px 8px;
    }
    #debugLog .e { color: #ff6b6b; }
    #debugLog .w { color: #ffd43b; }
    #debugLog .i { color: var(--accent); }

    /* Settings Dropdown */
    .settings-dropdown {
      position: fixed;
      top: 50px;
      left: 50%;
      transform: translateX(-50%) translateY(-100%);
      width: 760px;
      max-width: 96vw;
      max-height: calc(100vh - 100px);
      overflow-y: auto;
      overscroll-behavior: contain;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-top: none;
      border-radius: 0 0 12px 12px;
      padding: 24px;
      z-index: 999;
      opacity: 0;
      pointer-events: none;
      transition: transform 0.3s ease, opacity 0.3s ease;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }
    @media (max-width: 750px) {
      .settings-dropdown {
        width: 400px;
        grid-template-columns: 1fr;
      }
    }
    .settings-dropdown.open {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
      pointer-events: auto;
    }
    .settings-section {
      margin-bottom: 0;
      padding: 16px;
      border-radius: 10px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
    }
    .settings-section:nth-child(even) {
      background: color-mix(in srgb, var(--bg-tertiary) 60%, var(--bg-secondary));
    }
    .settings-section h3 {
      margin: 0 0 12px 0;
      font-size: 14px;
      color: var(--text-muted);
      font-weight: normal;
    }
    .settings-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
      gap: 12px;
    }
    .settings-row:last-child {
      margin-bottom: 0;
    }
    .settings-row label {
      color: var(--text-secondary);
      font-size: 14px;
      flex-shrink: 0;
    }
    .settings-row select,
    .settings-row input[type="number"] {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-primary);
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 14px;
    }
    .settings-row select {
      min-width: 140px;
    }
    .settings-row input[type="number"] {
      width: 70px;
      text-align: center;
    }
    .settings-row input[type="color"] {
      width: 40px;
      height: 30px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-tertiary);
      cursor: pointer;
      padding: 2px;
    }
    .color-with-opacity {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .color-with-opacity input[type="range"] {
      width: 80px;
      flex-shrink: 0;
    }
    .color-with-opacity .opacity-value {
      min-width: 35px;
      font-size: 12px;
      color: var(--text-muted);
    }
    .slider-with-value {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .slider-with-value input[type="range"] {
      width: 100px;
      flex-shrink: 0;
    }
    .slider-with-value .slider-value {
      min-width: 40px;
      font-size: 12px;
      color: var(--text-muted);
    }
    .settings-row input[type="range"] {
      flex: 1;
      min-width: 100px;
      accent-color: var(--accent);
    }
    .settings-toggle {
      display: flex;
      gap: 8px;
    }
    .settings-toggle button {
      padding: 8px 14px;
      font-size: 13px;
      min-width: 50px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      color: var(--text-secondary);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s ease;
    }
    .settings-toggle button:hover {
      background: var(--bg-primary);
      border-color: var(--accent);
    }
    .settings-toggle button.active {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }
    .settings-toggle.align-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
    }
    .range-value {
      min-width: 50px;
      text-align: left;
      color: var(--text-muted);
      font-size: 12px;
      background: var(--bg-secondary);
      padding: 4px 8px;
      border-radius: 4px;
    }

    /* Pages Panel - Left side PDF-style preview */
    .figures-panel {
      position: fixed;
      top: 50px;
      left: 0;
      width: 88px;
      bottom: 0;
      background: var(--bg-tertiary);
      border-right: 1px solid var(--border);
      z-index: 5;
      display: flex;
      flex-direction: column;
      transform: translateX(-100%);
      transition: transform 0.3s ease;
      box-shadow: 4px 0 20px rgba(0,0,0,0.3);
    }
    .figures-panel.open {
      transform: translateX(0);
    }
    /* Shift content when panel is open */
    body.figures-panel-open .container {
      margin-left: 27px;
      margin-right: -27px;
    }
    .figures-header {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 4px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
    }
    .figures-header span {
      display: none;
    }
    .figures-close {
      background: transparent;
      border: none;
      color: var(--text-muted);
      font-size: 14px;
      cursor: pointer;
      padding: 2px;
    }
    .figures-close:hover {
      color: var(--text-primary);
    }
    .figures-content {
      flex: 1;
      overflow-y: auto;
      overscroll-behavior: contain;
      padding: 3px;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .page-thumb {
      position: relative;
      cursor: pointer;
      border-radius: 2px;
      overflow: hidden;
      border: 1px solid transparent;
      transition: border-color 0.2s;
      flex-shrink: 0;
    }
    .page-thumb:hover {
      border-color: var(--text-muted);
    }
    .page-thumb.active {
      border-color: var(--accent);
      box-shadow: 0 0 8px var(--accent);
      transform: scale(1.05);
      z-index: 2;
    }
    .page-thumb img {
      width: 100%;
      display: block;
    }
    .page-thumb-label {
      position: absolute;
      bottom: 2px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.6);
      color: white;
      font-size: 9px;
      padding: 1px 4px;
      border-radius: 2px;
      transition: all 0.2s;
    }
    .page-thumb.active .page-thumb-label {
      background: var(--accent);
      font-size: 11px;
      font-weight: bold;
      padding: 2px 6px;
    }
    .figures-placeholder {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 150px;
      border: 2px dashed var(--border);
      border-radius: 8px;
      color: var(--text-muted);
      text-align: center;
      padding: 12px;
      font-size: 12px;
      transition: all 0.2s;
    }
    .figures-placeholder p {
      margin: 4px 0;
    }
    .figures-content.drag-over {
      background: var(--bg-secondary);
    }
    .figures-content.drag-over .figures-placeholder {
      border-color: var(--accent);
      background: var(--btn-bg);
      color: var(--accent);
    }
    /* Lightbox for full-size figure view */
    .figure-lightbox {
      position: fixed;
      top: 0;
      left: 0;
      right: 1px;
      bottom: 0;
      background: rgba(0,0,0,0.9);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10002;
      cursor: zoom-in;
      overflow: hidden;
    }
    .figure-lightbox.active {
      display: flex;
    }
    .figure-lightbox.zoomed {
      cursor: grab;
    }
    .figure-lightbox.zoomed.dragging {
      cursor: grabbing;
    }
    .figure-lightbox img {
      max-width: 95vw;
      max-height: 95vh;
      transition: transform 0.1s ease-out;
      transform-origin: center center;
      object-fit: contain;
    }
  </style>
</head>
<body>
  <!-- VN Border SVG Overlay -->
  <svg id="vnBorderSvg" style="display: none;">
    <path id="vnBorderPath"></path>
  </svg>

  <!-- Top Bar -->
  <header class="top-bar">
    <div class="top-bar-right">
      <button class="top-btn" id="newDocBtn" title="◊û◊°◊û◊ö ◊ó◊ì◊©">‚ûï</button>
    </div>
    <h1 class="top-bar-title">◊ß◊®◊ê ◊ë◊ß◊¶◊ë ◊©◊ú◊ö</h1>
    <div class="top-bar-left">
      <button class="top-btn" id="figuresBtn" title="◊ê◊ô◊ï◊®◊ô◊ù">üñºÔ∏è</button>
      <button class="top-btn" id="styleBtn" title="◊¢◊ô◊¶◊ï◊ë">üé®</button>
      <button class="top-btn" id="libraryBtn" title="◊°◊§◊®◊ô◊ô◊î">üìö</button>
    </div>
  </header>

  <!-- Library Sidebar -->
  <div class="library-overlay" id="libraryOverlay"></div>
  <aside class="library-sidebar" id="librarySidebar">
    <div class="library-header">
      <h2>üìö ◊°◊§◊®◊ô◊ô◊î</h2>
      <button class="library-close" id="libraryClose">‚úï</button>
    </div>
    <div class="library-list" id="libraryList">
      <div class="library-empty">◊ê◊ô◊ü ◊§◊®◊ô◊ò◊ô◊ù ◊ë◊°◊§◊®◊ô◊ô◊î</div>
    </div>
  </aside>

  <!-- Vertical Progress Bar -->
  <div class="progress-bar-container" id="progressBar">
    <div class="progress-bar-fill" id="progressFill"></div>
    <span class="progress-bar-percent" id="progressPercent">0%</span>
  </div>

  <!-- Settings Dropdown -->
  <div class="settings-dropdown" id="settingsDropdown">
    <!-- Theme -->
    <div class="settings-section">
      <h3>◊°◊í◊†◊ï◊ü</h3>
      <div class="settings-row">
        <label>◊°◊í◊†◊ï◊ü:</label>
        <select id="settingsTheme" onchange="setTheme(this.value)">
          <optgroup label="‚îÄ‚îÄ Light ‚îÄ‚îÄ">
            <option value="theme-light">‚òÄÔ∏è Classic Light</option>
            <option value="theme-solarized-light">üå§Ô∏è Solarized Light</option>
            <option value="theme-github-light">üìÑ GitHub Light</option>
          </optgroup>
          <optgroup label="‚îÄ‚îÄ Dark ‚îÄ‚îÄ">
            <option value="theme-pure-dark">üåë Pure Dark (OLED)</option>
            <option value="">üîÆ Sweet Mars</option>
            <option value="theme-catppuccin">üê± Catppuccin Mocha</option>
            <option value="theme-dracula">üßõ Dracula</option>
            <option value="theme-one-dark">‚öõÔ∏è One Dark</option>
            <option value="theme-tokyo">üåÉ Tokyo Night</option>
            <option value="theme-nord">‚ùÑÔ∏è Nord</option>
            <option value="theme-gruvbox">üé® Gruvbox</option>
            <option value="theme-monokai">üé≠ Monokai Pro</option>
            <option value="theme-ayu">üåô Ayu Dark</option>
            <option value="theme-palenight">üíú Palenight</option>
            <option value="theme-rose-pine">üåπ Ros√© Pine</option>
            <option value="theme-everforest">üå≤ Everforest</option>
            <option value="theme-kanagawa">üåä Kanagawa</option>
            <option value="theme-solarized">‚òØÔ∏è Solarized Dark</option>
          </optgroup>
        </select>
      </div>
    </div>

    <!-- Font -->
    <div class="settings-section">
      <h3>◊í◊ï◊§◊ü</h3>
      <div class="settings-row">
        <label>◊°◊ï◊í:</label>
        <select id="settingsFont">
          <option value="'David', serif">David</option>
          <option value="'Noto Sans Hebrew', sans-serif">Noto Sans Hebrew</option>
          <option value="'Arial', sans-serif">Arial</option>
          <option value="'Rubik', sans-serif">Rubik</option>
          <option value="'Heebo', sans-serif">Heebo</option>
          <option value="'Assistant', sans-serif">Assistant</option>
          <option value="'Frank Ruhl Libre', serif">Frank Ruhl Libre</option>
        </select>
      </div>
      <div class="settings-row">
        <label>◊í◊ï◊ì◊ú:</label>
        <input type="range" id="settingsFontSize" min="14" max="36" value="22">
        <span class="range-value" id="fontSizeValue">22px</span>
      </div>
      <div class="settings-row">
        <label>◊¢◊ï◊ë◊ô:</label>
        <div class="settings-toggle">
          <button id="fontWeightNormal" class="active">◊®◊í◊ô◊ú</button>
          <button id="fontWeightBold">◊û◊ï◊ì◊í◊©</button>
        </div>
      </div>
    </div>

    <!-- Spacing -->
    <div class="settings-section">
      <h3>◊®◊ô◊ï◊ï◊ó</h3>
      <div class="settings-row">
        <label>◊í◊ï◊ë◊î ◊©◊ï◊®◊î:</label>
        <input type="range" id="settingsLineHeight" min="1.2" max="3" step="0.1" value="2">
        <span class="range-value" id="lineHeightValue">2</span>
      </div>
      <div class="settings-row">
        <label>◊®◊ï◊ï◊ó ◊ê◊ï◊™◊ô◊ï◊™:</label>
        <input type="range" id="settingsLetterSpacing" min="0" max="5" step="0.5" value="0">
        <span class="range-value" id="letterSpacingValue">0px</span>
      </div>
      <div class="settings-row">
        <label>◊®◊ï◊ï◊ó ◊§◊°◊ß◊ê◊ï◊™:</label>
        <input type="range" id="settingsParagraphSpacing" min="0" max="40" step="2" value="16">
        <span class="range-value" id="paragraphSpacingValue">16px</span>
      </div>
    </div>

    <!-- Layout -->
    <div class="settings-section">
      <h3>◊§◊®◊ô◊°◊î</h3>
      <div class="settings-row">
        <label>◊©◊ï◊ú◊ô◊ô◊ù ◊¶◊ì◊ì◊ô◊ô◊ù:</label>
        <input type="range" id="settingsMargins" min="10" max="100" step="5" value="30">
        <span class="range-value" id="marginsValue">30px</span>
      </div>
      <div class="settings-row">
        <label>◊ô◊ô◊©◊ï◊® ◊ò◊ß◊°◊ò:</label>
        <div class="settings-toggle align-grid">
          <button id="alignRight">◊ô◊û◊ô◊ü</button>
          <button id="alignCenterRight" class="active">◊ô◊û◊ô◊ü-◊û◊®◊õ◊ñ</button>
          <button id="alignCenter">◊û◊®◊õ◊ñ</button>
          <button id="alignJustify">◊û◊ú◊ê</button>
        </div>
      </div>
    </div>

    <!-- Highlights -->
    <div class="settings-section">
      <h3>◊î◊ì◊í◊©◊ï◊™</h3>
      <div class="settings-row">
        <label>◊¶◊ë◊¢ ◊†◊ß◊®◊ê:</label>
        <div class="color-with-opacity">
          <input type="color" id="settingsHighlightRead" value="#64c864">
          <input type="range" id="highlightReadOpacity" min="0" max="100" value="25">
          <span class="opacity-value" id="highlightReadOpacityValue">25%</span>
        </div>
      </div>
      <div class="settings-row">
        <label>◊¶◊ë◊¢ ◊†◊ï◊õ◊ó◊ô:</label>
        <div class="color-with-opacity">
          <input type="color" id="settingsHighlightCurrent" value="#ffc800">
          <input type="range" id="highlightCurrentOpacity" min="0" max="100" value="50">
          <span class="opacity-value" id="highlightCurrentOpacityValue">50%</span>
        </div>
      </div>
    </div>

    <!-- Half-Bold Mode (◊î◊ì◊í◊©◊™ ◊ó◊¶◊ô) -->
    <div class="settings-section">
      <h3>◊î◊ì◊í◊©◊™ ◊ó◊¶◊ô</h3>
      <div class="settings-row">
        <label>◊û◊¶◊ë ◊î◊ì◊í◊©◊î:</label>
        <div class="settings-toggle">
          <button id="halfBoldModeOn">◊§◊¢◊ô◊ú</button>
          <button id="halfBoldModeOff" class="active">◊õ◊ë◊ï◊ô</button>
        </div>
      </div>
      <div class="settings-row">
        <label>◊¶◊ë◊¢ (◊ê◊ï◊§◊¶◊ô◊ï◊†◊ú◊ô):</label>
        <div class="color-with-opacity">
          <input type="color" id="settingsHalfBoldColor" value="#0a84ff">
          <input type="range" id="halfBoldColorOpacity" min="0" max="100" value="0">
          <span class="opacity-value" id="halfBoldColorOpacityValue">0%</span>
        </div>
      </div>
      <div class="settings-row">
        <label>◊í◊ï◊ì◊ú ◊ê◊ï◊™◊ô◊ï◊™:</label>
        <div class="slider-with-value">
          <input type="range" id="halfBoldFontSize" min="100" max="150" value="100">
          <span class="slider-value" id="halfBoldFontSizeValue">100%</span>
        </div>
      </div>
    </div>

    <!-- VN Mode -->
    <div class="settings-section">
      <h3>◊û◊¶◊ë VN</h3>
      <div class="settings-row">
        <label>◊ê◊§◊ß◊ò ◊ì◊¢◊ô◊õ◊î:</label>
        <div class="settings-toggle">
          <button id="vnModeOn">◊§◊¢◊ô◊ú</button>
          <button id="vnModeOff" class="active">◊õ◊ë◊ï◊ô</button>
        </div>
      </div>
      <div class="settings-row">
        <label>◊ò◊ï◊ï◊ó ◊™◊¶◊ï◊í◊î:</label>
        <input type="range" id="settingsVnRadius" min="0" max="50" value="5">
        <span class="range-value" id="vnRadiusValue">2</span>
      </div>
      <div class="settings-row">
        <label>◊û◊©◊§◊ò◊ô◊ù ◊í◊ú◊ï◊ô◊ô◊ù:</label>
        <input type="range" id="settingsVnSentenceBuffer" min="1" max="5" value="1">
        <span class="range-value" id="vnSentenceBufferValue">1</span>
      </div>
      <div class="settings-row">
        <label>◊û◊°◊í◊®◊™ VN:</label>
        <div class="settings-toggle">
          <button id="vnBorderOn">◊§◊¢◊ô◊ú</button>
          <button id="vnBorderOff" class="active">◊õ◊ë◊ï◊ô</button>
        </div>
      </div>
    </div>

    <!-- Sound -->
    <div class="settings-section">
      <h3>◊¶◊ú◊ô◊ú</h3>
      <div class="settings-row">
        <label>◊û◊ò◊®◊ï◊†◊ï◊ù:</label>
        <div class="settings-toggle">
          <button id="metronomeOn" class="active">◊§◊¢◊ô◊ú</button>
          <button id="metronomeOff">◊õ◊ë◊ï◊ô</button>
        </div>
      </div>
      <div class="settings-row">
        <label>◊¢◊ï◊¶◊û◊î:</label>
        <input type="range" id="settingsVolume" min="0" max="100" value="50">
        <span class="range-value" id="volumeValue">50%</span>
      </div>
    </div>

    <!-- Animation -->
    <div class="settings-section">
      <h3>◊ê◊†◊ô◊û◊¶◊ô◊î</h3>
      <div class="settings-row">
        <label>◊í◊ï◊ì◊ú ◊§◊ï◊§:</label>
        <input type="range" id="settingsPopSize" min="0" max="20" value="8">
        <span class="range-value" id="popSizeValue">8%</span>
      </div>
      <div class="settings-row">
        <label>◊û◊î◊ô◊®◊ï◊™:</label>
        <input type="range" id="settingsAnimSpeed" min="5" max="50" value="15">
        <span class="range-value" id="animSpeedValue">0.15s</span>
      </div>
    </div>

  </div>

  <!-- Pages Panel - PDF-style thumbnails -->
  <div class="figures-panel" id="figuresPanel">
    <div class="figures-header">
      <span>◊¢◊û◊ï◊ì◊ô◊ù</span>
      <button class="figures-close" onclick="closeFiguresPanel()">‚úï</button>
    </div>
    <div class="figures-content" id="figuresContent">
      <div class="figures-placeholder">
        <p>◊í◊®◊ï◊® ◊™◊ô◊ß◊ô◊ô◊™ ◊™◊û◊ï◊†◊ï◊™</p>
      </div>
    </div>
  </div>

  <div class="container">

    <!-- Drop Zone / Input Area (hidden by default, shown if no saved state) -->
    <div class="drop-zone" id="inputArea" style="display: none;">
      <!-- Faded example text as background -->
      <div class="sample-text-bg">
        <p>◊û◊î ◊û◊©◊ï◊™◊£ ◊ú◊õ◊ú ◊î◊ô◊¶◊ï◊®◊ô◊ù ◊î◊ó◊ô◊ô◊ù</p>

        <p>◊ß◊ú◊ô◊ò◊î ◊û◊™◊û◊ì◊™ ◊©◊ú ◊ê◊†◊®◊í◊ô◊î ◊ï◊™◊†◊ï◊¢◊î ◊û◊ó◊ñ◊ï◊®◊ô◊™ ◊©◊ú ◊ó◊ï◊û◊®◊ô◊ù ◊ë◊ô◊†◊ù ◊ú◊ë◊ô◊ü ◊°◊ë◊ô◊ë◊™◊ù ◊û◊ß◊ô◊ô◊û◊ï◊™ ◊ê◊™ ◊î◊ê◊®◊í◊ï◊ü ◊î◊û◊ï◊®◊õ◊ë ◊©◊ú ◊ô◊¶◊ï◊®◊ô◊ù ◊ó◊ô◊ô◊ù. ◊ê◊ï◊®◊í◊†◊ô◊ñ◊û◊ô◊ù ◊ó◊©◊ô◊ù ◊ë◊©◊ô◊†◊ï◊ô◊ô◊ù ◊ï◊û◊í◊ô◊ë◊ô◊ù ◊¢◊ú◊ô◊î◊ù.</p>

        <p>◊õ◊ú ◊î◊ê◊ï◊®◊í◊†◊ô◊ñ◊û◊ô◊ù ◊û◊©◊™◊û◊©◊ô◊ù ◊ú◊¶◊ï◊®◊ö ◊™◊§◊ß◊ï◊ì◊î ◊ï◊î◊™◊§◊™◊ó◊ï◊™◊ù ◊ë◊û◊ô◊ì◊¢ ◊©◊†◊û◊¶◊ê ◊ë◊ô◊®◊ô◊©◊™◊ï ◊û◊î◊î◊ï◊®◊ô◊ù ◊ê◊ï ◊û◊î◊î◊ï◊®◊ô◊ù ◊©◊ú◊î◊ù DNA. ◊í◊ù ◊ê◊ù ◊ê◊ô◊†◊ï ◊ô◊õ◊ï◊ú◊ô◊ù ◊ú◊î◊í◊ì◊ô◊® "◊ó◊ô◊ô◊ù" ◊ê◊†◊ó◊†◊ï ◊ô◊õ◊ï◊ú◊ô◊ù ◊ú◊î◊ë◊ô◊ü ◊ê◊ô◊†◊ò◊ï◊ê◊ô◊ò◊ô◊ë◊ô◊™ ◊û◊î◊ï ◊ô◊¶◊ï◊® ◊ó◊ô, ◊û◊©◊ï◊ù ◊©◊ô◊© ◊õ◊û◊î ◊™◊õ◊ï◊†◊ï◊™ ◊¢◊ô◊ß◊®◊ô◊ï◊™ ◊î◊û◊©◊ï◊™◊§◊ï◊™ ◊ú◊õ◊ú ◊î◊ô◊¶◊ï◊®◊ô◊ù ◊î◊ó◊ô◊ô◊ù:</p>

        <p>◊õ◊ï◊ú◊ù ◊ñ◊ß◊ï◊ß◊ô◊ù ◊ú◊ê◊°◊§◊ß◊î ◊û◊™◊û◊ì◊™ ◊©◊ú ◊ê◊†◊®◊í◊ô◊î ◊ï◊©◊ú ◊ó◊ï◊û◊®◊ô ◊í◊ú◊ù;<br>
        ◊õ◊ï◊ú◊ù ◊ó◊©◊ô◊ù ◊ë◊©◊ô◊†◊ï◊ô◊ô◊ù ◊ï◊û◊í◊ô◊ë◊ô◊ù ◊¢◊ú◊ô◊î◊ù;<br>
        ◊ï◊ú◊õ◊ï◊ú◊ù ◊ô◊©◊î◊û◊õ◊™◊ô◊ë ◊ê◊™ ◊ê◊ï◊§◊ü ◊™◊§◊ß◊ï◊ì◊ù DNA.</p>

        <p>◊ê◊ï◊®◊í◊†◊ô◊ñ◊û◊ô◊ù ◊ñ◊ß◊ï◊ß◊ô◊ù ◊ú◊ê◊†◊®◊í◊ô◊î ◊ï◊ú◊ó◊ï◊û◊®◊ô ◊í◊ú◊ù</p>

        <p>◊ú◊ë◊ô◊ï◊ú◊ï◊í◊ô◊î ◊©◊û◊ï◊® ◊û◊ß◊ï◊ù ◊û◊ô◊ï◊ó◊ì ◊ë◊ô◊ü ◊î◊û◊ì◊¢◊ô◊ù: ◊©◊õ◊†◊ï◊™◊ô◊î ◊û◊¶◊ì ◊ê◊ó◊ì ◊î◊ü ◊î◊õ◊ô◊û◊ô◊î ◊ï◊î◊§◊ô◊ñ◊ô◊ß◊î, ◊ï◊û◊¶◊ì◊î ◊î◊ê◊ó◊® ◊î◊ô◊ê ◊í◊ï◊ë◊ú◊™ ◊ë◊§◊°◊ô◊õ◊ï◊ú◊ï◊í◊ô◊î ◊ï◊ë◊°◊ï◊¶◊ô◊ï◊ú◊ï◊í◊ô◊î.</p>

        <p>◊î◊ë◊ô◊ï◊ú◊ï◊í◊ô◊î ◊¢◊ï◊°◊ß◊™ ◊ë◊ò◊ï◊ï◊ó ◊¢◊¶◊ï◊ù ◊©◊ú ◊™◊ï◊§◊¢◊ï◊™:<br>
        ◊û◊™◊î◊ú◊ô◊õ◊ô◊ù ◊û◊ï◊ú◊ß◊ï◊ú◊®◊ô◊ô◊ù ◊ï◊¢◊ì ◊î◊ê◊ë◊ï◊ú◊ï◊¶◊ô◊î ◊©◊ë◊î ◊†◊ï◊¶◊®◊ï ◊©◊§◊¢ ◊î◊ô◊¶◊ï◊®◊ô◊ù ◊î◊ó◊ô◊ô◊ù;<br>
        ◊û◊î◊û◊†◊í◊†◊ï◊†◊ô◊ù ◊î◊û◊™◊ï◊ó◊õ◊û◊ô◊ù ◊ú◊î◊§◊ú◊ô◊ê ◊©◊ú ◊î◊ó◊ô◊°◊ï◊ü, ◊î◊®◊ë◊ô◊ô◊î, ◊¢◊ô◊ë◊ï◊ì ◊î◊û◊ô◊ì◊¢ ◊ï◊î◊î◊™◊†◊î◊í◊ï◊™;<br>
        ◊ï◊¢◊ì ◊î◊ß◊©◊®◊ô◊ù ◊î◊û◊ï◊®◊õ◊ë◊ô◊ù ◊©◊ë◊ô◊ü ◊õ◊ú ◊î◊ô◊¶◊ï◊®◊ô◊ù ◊î◊ó◊ô◊ô◊ù ◊ú◊ë◊ô◊ü ◊°◊ë◊ô◊ë◊™◊ù.</p>

        <p>◊û◊î ◊û◊©◊ï◊™◊£ ◊ú◊õ◊ú ◊î◊ô◊¶◊ï◊®◊ô◊ù ◊î◊ó◊ô◊ô◊ù. ◊ß◊ú◊ô◊ò◊î ◊û◊™◊û◊ì◊™ ◊©◊ú ◊ê◊†◊®◊í◊ô◊î ◊ï◊™◊†◊ï◊¢◊î ◊û◊ó◊ñ◊ï◊®◊ô◊™ ◊©◊ú ◊ó◊ï◊û◊®◊ô◊ù ◊ë◊ô◊†◊ù ◊ú◊ë◊ô◊ü ◊°◊ë◊ô◊ë◊™◊ù ◊û◊ß◊ô◊ô◊û◊ï◊™ ◊ê◊™ ◊î◊ê◊®◊í◊ï◊ü ◊î◊û◊ï◊®◊õ◊ë ◊©◊ú ◊ô◊¶◊ï◊®◊ô◊ù ◊ó◊ô◊ô◊ù. ◊ê◊ï◊®◊í◊†◊ô◊ñ◊û◊ô◊ù ◊ó◊©◊ô◊ù ◊ë◊©◊ô◊†◊ï◊ô◊ô◊ù ◊ï◊û◊í◊ô◊ë◊ô◊ù ◊¢◊ú◊ô◊î◊ù.</p>

        <p>◊õ◊ú ◊î◊ê◊ï◊®◊í◊†◊ô◊ñ◊û◊ô◊ù ◊û◊©◊™◊û◊©◊ô◊ù ◊ú◊¶◊ï◊®◊ö ◊™◊§◊ß◊ï◊ì◊î ◊ï◊î◊™◊§◊™◊ó◊ï◊™◊ù ◊ë◊û◊ô◊ì◊¢ ◊©◊†◊û◊¶◊ê ◊ë◊ô◊®◊ô◊©◊™◊ï ◊û◊î◊î◊ï◊®◊ô◊ù ◊ê◊ï ◊û◊î◊î◊ï◊®◊ô◊ù ◊©◊ú◊î◊ù DNA. ◊í◊ù ◊ê◊ù ◊ê◊ô◊†◊ï ◊ô◊õ◊ï◊ú◊ô◊ù ◊ú◊î◊í◊ì◊ô◊® "◊ó◊ô◊ô◊ù" ◊ê◊†◊ó◊†◊ï ◊ô◊õ◊ï◊ú◊ô◊ù ◊ú◊î◊ë◊ô◊ü ◊ê◊ô◊†◊ò◊ï◊ê◊ô◊ò◊ô◊ë◊ô◊™ ◊û◊î◊ï ◊ô◊¶◊ï◊® ◊ó◊ô.</p>
      </div>
      <!-- Drop prompt overlay -->
      <div class="drop-prompt">
        <div class="drop-icon">üìÑ</div>
        <div class="drop-text">◊í◊®◊ï◊® ◊ß◊ï◊ë◊• ◊ò◊ß◊°◊ò ◊ú◊õ◊ê◊ü</div>
        <div class="drop-or">◊ê◊ï</div>
        <button class="paste-btn" onclick="openPasteModal()">◊î◊ì◊ë◊ß ◊ò◊ß◊°◊ò</button>
      </div>
      <!-- Hidden file input -->
      <input type="file" id="fileInput" accept=".txt,.md,.pdf" onchange="loadFile(event)" hidden>
      <!-- Hidden textarea for paste modal -->
      <textarea id="textInput" hidden></textarea>
    </div>

    <!-- Controls -->
    <div class="controls" id="controls" style="display: none;">
      <button onclick="backToInput()">‚Ü© ◊ó◊ñ◊ï◊®</button>

      <!-- Page Navigation -->
      <div class="page-nav" id="pageNav" style="display: none;">
        <button onclick="prevPage()" title="◊¢◊û◊ï◊ì ◊ß◊ï◊ì◊ù">‚èÆ ◊¢◊û◊ï◊ì</button>
        <select id="pageSelect" onchange="goToPage(this.value)"></select>
        <button onclick="nextPage()" title="◊¢◊û◊ï◊ì ◊î◊ë◊ê">◊¢◊û◊ï◊ì ‚è≠</button>
      </div>

      <span class="separator">|</span>

      <button onclick="prevChunk()">‚Üí ◊î◊ß◊ï◊ì◊ù</button>
      <button class="primary" onclick="nextChunk()">◊î◊ë◊ê ‚Üê</button>
      <button id="autoBtn" onclick="toggleAuto()">‚ñ∂ ◊ê◊ï◊ò◊ï◊û◊ò◊ô</button>
      <button id="cleanBtn" class="active" onclick="toggleClean()">üßπ ◊†◊ß◊ô</button>

      <div class="settings">
        <label>
          <select id="modeSelect" onchange="toggleMode()">
            <option value="words">◊û◊ô◊ú◊ô◊ù</option>
            <option value="sentences">◊û◊©◊§◊ò◊ô◊ù</option>
          </select>
          <input type="number" id="chunkSize" value="1" min="1" max="20" onchange="updateSettings()">
        </label>
        <label>
          ◊û/◊ì◊ß◊î:
          <input type="number" id="wpm" value="200" min="50" max="500" step="25" onchange="updateSettings()">
        </label>
      </div>

      <span class="progress" id="progress">0 / 0</span>
      <button onclick="reset()">◊ê◊ô◊§◊ï◊°</button>
      <select id="themeSelect" onchange="setTheme(this.value)">
        <optgroup label="‚îÄ‚îÄ Light ‚îÄ‚îÄ">
          <option value="theme-light">‚òÄÔ∏è Classic Light</option>
          <option value="theme-solarized-light">üå§Ô∏è Solarized Light</option>
          <option value="theme-github-light">üìÑ GitHub Light</option>
        </optgroup>
        <optgroup label="‚îÄ‚îÄ Dark ‚îÄ‚îÄ">
          <option value="theme-pure-dark">üåë Pure Dark (OLED)</option>
          <option value="">üîÆ Sweet Mars</option>
          <option value="theme-catppuccin">üê± Catppuccin Mocha</option>
          <option value="theme-dracula">üßõ Dracula</option>
          <option value="theme-one-dark">‚öõÔ∏è One Dark</option>
          <option value="theme-tokyo">üåÉ Tokyo Night</option>
          <option value="theme-nord">‚ùÑÔ∏è Nord</option>
          <option value="theme-gruvbox">üé® Gruvbox</option>
          <option value="theme-monokai">üé≠ Monokai Pro</option>
          <option value="theme-ayu">üåô Ayu Dark</option>
          <option value="theme-palenight">üíú Palenight</option>
          <option value="theme-rose-pine">üåπ Ros√© Pine</option>
          <option value="theme-everforest">üå≤ Everforest</option>
          <option value="theme-kanagawa">üåä Kanagawa</option>
          <option value="theme-solarized">‚òØÔ∏è Solarized Dark</option>
        </optgroup>
      </select>
    </div>

    <!-- Text Display -->
    <div class="text-display" id="textDisplay" style="display: none;"></div>
  </div>

  <!-- Loading Overlay -->
  <div id="loadingOverlay">
    <div id="loadingSpinner"></div>
    <div id="loadingText">◊ò◊ï◊¢◊ü...</div>
  </div>

  <!-- Paste Modal -->
  <div id="pasteModal" class="modal-overlay">
    <div class="paste-modal-content">
      <h2>◊î◊ì◊ë◊ß ◊ò◊ß◊°◊ò</h2>
      <textarea id="pasteTextarea" placeholder="◊î◊ì◊ë◊ß ◊ò◊ß◊°◊ò ◊õ◊ê◊ü..." dir="rtl"></textarea>
      <div class="paste-modal-buttons">
        <button class="primary" onclick="loadPastedText()">◊ò◊¢◊ü</button>
        <button onclick="closePasteModal()">◊ë◊ô◊ò◊ï◊ú</button>
      </div>
    </div>
  </div>

  <!-- PDF Helper Modal -->
  <div id="pdfModal">
    <div class="pdf-modal-content">
      <h2>üìÑ ◊ß◊ï◊ë◊• PDF ◊ñ◊ï◊î◊î</h2>
      <p>◊ì◊§◊ì◊§◊†◊ô◊ù ◊ú◊ê ◊ô◊õ◊ï◊ú◊ô◊ù ◊ú◊ß◊®◊ï◊ê PDF ◊ô◊©◊ô◊®◊ï◊™. ◊¶◊®◊ô◊ö ◊ú◊î◊û◊ô◊® ◊ê◊ï◊™◊ï ◊ú◊ò◊ß◊°◊ò ◊ß◊ï◊ì◊ù.</p>

      <div class="pdf-steps">
        <ol>
          <li><a href="https://www.xpdfreader.com/download.html" target="_blank">◊î◊™◊ß◊ü ◊ê◊™ pdftotext</a> (◊ê◊ù ◊¢◊ï◊ì ◊ú◊ê ◊û◊ï◊™◊ß◊ü)</li>
          <li>◊ë◊û◊†◊î◊ú ◊î◊ß◊ë◊¶◊ô◊ù: ◊ß◊ú◊ô◊ß ◊ô◊û◊†◊ô ◊¢◊ú ◊î◊™◊ô◊ß◊ô◊ô◊î ‚Üí "Copy Location/Path" ◊ê◊ï "◊î◊¢◊™◊ß ◊û◊ô◊ß◊ï◊ù"</li>
          <li>◊§◊™◊ó Terminal / PowerShell / CMD</li>
          <li>
            ◊î◊®◊•: <span class="pdf-note">üí° ◊î◊ì◊ë◊ß◊î ◊ë◊ò◊®◊û◊ô◊†◊ú: Ctrl+Shift+V</span>
            <div class="pdf-command-row">
              <div class="pdf-command" id="cdCommand">cd "◊î◊û◊ô◊ß◊ï◊ù ◊©◊î◊¢◊™◊ß◊™"</div>
              <button onclick="copyCdCommand()">üìã</button>
            </div>
          </li>
          <li>
            ◊î◊®◊•:
            <div class="pdf-command-row">
              <div class="pdf-command">pdftotext "◊©◊ù ◊î◊ß◊ï◊ë◊• ◊õ◊ï◊ú◊ú ◊°◊ô◊ï◊û◊™"</div>
              <button onclick="copyPdfCommand()">üìã</button>
            </div>
            <div class="pdf-example-row">
              <span>◊ú◊ì◊ï◊í◊û◊î:</span>
              <code id="pdfCommand">pdftotext "filename.pdf"</code>
            </div>
          </li>
          <li>
            ◊í◊®◊ï◊® ◊ê◊™ ◊ß◊ï◊ë◊• ◊î-txt ◊©◊†◊ï◊¶◊® ◊ë◊™◊ô◊ß◊ô◊ô◊î ◊ú◊õ◊ê◊ü:
            <div class="pdf-dropzone" id="pdfDropzone">
              ◊í◊®◊ï◊® ◊ú◊õ◊ê◊ü
            </div>
          </li>
        </ol>
      </div>

      <div class="pdf-modal-buttons">
        <button onclick="closePdfModal()">◊°◊í◊ï◊®</button>
      </div>
    </div>
  </div>

  <!-- Bottom Control Bar -->
  <div class="bottom-bar">
    <div class="wing-outer wing-outer-left">¬ª</div>
    <div class="wing wing-left">‚Ä∫</div>
    <button class="play-btn" id="playBtn">‚ü≥</button>
    <div class="wing wing-right">‚Äπ</div>
    <div class="wing-outer wing-outer-right">¬´</div>

    <div class="bar-inputs">
      <label class="bar-input-group">
        <span>◊õ◊û◊ï◊™ ◊û◊ô◊ú◊ô◊ù:</span>
        <input type="number" id="chunkSizeInput" value="1" min="1" max="20">
      </label>
      <label class="bar-input-group">
        <span>◊û◊ô◊ú◊ô◊ù/◊ì◊ß◊î:</span>
        <input type="number" id="wpmInput" value="200" min="50" max="1000" step="10">
      </label>
    </div>

    <div class="bar-buttons-left">
      <button class="bar-btn" id="cleanTextBtn">◊ò◊ß◊°◊ò ◊†◊ß◊ô</button>
      <button class="bar-btn" id="wordModeBtn">◊û◊¶◊ë ◊û◊ô◊ú◊ô◊ù</button>
    </div>

    <div class="bar-buttons-right">
      <button class="bar-btn" id="resetBtn">◊ê◊ô◊§◊ï◊°</button>
      <label class="bar-input-group">
        <span>◊í◊ú◊ô◊ú◊î ◊ë%:</span>
        <input type="number" id="scrollToleranceInput" value="20" min="5" max="40" step="5">
      </label>
    </div>
  </div>

  <!-- Page Slider -->
  <div class="page-slider-wrapper">
    <div class="page-slider-container">
      <div class="page-slider-track" id="pageSliderTrack"></div>
    </div>
    <div class="page-slider-thumb" id="pageSliderThumb">1/1</div>
  </div>

  <!-- Figure Lightbox -->
  <div class="figure-lightbox" id="figureLightbox" onclick="closeLightbox()">
    <img id="lightboxImg" src="" alt="Figure">
  </div>

  <!-- Debug -->
  <div id="debugIcon" onclick="toggleDebug()" title="Debug">ü™≤</div>
  <div id="debugPanel">
    <div id="debugHeader">
      <span onclick="copyDebugLog()">üìã Copy</span>
      <span onclick="clearDebugLog()">üóëÔ∏è Clear</span>
    </div>
    <div id="debugLog"></div>
  </div>

  <script>
    // Debug logger
    const DEBUG = true;
    function log(msg, level = '') {
      if (!DEBUG) return;
      const time = new Date().toLocaleTimeString('en-GB');
      const logEl = document.getElementById('debugLog');
      const line = document.createElement('div');
      line.className = level;
      line.textContent = `[${time}] ${msg}`;
      logEl.appendChild(line);
      logEl.scrollTop = logEl.scrollHeight;
    }
    function logState(label) {
      log(`${label} | idx=${currentIndex} words=${words.length} clean=${useCleanText} chunk=${chunkSize}`, 'i');
    }
    function toggleDebug() {
      document.getElementById('debugPanel').classList.toggle('open');
    }
    function copyDebugLog() {
      const logEl = document.getElementById('debugLog');
      navigator.clipboard.writeText(logEl.innerText).then(() => {
        log('Log copied to clipboard', 'i');
      });
    }
    function clearDebugLog() {
      document.getElementById('debugLog').innerHTML = '';
      log('Log cleared');
    }
    // Close debug panel on outside click
    document.addEventListener('click', (e) => {
      const panel = document.getElementById('debugPanel');
      const icon = document.getElementById('debugIcon');
      if (panel.classList.contains('open') && !panel.contains(e.target) && !icon.contains(e.target)) {
        panel.classList.remove('open');
      }
    });

    // Page slider drag functionality
    (function() {
      const thumb = document.getElementById('pageSliderThumb');
      const track = document.getElementById('pageSliderTrack');
      let isDragging = false;

      // Update thumb position based on current page (RTL: right = page 1)
      window.updatePageSlider = function() {
        const totalPages = hasPages ? pages.length : 1;
        const trackWidth = track.offsetWidth;
        const trackLeft = 24; // padding from left
        // RTL: page 1 (idx 0) = right side, last page = left side
        const percent = totalPages > 1 ? (1 - currentPage / (totalPages - 1)) * 100 : 100;
        thumb.style.left = (trackLeft + (trackWidth * percent / 100)) + 'px';
        thumb.textContent = `${currentPage + 1}/${totalPages}`;
      };

      function handleSliderInput(e) {
        if (!hasPages || pages.length <= 1) return;
        const rect = track.getBoundingClientRect();
        let x = (e.clientX || e.touches[0].clientX) - rect.left;
        let percent = Math.max(0, Math.min(100, (x / rect.width) * 100));
        // RTL: right = first page, left = last page (invert percent)
        const pageIdx = Math.round((1 - percent / 100) * (pages.length - 1));
        if (pageIdx !== currentPage) {
          goToPage(pageIdx);
        }
        updatePageSlider();
      }

      thumb.addEventListener('mousedown', (e) => {
        isDragging = true;
        e.preventDefault();
      });
      thumb.addEventListener('touchstart', (e) => {
        isDragging = true;
      });

      document.addEventListener('mousemove', (e) => {
        if (isDragging) handleSliderInput(e);
      });
      document.addEventListener('touchmove', (e) => {
        if (isDragging) handleSliderInput(e);
      });

      document.addEventListener('mouseup', () => isDragging = false);
      document.addEventListener('touchend', () => isDragging = false);

      // Click on track to jump to page
      track.addEventListener('click', (e) => {
        handleSliderInput(e);
      });
    })();

    // Toggle buttons
    document.getElementById('wordModeBtn').addEventListener('click', function() {
      const chunkLabel = document.querySelector('#chunkSizeInput').previousElementSibling;
      const wpmLabel = document.querySelector('#wpmInput').previousElementSibling;
      const modeSelect = document.getElementById('modeSelect');

      if (this.textContent === '◊û◊¶◊ë ◊û◊ô◊ú◊ô◊ù') {
        this.textContent = '◊û◊¶◊ë ◊û◊©◊§◊ò◊ô◊ù';
        chunkLabel.textContent = '◊õ◊û◊ï◊™ ◊û◊©◊§◊ò◊ô◊ù:';
        modeSelect.value = 'sentences';
      } else {
        this.textContent = '◊û◊¶◊ë ◊û◊ô◊ú◊ô◊ù';
        chunkLabel.textContent = '◊õ◊û◊ï◊™ ◊û◊ô◊ú◊ô◊ù:';
        modeSelect.value = 'words';
      }
      toggleMode();
    });

    document.getElementById('cleanTextBtn').addEventListener('click', function() {
      if (this.textContent === '◊ò◊ß◊°◊ò ◊†◊ß◊ô') {
        this.textContent = '◊ò◊ß◊°◊ò ◊û◊õ◊ï◊¢◊®';
      } else {
        this.textContent = '◊ò◊ß◊°◊ò ◊†◊ß◊ô';
      }
      toggleClean();
    });

    // Play button - toggle auto advance
    document.getElementById('playBtn').addEventListener('click', toggleAuto);

    // Reset button
    document.getElementById('resetBtn').addEventListener('click', reset);

    // Scroll tolerance input
    document.getElementById('scrollToleranceInput').addEventListener('change', function() {
      scrollTolerance = parseInt(this.value) || 20;
    });

    // Bottom bar input sync
    document.getElementById('chunkSizeInput').addEventListener('input', function() {
      chunkSize = parseInt(this.value) || 1;
      document.getElementById('chunkSize').value = chunkSize;
      renderText();
      if (autoAdvance) {
        stopAutoAdvance();
        startAutoAdvance();
      }
    });
    document.getElementById('wpmInput').addEventListener('input', function() {
      wpm = parseInt(this.value) || 200;
      document.getElementById('wpm').value = wpm;
      if (autoAdvance) {
        stopAutoAdvance();
        startAutoAdvance();
      }
    });

    // Wings - chunk navigation (inner wings)
    document.querySelector('.wing-left').addEventListener('click', nextChunk);
    document.querySelector('.wing-right').addEventListener('click', prevChunk);

    // Outer wings - page navigation
    document.querySelector('.wing-outer-left').addEventListener('click', nextPage);
    document.querySelector('.wing-outer-right').addEventListener('click', prevPage);

    // Theme management
    function setTheme(theme) {
      document.body.className = theme;
      localStorage.setItem('reading-pacer-theme', theme);
      document.querySelectorAll('#themeSelect, #settingsTheme').forEach(el => {
        if (el) el.value = theme;
      });
      log('Theme set: ' + (theme || 'Sweet Mars'));
    }
    function loadTheme() {
      const saved = localStorage.getItem('reading-pacer-theme') || '';
      document.body.className = saved;
      document.querySelectorAll('#themeSelect, #settingsTheme').forEach(el => {
        if (el) el.value = saved;
      });
    }
    loadTheme();
    log('Page loaded');

    // Simple loading overlay
    function showLoading(text = '◊ò◊ï◊¢◊ü...') {
      document.getElementById('loadingText').textContent = text;
      document.getElementById('loadingOverlay').classList.add('active');
    }
    function hideLoading() {
      document.getElementById('loadingOverlay').classList.remove('active');
    }

    // Async delay helper
    function delay(ms = 0) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    let words = [];
    let currentIndex = 0;
    let chunkSize = 1;
    let wpm = 200;
    let autoAdvance = false;
    let autoInterval = null;
    let dirtyText = '';
    let cleanedText = '';
    let useCleanText = true;

    // Page tracking (only used when \f detected from pdftotext)
    let pages = [];           // Array of page objects: { dirtyText, cleanText, words }
    let currentPage = 0;
    let hasPages = false;     // True if text has page breaks

    // Sentence mode
    let sentenceMode = false;
    let sentences = [];       // Array of { startIdx, endIdx } marking word indices for each sentence
    let currentSentence = 0;
    let scrollTolerance = 20;  // How far from 25% target before scrolling

    // VN Mode - visual novel style fading
    let vnMode = localStorage.getItem('reading-pacer-vnmode') === 'true';
    let vnRadius = parseInt(localStorage.getItem('reading-pacer-vnradius')) || 5;
    let vnSentenceBuffer = parseInt(localStorage.getItem('reading-pacer-vnsentencebuffer')) || 1;
    let vnBorder = localStorage.getItem('reading-pacer-vnborder') === 'true';

    // Half-bold mode (◊î◊ì◊í◊©◊™ ◊ó◊¶◊ô)
    let halfBoldMode = localStorage.getItem('reading-pacer-halfbold') === 'true';
    let halfBoldColor = localStorage.getItem('reading-pacer-halfbold-color') || '';

    // Junk patterns to remove (for Open University / similar PDF watermarks)
    const cleanPatterns = [
      { regex: /^[_\-\u200E\u200F\u202A\u202B\u202C\u202D\u202E\s]+$/gm },           // Separator lines
      { regex: /^.*\d{2}\/\d{2}\/\d{4}\s+\d{2}:\d{2}:\d{2}.*$/gm },                  // Timestamps
      { regex: /^.*\.indb.*$/gmi },                                                  // InDesign file refs
      { regex: /^.*do not distribute.*$/gmi },                                       // Distribution warning
      { regex: /^.*File #\d+\s*belongs to.*$/gmi },                                  // File # watermarks
      { regex: /^.*\d{6,}.*@.*\.com.*$/gmi },                                        // Email watermarks
      { regex: /^.*\d{6,}.*\w+at\w+\.com.*$/gmi },                                   // Obfuscated emails
      { regex: /^[\u200E\u200F\u202A\u202B\u202C\s]*[A-Z]{5,15}[\u200E\u200F\u202A\u202B\u202C\s]*$/gm }, // Random uppercase
      { regex: /^[\u200E\u200F\u202A\u202B\u202C\s]*\d{1,6}[\u200E\u200F\u202A\u202B\u202C\s]*$/gm },     // Standalone numbers
      { regex: /^.*\bUntitled\b.*$/gm },                                             // Untitled markers
      { regex: /^.*0\s*\d{6,}.*$/gm },                                               // Barcode numbers
      { regex: /^[\u200E\u200F\u202A\u202B\u202C\u202D\u202E\u2066\u2067\u2068\u2069\s\t]+$/gm }, // RTL marks only
      // Fix broken parentheses patterns from pdftotext: (‚Ä™,)word ‚Üí (word), (‚Ä™ )word ‚Üí (word)
      { regex: /\([\u200E\u200F\u202A\u202B\u202C\u202D\u202E\u2066\u2067\u2068\u2069\s,]*\)[\u200E\u200F\u202A\u202B\u202C\u202D\u202E\u2066\u2067\u2068\u2069\s]*([a-zA-Z][a-zA-Z\s-]*)[\u200E\u200F\u202A\u202B\u202C\u202D\u202E\u2066\u2067\u2068\u2069]*/g, replacement: '($1)' },
      // Strip all RTL/bidi marks from text entirely
      { regex: /[\u200E\u200F\u202A\u202B\u202C\u202D\u202E\u2066\u2067\u2068\u2069]/g, replacement: '' },
      // Add space between English/brackets and Hebrew (when touching)
      { regex: /\)(?=[\u0590-\u05FF])/g, replacement: ') ' },
      { regex: /([\u0590-\u05FF])\(/g, replacement: '$1 (' },
      { regex: /\.(?=[\u0590-\u05FFa-zA-Z])/g, replacement: '. ' },
      { regex: /([a-zA-Z])([\u0590-\u05FF])/g, replacement: '$1 $2' },
      { regex: /([\u0590-\u05FF])([a-zA-Z])/g, replacement: '$1 $2' },
      // Fix Hebrew final letters (pdftotext often misses these)
      { regex: /◊û(?=\s|[^\u0590-\u05FF]|$)/g, replacement: '◊ù' },  // mem ‚Üí final mem
      { regex: /◊†(?=\s|[^\u0590-\u05FF]|$)/g, replacement: '◊ü' },  // nun ‚Üí final nun
      { regex: /◊¶(?=\s|[^\u0590-\u05FF]|$)/g, replacement: '◊•' },  // tsadi ‚Üí final tsadi
      { regex: /◊§(?=\s|[^\u0590-\u05FF]|$)/g, replacement: '◊£' },  // pe ‚Üí final pe
      { regex: /◊õ(?=\s|[^\u0590-\u05FF]|$)/g, replacement: '◊ö' },  // kaf ‚Üí final kaf
      { regex: /\n{3,}/g, replacement: '\n\n' },                                     // Multiple blank lines
    ];

    async function cleanTextAsync(text) {
      let result = text;
      const total = cleanPatterns.length;
      for (let i = 0; i < total; i++) {
        const p = cleanPatterns[i];
        if (p.replacement !== undefined) {
          result = result.replace(p.regex, p.replacement);
        } else {
          result = result.replace(p.regex, '');
        }
        // Yield to UI every few patterns
        if (i % 3 === 0) await delay(0);
      }
      return result.trim();
    }

    async function loadText() {
      log('loadText() called');
      const text = document.getElementById('textInput').value.trim();
      if (!text) return alert('◊ê◊†◊ê ◊î◊õ◊†◊° ◊ò◊ß◊°◊ò');

      showLoading('◊ß◊ï◊®◊ê ◊ò◊ß◊°◊ò...');
      await delay(10);

      // Check for page breaks (form feed from pdftotext)
      hasPages = text.includes('\f');
      log(`hasPages=${hasPages}`);

      if (hasPages) {
        await loadPagesAsync(text);
      } else {
        dirtyText = text;
        cleanedText = await cleanTextAsync(text);
        log(`dirty=${dirtyText.length}chars, clean=${cleanedText.length}chars`);

        await initPacerAsync(useCleanText ? cleanedText : dirtyText);
      }
      hideLoading();
      
      // Save to library (skip if loading from library)
      if (!currentLibraryId) {
        if (hasPages) {
          currentLibraryId = await saveToLibrary(text, pages);
        } else {
          currentLibraryId = await saveToLibrary(text);
        }
        log('Saved to library: ' + currentLibraryId);
      }
    }

    // Process multi-page PDF text
    async function loadPagesAsync(text) {
      const rawPages = text.split('\f').filter(p => p.trim().length > 0);
      log(`Found ${rawPages.length} pages`);

      pages = [];
      for (let i = 0; i < rawPages.length; i++) {
        const dirty = rawPages[i].trim();
        const clean = await cleanTextAsync(dirty);
        pages.push({ dirtyText: dirty, cleanText: clean, words: null });
      }

      currentPage = 0;
      await initCurrentPage();
      updatePageNav();
    }

    // Initialize words for current page
    async function initCurrentPage() {
      const page = pages[currentPage];
      const text = useCleanText ? page.cleanText : page.dirtyText;


      // Parse words for this page
      const pageWords = [];
      const lines = text.split('\n');
      for (let lineIdx = 0; lineIdx < lines.length; lineIdx++) {
        const line = lines[lineIdx];
        const trimmedLine = line.trim();

        if (trimmedLine === '') {
          if (pageWords.length > 0 && !pageWords[pageWords.length - 1].isParagraph) {
            pageWords.push({ text: '', isWord: false, isParagraph: true, isLine: false });
          }
          continue;
        }

        if (lineIdx > 0 && pageWords.length > 0 && !pageWords[pageWords.length - 1].isParagraph) {
          pageWords.push({ text: '', isWord: false, isParagraph: false, isLine: true });
        }

        // Fix detached punctuation: "word ." -> "word."
        const cleanedLine = trimmedLine.replace(/\s+\./g, '.').replace(/\s+,/g, ',').replace(/\s+:/g, ':').replace(/\s+;/g, ';');
        const tokens = cleanedLine.split(/\s+/).filter(w => w.length > 0);
        tokens.forEach(token => {
          pageWords.push({
            text: token,
            isWord: /[\u0590-\u05FFa-zA-Z]/.test(token),
            isParagraph: false,
            isLine: false
          });
        });
      }

      words = pageWords;
      currentIndex = 0;

      // Show UI
      document.getElementById('inputArea').style.display = 'none';
      document.getElementById('controls').style.display = 'none';
      document.getElementById('textDisplay').style.display = 'block';

      parseSentences();
      markHeadings();
      logState('initCurrentPage done');
      renderText();
      updateWordProgress();
      if (typeof updatePageSlider === 'function') updatePageSlider();
    }

    function updatePageNav() {
      const select = document.getElementById('pageSelect');
      select.innerHTML = pages.map((_, i) =>
        `<option value="${i}" ${i === currentPage ? 'selected' : ''}>◊¢◊û◊ï◊ì ${i + 1} / ${pages.length}</option>`
      ).join('');
      if (typeof updatePageSlider === 'function') updatePageSlider();
    }

    function goToPage(pageIdx, keepAutoAdvance = false) {
      pageIdx = parseInt(pageIdx);
      if (pageIdx < 0 || pageIdx >= pages.length) return;
      if (autoAdvance && !keepAutoAdvance) toggleAuto();
      currentPage = pageIdx;
      initCurrentPage();
      updatePageNav();
      log(`Jumped to page ${pageIdx + 1}`);
    }

    function nextPage() {
      if (currentPage < pages.length - 1) {
        goToPage(currentPage + 1);
      }
    }

    function prevPage() {
      if (currentPage > 0) {
        goToPage(currentPage - 1);
      }
    }

    async function loadFile(event) {
      const file = event.target.files[0];
      if (!file) return;

      // PDF detection - show helper modal
      if (file.name.match(/\.pdf$/i)) {
        showPdfModal(file.name);
        event.target.value = ''; // Reset input
        return;
      }

      showLoading('◊ß◊ï◊®◊ê ◊ß◊ï◊ë◊•...');

      const reader = new FileReader();
      reader.onload = async (e) => {
        const text = e.target.result;
        document.getElementById('textInput').value = text;

        // Check for page breaks
        hasPages = text.includes('\f');
        log(`loadFile hasPages=${hasPages}`);

        if (hasPages) {
          await loadPagesAsync(text);
        } else {
          dirtyText = text;
          cleanedText = await cleanTextAsync(text);
          await initPacerAsync(useCleanText ? cleanedText : dirtyText);
        }
        hideLoading();
        if (typeof saveState === 'function') saveState();
        
        // Save to library
        if (hasPages) {
          saveToLibrary(text, pages).then(id => {
            currentLibraryId = id;
            log('Saved to library: ' + id);
          });
        } else {
          saveToLibrary(text).then(id => {
            currentLibraryId = id;
            log('Saved to library: ' + id);
          });
        }
      };
      reader.readAsText(file);
    }

    async function loadSampleText() {
      const sample = `◊†◊ô◊°◊ï◊ô◊ô◊ù ◊û◊ì◊¢◊ô◊ô◊ù ◊ë◊ë◊ô◊ï◊ú◊ï◊í◊ô◊î

◊ê◊§◊©◊® ◊ú◊¢◊®◊ï◊ö ◊û◊ó◊ß◊®◊ô◊ù ◊ë◊ì◊®◊õ◊ô◊ù ◊®◊ë◊ï◊™, ◊ë◊û◊ô◊ï◊ó◊ì ◊ë◊ë◊ô◊ï◊ú◊ï◊í◊ô◊î. ◊ô◊© ◊ë◊ô◊ï◊ú◊ï◊í◊ô◊ù ◊î◊¢◊ï◊®◊õ◊ô◊ù ◊°◊ß◊®◊ô◊ù; ◊î◊ù ◊¢◊ï◊®◊õ◊ô◊ù ◊™◊¶◊§◊ô◊ï◊™ ◊û◊ë◊ú◊ô ◊ú◊†◊°◊ó ◊î◊©◊¢◊®◊ï◊™. ◊ô◊© ◊î◊û◊¢◊ú◊ô◊ù ◊î◊©◊¢◊®◊ï◊™ ◊ï◊û◊ï◊™◊ô◊®◊ô◊ù ◊ê◊™ ◊ë◊ô◊¶◊ï◊¢ ◊î◊†◊ô◊°◊ï◊ô◊ô◊ù ◊ú◊ê◊ó◊®◊ô◊ù. ◊¢◊ù ◊ñ◊ê◊™, ◊ú◊û◊®◊ï◊™ ◊î◊ô◊ß◊§◊ï ◊î◊®◊ó◊ë ◊©◊ú ◊î◊™◊ó◊ï◊ù ◊õ◊ï◊ú◊ï, ◊†◊ô◊°◊ï◊ô◊ô◊ù ◊û◊ì◊¢◊ô◊ô◊ù ◊û◊™◊ï◊õ◊†◊†◊ô◊ù ◊ë◊¢◊ß◊ë◊ô◊ï◊™ ◊ë◊ê◊ï◊™◊ï ◊ê◊ï◊§◊ü.

◊î◊ó◊ï◊ß◊®◊ô◊ù ◊ë◊ï◊ó◊®◊ô◊ù ◊ë◊õ◊ú ◊§◊¢◊ù ◊ë◊û◊©◊™◊†◊î ◊ë◊ú◊™◊ô÷æ◊™◊ú◊ï◊ô ◊ê◊ó◊ì, ◊û◊†◊°◊ô◊ù ◊ú◊©◊†◊ï◊™ ◊®◊ß ◊ê◊ï◊™◊ï ◊ë◊†◊ô◊°◊ï◊ô ◊ï◊®◊ï◊ê◊ô◊ù ◊û◊î ◊ß◊ï◊®◊î ◊ë◊¢◊ß◊ë◊ï◊™ ◊ñ◊ê◊™ ◊ú◊û◊©◊™◊†◊î ◊™◊ú◊ï◊ô ◊ô◊ó◊ô◊ì. ◊õ◊ì◊ô ◊ú◊î◊û◊ó◊ô◊© ◊õ◊ô◊¶◊ì ◊†◊¢◊©◊ô◊ù ◊†◊ô◊°◊ï◊ô◊ô◊ù ◊ë◊ë◊ô◊ï◊ú◊ï◊í◊ô◊î ◊ê◊†◊ï ◊û◊°◊õ◊û◊ô◊ù ◊õ◊ê◊ü ◊©◊†◊ô ◊†◊ô◊°◊ï◊ô◊ô◊ù ◊û◊™◊ï◊ö ◊û◊ó◊ß◊®◊ô◊ù ◊©◊î◊™◊§◊®◊°◊û◊ï ◊ë◊¢◊ë◊®.

◊ò◊ï◊í◊†◊ô◊ù ◊ï◊õ◊ê◊ë◊ô ◊ë◊ò◊ü

◊ë◊©◊†◊™ 1996 ◊ê◊ô◊©◊®◊î ◊®◊©◊ï◊™ ◊î◊û◊ñ◊ï◊ü ◊ï◊î◊™◊®◊ï◊§◊ï◊™ ◊î◊ê◊û◊®◊ô◊ß◊†◊ô◊™ (FDA) ◊ê◊™ ◊î◊©◊ô◊û◊ï◊© ◊ë◊ó◊ï◊û◊® Olestra, ◊™◊ó◊ú◊ô◊£ ◊©◊ï◊û◊ü ◊î◊û◊ô◊ï◊¶◊® ◊û◊°◊ï◊õ◊® ◊ï◊û◊©◊û◊ü ◊¶◊û◊ó◊ô, ◊õ◊™◊ï◊°◊£ ◊û◊ñ◊ï◊ü. ◊ò◊ï◊í◊†◊ô◊ù ◊û◊™◊§◊ï◊ó◊ô ◊ê◊ì◊û◊î ◊î◊ô◊ï ◊î◊û◊ï◊¶◊® ◊î◊®◊ê◊©◊ï◊ü ◊©◊î◊õ◊ô◊ú Olestra ◊ï◊ô◊¶◊ê ◊ú◊©◊ï◊ß ◊ë◊ê◊®◊¶◊ï◊™ ◊î◊ë◊®◊ô◊™.

◊™◊ï◊ö ◊ñ◊û◊ü ◊ß◊¶◊® ◊§◊®◊¶◊î ◊û◊ó◊ú◊ï◊ß◊™ ◊¢◊ñ◊î ◊°◊ë◊ô◊ë ◊™◊ï◊°◊£ ◊î◊û◊ñ◊ï◊ü ◊î◊ñ◊î. ◊®◊ë◊ô◊ù ◊î◊™◊ú◊ï◊†◊†◊ï ◊¢◊ú ◊õ◊ê◊ë◊ô ◊ë◊ò◊ü ◊ú◊ê◊ó◊® ◊ê◊õ◊ô◊ú◊™ ◊î◊ò◊ï◊í◊†◊ô◊ù ◊ï◊ó◊©◊ë◊ï ◊©◊î◊ê◊©◊û◊î ◊î◊ô◊ô◊™◊î ◊ë÷æ Olestra. ◊©◊†◊™◊ô◊ô◊ù ◊ú◊ê◊ó◊® ◊î◊©◊ß◊™ ◊î◊û◊ï◊¶◊®, ◊ó◊ï◊ß◊®◊ô◊ù ◊û◊ë◊ô◊™ ◊î◊°◊§◊® ◊ú◊®◊§◊ï◊ê◊î ◊©◊ú ◊ê◊ï◊†◊ô◊ë◊®◊°◊ô◊ò◊™ ◊í'◊ï◊†◊° ◊î◊ï◊§◊ß◊ô◊†◊° ◊™◊õ◊†◊†◊ï ◊†◊ô◊°◊ï◊ô ◊©◊†◊ï◊¢◊ì ◊ú◊ë◊ì◊ï◊ß ◊ê◊ù ◊î◊™◊ï◊°◊£ ◊í◊ï◊®◊ù ◊ú◊õ◊ê◊ë◊ô ◊ë◊ò◊ü.
\f
◊™◊õ◊†◊ï◊ü ◊î◊†◊ô◊°◊ï◊ô

◊¢◊ú ◊§◊ô ◊î◊ó◊ô◊ñ◊ï◊ô ◊©◊†◊ô◊°◊ó◊ï ◊î◊ó◊ï◊ß◊®◊ô◊ù, ◊ê◊ù Olestra ◊í◊ï◊®◊ù ◊õ◊ê◊ë◊ô ◊ë◊ò◊ü ◊ê◊ñ ◊û◊ô ◊©◊ê◊ï◊õ◊ú Olestra ◊¶◊§◊ï◊ô ◊ú◊°◊ë◊ï◊ú ◊û◊î◊™◊õ◊ï◊ï◊¶◊ï◊ô◊ï◊™ ◊ô◊ï◊™◊® ◊û◊û◊ô ◊©◊ê◊ô◊†◊ï ◊ê◊ï◊õ◊ú ◊ê◊™ ◊î◊™◊ï◊°◊£. ◊õ◊ì◊ô ◊ú◊ë◊ó◊ï◊ü ◊ê◊™ ◊î◊ó◊ô◊ñ◊ï◊ô ◊î◊ù ◊î◊©◊™◊û◊©◊ï ◊ë◊ê◊ï◊ú◊ù ◊ß◊ï◊ú◊†◊ï◊¢ ◊ë◊©◊ô◊ß◊í◊ï ◊õ"◊û◊¢◊ë◊ì◊î".

◊î◊ù ◊õ◊ô◊†◊°◊ï 1,100 ◊ê◊†◊©◊ô◊ù ◊ë◊í◊ô◊ú◊ô◊ù ◊©◊ë◊ô◊ü 13 ◊ú÷æ 38 ◊ï◊ë◊ô◊ß◊©◊ï ◊û◊î◊ù ◊ú◊ê◊õ◊ï◊ú ◊ò◊ï◊í◊†◊ô◊ù ◊ë◊¢◊™ ◊¶◊§◊ô◊ô◊î ◊ë◊°◊®◊ò. ◊õ◊ú ◊û◊©◊™◊™◊£ ◊ë◊†◊ô◊°◊ï◊ô ◊ß◊ô◊ë◊ú ◊©◊ß◊ô◊™ ◊ú◊ê ◊û◊°◊ï◊û◊†◊™ ◊©◊î◊õ◊ô◊ú◊î ◊õ÷æ 360 ◊í◊®◊ù ◊ò◊ï◊í◊†◊ô◊ù.

◊ë◊†◊ô◊°◊ï◊ô ◊ñ◊î, ◊î◊ê◊†◊©◊ô◊ù ◊©◊ß◊ô◊ë◊ú◊ï ◊ò◊ï◊í◊†◊ô◊ù ◊©◊î◊õ◊ô◊ú◊ï Olestra ◊î◊ô◊ï ◊ß◊ë◊ï◊¶◊™ ◊î◊†◊ô◊°◊ï◊ô, ◊ï◊ê◊ú◊î ◊©◊ß◊ô◊ë◊ú◊ï ◊ò◊ï◊í◊†◊ô◊ù ◊ú◊ú◊ê Olestra ◊î◊ô◊ï ◊ß◊ë◊ï◊¶◊™ ◊î◊ë◊ô◊ß◊ï◊®◊™. ◊î◊û◊©◊™◊†◊î ◊î◊ë◊ú◊™◊ô÷æ◊™◊ú◊ï◊ô ◊î◊ô◊î ◊†◊ï◊õ◊ó◊ï◊™ ◊ê◊ï ◊î◊ô◊¢◊ì◊® ◊©◊ú Olestra ◊ë◊ò◊ï◊í◊†◊ô◊ù.

◊ô◊û◊ô◊ù ◊ê◊ó◊ì◊ô◊ù ◊ú◊ê◊ó◊® ◊™◊ï◊ù ◊î◊†◊ô◊°◊ï◊ô ◊î◊™◊ß◊©◊®◊ï ◊î◊ó◊ï◊ß◊®◊ô◊ù ◊ú◊õ◊ú ◊î◊û◊©◊™◊™◊§◊ô◊ù ◊ï◊ê◊°◊§◊ï ◊û◊î◊ù ◊û◊ô◊ì◊¢ ◊¢◊ú ◊õ◊ú ◊í◊ô◊ú◊ï◊ô ◊©◊ú ◊ë◊¢◊ô◊î ◊ë◊û◊¢◊ô◊ô◊ù ◊ê◊ï ◊ë◊ß◊ô◊ë◊î ◊©◊°◊ë◊ú◊ï ◊û◊û◊†◊î ◊ú◊ê◊ó◊® ◊î◊¶◊§◊ô◊ô◊î ◊ë◊°◊®◊ò.
\f
◊™◊ï◊¶◊ê◊ï◊™ ◊ï◊û◊°◊ß◊†◊ï◊™

◊û◊ë◊ô◊ü 563 ◊î◊ê◊†◊©◊ô◊ù ◊©◊î◊ô◊ï ◊ë◊ß◊ë◊ï◊¶◊™ ◊î◊†◊ô◊°◊ï◊ô, 89 (15.8 ◊ê◊ó◊ï◊ñ◊ô◊ù) ◊î◊™◊ú◊ï◊†◊†◊ï ◊¢◊ú ◊õ◊ê◊ë◊ô ◊ë◊ò◊ü. ◊ê◊ë◊ú ◊õ◊ö ◊ß◊®◊î ◊í◊ù ◊ú÷æ 93 ◊û◊ë◊ô◊ü 529 (17.6 ◊ê◊ó◊ï◊ñ◊ô◊ù) ◊î◊ê◊†◊©◊ô◊ù ◊©◊î◊ô◊ï ◊ë◊ß◊ë◊ï◊¶◊™ ◊î◊ë◊ô◊ß◊ï◊®◊™, ◊©◊ê◊õ◊ú◊ï ◊ò◊ï◊í◊†◊ô◊ù ◊®◊í◊ô◊ú◊ô◊ù.

◊î◊°◊ô◊õ◊ï◊ô ◊©◊ú ◊ê◊†◊©◊ô◊ù ◊ú◊°◊ë◊ï◊ú ◊û◊õ◊ê◊ë◊ô ◊ë◊ò◊ü ◊î◊ô◊î ◊ì◊ï◊û◊î ◊û◊ê◊ï◊ì ◊ë◊ú◊ô ◊ß◊©◊® ◊ú◊ò◊ï◊í◊†◊ô◊ù ◊©◊ê◊õ◊ú◊ï ‚Äî ◊¢◊ù ◊ê◊ï ◊ë◊ú◊ô Olestra. ◊î◊™◊ï◊¶◊ê◊ï◊™ ◊î◊ê◊ú◊î ◊ú◊ê ◊ê◊ô◊©◊©◊ï ◊ê◊™ ◊î◊ó◊ô◊ñ◊ï◊ô, ◊ï◊î◊ó◊ï◊ß◊®◊ô◊ù ◊î◊°◊ô◊ß◊ï ◊©◊ê◊õ◊ô◊ú◊™ Olestra ◊ê◊ô◊†◊î ◊í◊ï◊®◊û◊™ ◊ú◊î◊™◊õ◊ï◊ï◊¶◊ï◊ô◊ï◊™ ◊ë◊û◊¢◊ô◊ô◊ù.

◊§◊®◊§◊®◊ô◊ù ◊ï◊¶◊ô◊§◊ï◊®◊ô◊ù

◊§◊®◊§◊® ◊î◊ò◊ï◊ï◊° ◊ß◊ô◊ë◊ú ◊ê◊™ ◊©◊û◊ï ◊ë◊í◊ú◊ú ◊î◊õ◊™◊û◊ô◊ù ◊î◊í◊ì◊ï◊ú◊ô◊ù ◊ï◊î◊¶◊ë◊¢◊ï◊†◊ô◊ô◊ù ◊¢◊ú ◊õ◊†◊§◊ô◊ï. ◊ë◊©◊†◊™ 2005 ◊ì◊ô◊ï◊ï◊ó◊ï ◊ó◊ï◊ß◊®◊ô◊ù ◊¢◊ú ◊™◊ï◊¶◊ê◊ï◊™ ◊†◊ô◊°◊ï◊ô◊ô◊ù ◊©◊ë◊ì◊ß◊ï ◊ê◊ù ◊ì◊§◊ï◊°◊ô ◊î◊™◊†◊î◊í◊ï◊™ ◊û◊°◊ï◊ô◊û◊ô◊ù ◊û◊°◊ô◊ô◊¢◊ô◊ù ◊ú◊§◊®◊§◊®◊ô ◊î◊ò◊ï◊ï◊° ◊ú◊î◊™◊í◊ï◊†◊ü ◊û◊§◊†◊ô ◊¶◊ô◊§◊ï◊®◊ô◊ù ◊î◊ò◊ï◊®◊§◊ï◊™ ◊ó◊®◊ß◊ô◊ù.

◊î◊ó◊ï◊ß◊®◊ô◊ù ◊î◊ó◊ú◊ï ◊ê◊™ ◊î◊û◊ó◊ß◊® ◊ë◊©◊†◊ô ◊û◊û◊¶◊ê◊ô◊ù ◊û◊™◊¶◊§◊ô◊ï◊™. ◊î◊ê◊ó◊ì: ◊õ◊ê◊©◊® ◊§◊®◊§◊® ◊ò◊ï◊ï◊° ◊†◊û◊¶◊ê ◊ë◊û◊†◊ï◊ó◊î ◊î◊ï◊ê ◊û◊ß◊§◊ú ◊ê◊™ ◊õ◊†◊§◊ô◊ï, ◊ï◊õ◊ö ◊®◊ß ◊î◊¶◊ì ◊î◊™◊ó◊™◊ï◊ü ◊î◊õ◊î◊î ◊í◊ú◊ï◊ô ◊ú◊¢◊ô◊ü. ◊î◊©◊†◊ô: ◊õ◊ê◊©◊® ◊§◊®◊§◊® ◊®◊ï◊ê◊î ◊ò◊ï◊®◊£ ◊û◊™◊ß◊®◊ë ◊î◊ï◊ê ◊§◊ï◊™◊ó ◊ï◊°◊ï◊í◊® ◊ê◊™ ◊õ◊†◊§◊ô◊ï ◊ë◊™◊†◊ï◊¢◊ï◊™ ◊û◊î◊ô◊®◊ï◊™, ◊ï◊ë◊™◊ï◊ö ◊õ◊ö ◊í◊ù ◊û◊†◊ô◊¢ ◊ê◊™ ◊î◊õ◊†◊§◊ô◊ô◊ù ◊î◊ê◊ó◊ï◊®◊ô◊ï◊™ ◊ë◊ê◊ï◊§◊ü ◊©◊ô◊ï◊¶◊® ◊¶◊ú◊ô◊ú ◊©◊®◊ô◊ß◊î ◊ï◊°◊ì◊®◊î ◊©◊ú ◊†◊ß◊ô◊©◊ï◊™.

◊î◊ó◊ï◊ß◊®◊ô◊ù ◊™◊î◊ï ◊û◊ì◊ï◊¢ ◊§◊®◊§◊® ◊î◊ò◊ï◊ï◊° ◊ò◊ï◊§◊ó ◊ë◊õ◊†◊§◊ô◊ï. ◊ú◊ê◊ó◊® ◊©◊°◊ß◊®◊ï ◊û◊ó◊ß◊®◊ô◊ù ◊ß◊ï◊ì◊û◊ô◊ù ◊î◊ù ◊î◊¢◊ú◊ï ◊©◊™◊ô ◊î◊©◊¢◊®◊ï◊™ ◊©◊¢◊©◊ï◊ô◊ï◊™ ◊ú◊î◊°◊ë◊ô◊® ◊ê◊™ ◊î◊î◊™◊†◊î◊í◊ï◊™ ◊î◊ñ◊ï.`;
      document.getElementById('textInput').value = sample;

      // Sample has pages
      hasPages = true;
      await loadPagesAsync(sample);
      hideLoading();
    }

    function toggleClean() {
      log('toggleClean() called, was=' + useCleanText);
      useCleanText = !useCleanText;
      const btn = document.getElementById('cleanBtn');
      btn.classList.toggle('active', useCleanText);
      btn.textContent = useCleanText ? 'üßπ ◊†◊ß◊ô' : 'üìÑ ◊û◊ß◊ï◊®◊ô';

      // Re-init with same position ratio
      const ratio = words.length > 0 ? currentIndex / words.length : 0;
      log(`ratio=${ratio.toFixed(3)}`);

      // Get text based on mode (pages or single)
      let text;
      if (hasPages) {
        text = useCleanText ? pages[currentPage].cleanText : pages[currentPage].dirtyText;
      } else {
        text = useCleanText ? cleanedText : dirtyText;
      }

      // Split by lines, preserving breaks (same as initPacer)
      words = [];
      const lines = text.split('\n');
      lines.forEach((line, lineIdx) => {
        const trimmedLine = line.trim();
        if (trimmedLine === '') {
          if (words.length > 0 && !words[words.length - 1].isParagraph) {
            words.push({ text: '', isWord: false, isParagraph: true, isLine: false });
          }
          return;
        }
        if (lineIdx > 0 && words.length > 0 && !words[words.length - 1].isParagraph) {
          words.push({ text: '', isWord: false, isParagraph: false, isLine: true });
        }
        // Fix detached punctuation: "word ." -> "word."
        const cleanedLine = trimmedLine.replace(/\s+\./g, '.').replace(/\s+,/g, ',').replace(/\s+:/g, ':').replace(/\s+;/g, ';');
        const tokens = cleanedLine.split(/\s+/).filter(w => w.length > 0);
        tokens.forEach(token => {
          words.push({
            text: token,
            isWord: /[\u0590-\u05FFa-zA-Z]/.test(token),
            isParagraph: false,
            isLine: false
          });
        });
      });

      currentIndex = Math.min(Math.floor(ratio * words.length), words.length - 1);
      currentIndex = Math.max(0, currentIndex);

      markHeadings();
      logState('after toggleClean');
      renderText();
      updateWordProgress();
    }

    async function initPacerAsync(text) {
      log('initPacerAsync() called with ' + text.length + ' chars');

      // Split by lines, preserving both single and double line breaks
      words = [];
      const lines = text.split('\n');
      const totalLines = lines.length;

      for (let lineIdx = 0; lineIdx < totalLines; lineIdx++) {
        const line = lines[lineIdx];
        const trimmedLine = line.trim();

        // Empty line = paragraph break (from double newlines)
        if (trimmedLine === '') {
          if (words.length > 0 && !words[words.length - 1].isParagraph) {
            words.push({ text: '', isWord: false, isParagraph: true, isLine: false });
          }
          continue;
        }

        // Add line break before this line (unless first line or after paragraph)
        if (lineIdx > 0 && words.length > 0 && !words[words.length - 1].isParagraph) {
          words.push({ text: '', isWord: false, isParagraph: false, isLine: true });
        }

        // Add words from this line
        // Fix detached punctuation: "word ." -> "word."
        const cleanedLine = trimmedLine.replace(/\s+\./g, '.').replace(/\s+,/g, ',').replace(/\s+:/g, ':').replace(/\s+;/g, ';');
        const tokens = cleanedLine.split(/\s+/).filter(w => w.length > 0);
        tokens.forEach(token => {
          words.push({
            text: token,
            isWord: /[\u0590-\u05FFa-zA-Z]/.test(token),
            isParagraph: false,
            isLine: false
          });
        });

        // Yield to UI periodically
        if (lineIdx % 100 === 0) await delay(0);
      }

      currentIndex = 0;
      log('currentIndex set to 0');

      // Update settings
      chunkSize = parseInt(document.getElementById('chunkSize').value) || 1;
      wpm = parseInt(document.getElementById('wpm').value) || 200;

      // Hide input, show pacer
      document.getElementById('inputArea').style.display = 'none';
      document.getElementById('controls').style.display = 'none';
      document.getElementById('textDisplay').style.display = 'block';

      parseSentences();
      markHeadings();
      logState('initPacerAsync done');
      renderText();
      updateWordProgress();
    }

    // Parse sentence boundaries - simple dot to dot
    function parseSentences() {
      sentences = [];
      let sentenceStart = 0;

      for (let i = 0; i < words.length; i++) {
        const w = words[i];

        // Check if token contains a period
        if (w.text && w.text.includes('.')) {
          sentences.push({ startIdx: sentenceStart, endIdx: i + 1 });
          sentenceStart = i + 1;
        }
      }

      // Last chunk if no period at end
      if (sentenceStart < words.length) {
        sentences.push({ startIdx: sentenceStart, endIdx: words.length });
      }

      log(`Parsed ${sentences.length} sentences`);
      currentSentence = 0;
    }

    // Mark short paragraphs (2-9 words) as headings
    function markHeadings() {
      let paraStart = 0;
      let headingCount = 0;

      for (let i = 0; i <= words.length; i++) {
        const w = words[i];
        const isEnd = !w || w.isParagraph;

        if (isEnd) {
          // Count actual words in this paragraph
          let wordCount = 0;
          for (let j = paraStart; j < i; j++) {
            if (words[j].isWord) wordCount++;
          }

          // Mark as heading if 2-9 words
          if (wordCount >= 2 && wordCount <= 9) {
            for (let j = paraStart; j < i; j++) {
              words[j].isHeading = true;
            }
            headingCount++;
          }

          paraStart = i + 1;
        }
      }

      log(`Marked ${headingCount} headings`);
    }

    function toggleMode() {
      const mode = document.getElementById('modeSelect').value;
      sentenceMode = (mode === 'sentences');
      const chunkInput = document.getElementById('chunkSize');
      chunkInput.style.display = sentenceMode ? 'none' : 'inline-block';
      
      // Toggle sentence-mode class for CSS
      const textDisplay = document.getElementById('textDisplay');
      textDisplay.classList.toggle('sentence-mode', sentenceMode);

      if (sentenceMode && sentences.length > 0) {
        // Find which sentence contains current word
        currentSentence = sentences.findIndex(s => currentIndex >= s.startIdx && currentIndex < s.endIdx);
        if (currentSentence < 0) currentSentence = 0;
        currentIndex = sentences[currentSentence].startIdx;
      }

      log(`Mode: ${mode}, sentenceMode=${sentenceMode}`);
      renderText();
      updateWordProgress();
    }

    // VN Mode: batch-based with progressive fade on previous batch
    function getVnFadeClass(wordIdx) {
      if (!vnMode) return '';

      // Find sentence boundaries
      const wordSentence = sentences.findIndex(s => wordIdx >= s.startIdx && wordIdx < s.endIdx);
      const currentSentenceIdx = sentences.findIndex(s => currentIndex >= s.startIdx && currentIndex < s.endIdx);

      if (currentSentenceIdx < 0 || wordSentence < 0) return 'vn-fade-6';

      // Calculate batch system (same as border)
      const currentBatch = Math.floor(currentSentenceIdx / vnSentenceBuffer);
      const wordBatch = Math.floor(wordSentence / vnSentenceBuffer);
      
      const batchStartSentence = currentBatch * vnSentenceBuffer;
      const batchEndSentence = Math.min(sentences.length - 1, batchStartSentence + vnSentenceBuffer - 1);
      
      // How far into current batch we are (word distance from batch start)
      const batchStartWordIdx = sentences[batchStartSentence].startIdx;
      const wordsIntoBatch = currentIndex - batchStartWordIdx;

      // Current chunk boundaries
      const chunkEnd = currentIndex + chunkSize;
      const peekEnd = chunkEnd + chunkSize;

      // CURRENT CHUNK: fully visible
      if (wordIdx >= currentIndex && wordIdx < chunkEnd) {
        return 'vn-fade-0';
      }

      // CURRENT BATCH (already read): fully visible
      if (wordBatch === currentBatch && wordIdx < currentIndex) {
        return 'vn-fade-0';
      }

      // CURRENT BATCH (peek ahead): slightly faded
      if (wordBatch === currentBatch && wordIdx >= chunkEnd && wordIdx < peekEnd) {
        return 'vn-fade-peek';
      }

      // CURRENT BATCH (further ahead): invisible
      if (wordBatch === currentBatch && wordIdx >= peekEnd) {
        return 'vn-fade-6';
      }

      // FUTURE BATCHES: invisible
      if (wordBatch > currentBatch) {
        return 'vn-fade-6';
      }

      // PREVIOUS BATCHES: only immediate previous batch fades, older ones stay invisible
      if (wordBatch < currentBatch) {
        const batchDistance = currentBatch - wordBatch;
        
        // Batches 2+ back: always fully invisible
        if (batchDistance >= 2) {
          return 'vn-fade-6';
        }
        
        // Immediate previous batch (1 back): start at 50%, fade per word
        // fade-1=50%, fade-2=37.5%, fade-3=25%, fade-4=12.5%, fade-5=0%, fade-6=0%
        const progressFade = Math.floor(wordsIntoBatch / 1); // 1 level per word
        const fadeLevel = Math.min(1 + progressFade, 6);
        return 'vn-fade-' + fadeLevel;
      }

      // Fallback
      return 'vn-fade-6';
    }

    // Format word text with half-bold (bold first N letters)
    // For words 6+ chars, use 3 letters; otherwise use 2
    function formatHalfBold(text) {
      if (text.length <= 1) return text;
      const letters = text.length >= 6 ? 3 : 2;
      const prefix = text.slice(0, letters);
      const suffix = text.slice(letters);
      return `<span class="half-bold-prefix">${prefix}</span><span class="half-bold-suffix">${suffix}</span>`;
    }

    function joinWithSmartSpacing(wordObjects, startIdx, isCurrentChunk = false) {
      return wordObjects.map((w, i) => {
        const globalIdx = startIdx + i;
        // Paragraph break (double newline)
        if (w.isParagraph) {
          return '<span class="paragraph-break"></span>';
        }
        // Line break (single newline)
        if (w.isLine) {
          return '<br>';
        }
        // Punctuation/numbers: wrap in span for VN mode fade, plain text otherwise
        if (!w.isWord) {
          if (vnMode) {
            const vnClass = getVnFadeClass(globalIdx);
            return `<span class="${vnClass}">${w.text}</span>`;
          }
          return w.text;
        }
        // Real word: clickable span with space before (unless first or after break)
        const headingClass = w.isHeading ? ' heading' : '';
        const vnClass = getVnFadeClass(globalIdx);
        // Add word-pop class for current chunk words (not in VN mode)
        const popClass = (isCurrentChunk && !vnMode) ? ' word-pop' : '';
        // Apply half-bold formatting only to current chunk
        const wordContent = (halfBoldMode && isCurrentChunk) ? formatHalfBold(w.text) : w.text;
        const span = `<span class="word${headingClass}${popClass}${vnClass ? ' ' + vnClass : ''}" onclick="setPosition(${globalIdx})">${wordContent}</span>`;
        const prevIsBreak = i > 0 && (wordObjects[i-1].isParagraph || wordObjects[i-1].isLine);
        return (i > 0 && !prevIsBreak) ? ' ' + span : span;
      }).join('');
    }

    // Draw VN border around current + upcoming sentences (the "reading zone")
    function drawVnBorder() {
      const svg = document.getElementById('vnBorderSvg');
      const path = document.getElementById('vnBorderPath');
      
      if (!vnBorder || !vnMode || sentences.length === 0) {
        svg.style.display = 'none';
        return;
      }
      
      // Find current sentence
      const currentSentenceIdx = sentences.findIndex(s => currentIndex >= s.startIdx && currentIndex < s.endIdx);
      if (currentSentenceIdx < 0) {
        svg.style.display = 'none';
        return;
      }
      
      // Calculate which "batch" of sentences we're in
      // Each batch contains vnSentenceBuffer sentences
      const batchNumber = Math.floor(currentSentenceIdx / vnSentenceBuffer);
      const startSentence = batchNumber * vnSentenceBuffer;
      const endSentence = Math.min(sentences.length - 1, startSentence + vnSentenceBuffer - 1);
      
      // Find all word elements that belong to sentences in our batch
      const allWords = document.querySelectorAll('.word');
      const rects = [];
      
      allWords.forEach(word => {
        // Get word index from onclick attribute
        const onclick = word.getAttribute('onclick');
        if (!onclick) return;
        const match = onclick.match(/setPosition\((\d+)\)/);
        if (!match) return;
        const wordIdx = parseInt(match[1]);
        
        // Check which sentence this word belongs to
        const wordSentenceIdx = sentences.findIndex(s => wordIdx >= s.startIdx && wordIdx < s.endIdx);
        
        // Only include if word's sentence is in our batch
        if (wordSentenceIdx >= startSentence && wordSentenceIdx <= endSentence) {
          const rect = word.getBoundingClientRect();
          if (rect.width > 0 && rect.height > 0) {
            rects.push({
              left: rect.left,
              right: rect.right,
              top: rect.top,
              bottom: rect.bottom
            });
          }
        }
      });
      
      if (rects.length === 0) {
        svg.style.display = 'none';
        return;
      }
      
      // Group rects by line (similar Y position, within 5px tolerance)
      const lines = [];
      const tolerance = 5;
      
      rects.forEach(rect => {
        const midY = (rect.top + rect.bottom) / 2;
        let foundLine = lines.find(line => Math.abs(line.midY - midY) < tolerance);
        if (foundLine) {
          foundLine.rects.push(rect);
          foundLine.left = Math.min(foundLine.left, rect.left);
          foundLine.right = Math.max(foundLine.right, rect.right);
          foundLine.top = Math.min(foundLine.top, rect.top);
          foundLine.bottom = Math.max(foundLine.bottom, rect.bottom);
        } else {
          lines.push({
            midY: midY,
            left: rect.left,
            right: rect.right,
            top: rect.top,
            bottom: rect.bottom,
            rects: [rect]
          });
        }
      });
      
      // Sort lines by Y position (top to bottom)
      lines.sort((a, b) => a.top - b.top);
      
      if (lines.length === 0) {
        svg.style.display = 'none';
        return;
      }
      
      // Build the path - trace around the outside
      const padding = 6;
      const radius = 8;
      let pathData = '';
      
      // Start from top-left of first line
      const firstLine = lines[0];
      const startX = firstLine.left - padding;
      const startY = firstLine.top - padding;
      
      // Move to start position
      pathData = `M ${startX + radius} ${startY}`;
      
      // Trace right along top of each line, then down
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const nextLine = lines[i + 1];
        
        // Top-right corner of this line
        pathData += ` L ${line.right + padding - radius} ${line.top - padding}`;
        pathData += ` Q ${line.right + padding} ${line.top - padding} ${line.right + padding} ${line.top - padding + radius}`;
        
        // Right side down
        if (nextLine && nextLine.right < line.right) {
          // Next line is shorter on the right - step in
          pathData += ` L ${line.right + padding} ${line.bottom + padding - radius}`;
          pathData += ` Q ${line.right + padding} ${line.bottom + padding} ${line.right + padding - radius} ${line.bottom + padding}`;
          pathData += ` L ${nextLine.right + padding + radius} ${line.bottom + padding}`;
          pathData += ` Q ${nextLine.right + padding} ${line.bottom + padding} ${nextLine.right + padding} ${nextLine.top - padding + radius}`;
        } else if (nextLine) {
          // Next line is same width or wider - just continue down
          pathData += ` L ${line.right + padding} ${nextLine.top - padding - radius}`;
          pathData += ` Q ${line.right + padding} ${nextLine.top - padding} ${Math.min(line.right, nextLine.right) + padding - radius} ${nextLine.top - padding}`;
        } else {
          // Last line - go to bottom-right corner
          pathData += ` L ${line.right + padding} ${line.bottom + padding - radius}`;
          pathData += ` Q ${line.right + padding} ${line.bottom + padding} ${line.right + padding - radius} ${line.bottom + padding}`;
        }
      }
      
      // Trace left along bottom of each line (reverse order), then up
      for (let i = lines.length - 1; i >= 0; i--) {
        const line = lines[i];
        const prevLine = lines[i - 1];
        
        // Bottom-left corner of this line
        pathData += ` L ${line.left - padding + radius} ${line.bottom + padding}`;
        pathData += ` Q ${line.left - padding} ${line.bottom + padding} ${line.left - padding} ${line.bottom + padding - radius}`;
        
        // Left side up
        if (prevLine && prevLine.left > line.left) {
          // Previous line starts more to the right - step out
          pathData += ` L ${line.left - padding} ${line.top - padding + radius}`;
          pathData += ` Q ${line.left - padding} ${line.top - padding} ${line.left - padding + radius} ${line.top - padding}`;
          pathData += ` L ${prevLine.left - padding - radius} ${line.top - padding}`;
          pathData += ` Q ${prevLine.left - padding} ${line.top - padding} ${prevLine.left - padding} ${prevLine.bottom + padding - radius}`;
        } else if (prevLine) {
          // Previous line starts at same position or more left - just continue up
          pathData += ` L ${line.left - padding} ${prevLine.bottom + padding + radius}`;
          pathData += ` Q ${line.left - padding} ${prevLine.bottom + padding} ${Math.max(line.left, prevLine.left) - padding + radius} ${prevLine.bottom + padding}`;
        } else {
          // First line - close the path
          pathData += ` L ${line.left - padding} ${line.top - padding + radius}`;
          pathData += ` Q ${line.left - padding} ${line.top - padding} ${line.left - padding + radius} ${line.top - padding}`;
        }
      }
      
      pathData += ' Z';
      
      path.setAttribute('d', pathData);
      svg.style.display = 'block';
    }

    function renderText() {
      log(`renderText() idx=${currentIndex} words=${words.length} sentenceMode=${sentenceMode}`);
      const display = document.getElementById('textDisplay');
      let html = '';

      // Determine current chunk boundaries
      let currentEnd;
      if (sentenceMode && sentences.length > 0) {
        // Highlight chunkSize sentences
        const lastSentIdx = Math.min(currentSentence + chunkSize - 1, sentences.length - 1);
        const lastSent = sentences[lastSentIdx];
        currentEnd = lastSent ? lastSent.endIdx : words.length;
      } else {
        currentEnd = Math.min(currentIndex + chunkSize, words.length);
      }

      // Group words into: read, current, unread
      if (currentIndex > 0) {
        // Read words - skip highlight in VN mode (fading handles it)
        const readContent = joinWithSmartSpacing(words.slice(0, currentIndex), 0);
        if (vnMode) {
          html += readContent + ' ';
        } else {
          html += `<span class="highlight-read">${readContent}</span> `;
        }
      }

      // Current chunk - continuous highlight
      if (currentIndex < words.length) {
        const currentContent = joinWithSmartSpacing(words.slice(currentIndex, currentEnd), currentIndex, true);
        html += `<span class="highlight-current" id="currentChunk">${currentContent}</span> `;
      }

      // Remaining words - no highlight
      if (currentEnd < words.length) {
        const remainingContent = joinWithSmartSpacing(words.slice(currentEnd), currentEnd);
        html += remainingContent;
      }

      display.innerHTML = html;

      // Smart scroll - only when highlight leaves comfort zone around 25%
      const currentEl = document.getElementById('currentChunk');
      if (currentEl) {
        const rect = currentEl.getBoundingClientRect();
        const viewportHeight = window.innerHeight;
        const targetPos = 0.25; // Fixed at 25% from top
        const tolerance = scrollTolerance / 100;
        const comfortTop = viewportHeight * (targetPos - tolerance);
        const comfortBottom = viewportHeight * (targetPos + tolerance);

        // Only scroll if outside comfort zone
        if (rect.top < comfortTop || rect.bottom > comfortBottom) {
          const targetY = window.scrollY + rect.top - (viewportHeight * targetPos);
          window.scrollTo({ top: targetY, behavior: 'smooth' });
        }
      }
      
      // Draw VN border after DOM update
      requestAnimationFrame(drawVnBorder);
    }

    function setPosition(idx) {
      currentIndex = idx;
      if (sentenceMode) {
        // Find which sentence contains this word
        currentSentence = sentences.findIndex(s => idx >= s.startIdx && idx < s.endIdx);
        if (currentSentence < 0) currentSentence = 0;
        currentIndex = sentences[currentSentence].startIdx;
      }
      renderText();
      updateWordProgress();
    }

    // Skip over line/paragraph breaks to land on actual words
    function skipBreaks(idx, direction = 1) {
      while (idx >= 0 && idx < words.length && (words[idx].isLine || words[idx].isParagraph)) {
        idx += direction;
      }
      return Math.max(0, Math.min(idx, words.length - 1));
    }

    function nextChunk() {
      if (sentenceMode) {
        if (currentSentence + chunkSize < sentences.length) {
          currentSentence += chunkSize;
          currentIndex = sentences[currentSentence].startIdx;
          renderText();
          updateWordProgress();
        } else if (hasPages && currentPage < pages.length - 1) {
          playPageFinishSound();
          goToPage(currentPage + 1, autoAdvance);
        } else if (autoAdvance) {
          toggleAuto();
        }
      } else {
        if (currentIndex + chunkSize < words.length) {
          currentIndex = skipBreaks(currentIndex + chunkSize, 1);
          renderText();
          updateWordProgress();
        } else if (hasPages && currentPage < pages.length - 1) {
          playPageFinishSound();
          goToPage(currentPage + 1, autoAdvance);
        } else if (autoAdvance) {
          toggleAuto();
        }
      }
    }

    function prevChunk() {
      if (sentenceMode) {
        if (currentSentence > 0) {
          currentSentence = Math.max(0, currentSentence - chunkSize);
          currentIndex = sentences[currentSentence].startIdx;
          renderText();
          updateWordProgress();
        } else if (hasPages && currentPage > 0) {
          currentPage--;
          initCurrentPage().then(() => {
            currentSentence = sentences.length - 1;
            currentIndex = sentences[currentSentence].startIdx;
            renderText();
            updateWordProgress();
            updatePageNav();
          });
        }
      } else if (currentIndex > 0) {
        currentIndex = skipBreaks(Math.max(0, currentIndex - chunkSize), -1);
        renderText();
        updateWordProgress();
      } else if (hasPages && currentPage > 0) {
        currentPage--;
        initCurrentPage().then(() => {
          currentIndex = skipBreaks(Math.max(0, words.length - chunkSize), -1);
          renderText();
          updateWordProgress();
          updatePageNav();
        });
      }
    }


    function nextLine() {
      for (let i = currentIndex + 1; i < words.length; i++) {
        if (words[i].isLine || words[i].isParagraph) {
          const nextIdx = skipBreaks(i + 1, 1);
          if (nextIdx < words.length) {
            currentIndex = nextIdx;
            if (sentenceMode) {
              currentSentence = sentences.findIndex(s => currentIndex >= s.startIdx && currentIndex < s.endIdx);
              if (currentSentence < 0) currentSentence = 0;
            }
            renderText();
            updateWordProgress();
          }
          return;
        }
      }
      if (hasPages && currentPage < pages.length - 1) goToPage(currentPage + 1, false);
    }

    function prevLine() {
      let foundBreak = -1;
      for (let i = currentIndex - 1; i >= 0; i--) {
        if (words[i].isLine || words[i].isParagraph) { foundBreak = i; break; }
      }
      if (foundBreak >= 0) {
        let prevBreak = -1;
        for (let i = foundBreak - 1; i >= 0; i--) {
          if (words[i].isLine || words[i].isParagraph) { prevBreak = i; break; }
        }
        currentIndex = prevBreak >= 0 ? skipBreaks(prevBreak + 1, 1) : 0;
        if (sentenceMode) {
          currentSentence = sentences.findIndex(s => currentIndex >= s.startIdx && currentIndex < s.endIdx);
          if (currentSentence < 0) currentSentence = 0;
        }
        renderText();
        updateWordProgress();
      } else if (currentIndex > 0) {
        currentIndex = 0;
        if (sentenceMode) currentSentence = 0;
        renderText();
        updateWordProgress();
      } else if (hasPages && currentPage > 0) {
        currentPage--;
        initCurrentPage().then(() => {
          currentIndex = skipBreaks(words.length - 1, -1);
          renderText();
          updateWordProgress();
          updatePageNav();
        });
      }
    }

    function toggleAuto() {
      autoAdvance = !autoAdvance;
      const btn = document.getElementById('autoBtn');
      const playBtn = document.getElementById('playBtn');

      if (autoAdvance) {
        btn.classList.add('active');
        btn.textContent = '‚è∏ ◊¢◊¶◊ï◊®';
        playBtn.textContent = '‚è∏';
        startAutoAdvance();
      } else {
        btn.classList.remove('active');
        btn.textContent = '‚ñ∂ ◊ê◊ï◊ò◊ï◊û◊ò◊ô';
        playBtn.textContent = '‚ü≥';
        stopAutoAdvance();
      }
    }

    function getAutoAdvanceInterval() {
      if (sentenceMode && sentences.length > 0) {
        // Sentence mode: calculate based on words in current sentence(s)
        const startSent = currentSentence;
        const endSent = Math.min(currentSentence + chunkSize, sentences.length);
        let wordCount = 0;
        for (let i = startSent; i < endSent; i++) {
          wordCount += sentences[i].endIdx - sentences[i].startIdx;
        }
        const baseTime = (wordCount / wpm) * 60000;
        return baseTime * 1.1; // 10% buffer
      } else {
        // Word mode: fixed interval
        return (chunkSize / wpm) * 60000;
      }
    }

    function scheduleNextChunk() {
      if (!autoAdvance) return;
      const interval = getAutoAdvanceInterval();
      autoInterval = setTimeout(() => {
        nextChunk();
        scheduleNextChunk();
      }, interval);
    }

    function startAutoAdvance() {
      scheduleNextChunk();
    }

    function stopAutoAdvance() {
      if (autoInterval) {
        clearTimeout(autoInterval);
        autoInterval = null;
      }
    }

    function updateSettings() {
      chunkSize = parseInt(document.getElementById('chunkSize').value) || 1;
      wpm = parseInt(document.getElementById('wpm').value) || 200;

      if (autoAdvance) {
        stopAutoAdvance();
        startAutoAdvance();
      }

      renderText();
    }

    function reset() {
      log('reset() called');
      currentIndex = 0;
      currentSentence = 0;
      if (autoAdvance) toggleAuto();

      logState('after reset');
      renderText();
      updateWordProgress();
    }

    function backToInput() {
      log('backToInput() called');
      if (autoAdvance) toggleAuto();
      document.getElementById('inputArea').style.display = 'block';
      document.getElementById('controls').style.display = 'none';
      document.getElementById('textDisplay').style.display = 'none';
    }

    function updateWordProgress() {
      let progressText;
      let percent;
      let visualPercent;
      if (sentenceMode) {
        progressText = `◊û◊©◊§◊ò ${currentSentence + 1} / ${sentences.length}`;
        percent = sentences.length > 0 ? ((currentSentence + 1) / sentences.length) * 100 : 0;
        visualPercent = percent;
      } else {
        progressText = `${currentIndex} / ${words.length}`;
        percent = words.length > 0 ? (currentIndex / words.length) * 100 : 0;
        // Use word-based percent (line snapping was causing issues)
        visualPercent = percent;
      }
      if (hasPages) {
        progressText += ` | ◊¢◊û◊≥ ${currentPage + 1}/${pages.length}`;
      }
      document.getElementById('progress').textContent = progressText;

      // Update vertical progress bar (use visualPercent for smoother movement)
      const progressBar = document.getElementById('progressBar');
      const progressFill = document.getElementById('progressFill');
      const progressPercent = document.getElementById('progressPercent');
      if (words.length > 0) {
        progressBar.classList.add('visible');
        progressFill.style.height = visualPercent + '%';
        progressPercent.style.top = visualPercent + '%';
        progressPercent.textContent = Math.round(visualPercent) + '%';
      } else {
        progressBar.classList.remove('visible');
      }
    }

    // Progress bar drag functionality
    function initProgressBarDrag() {
      const progressBar = document.getElementById('progressBar');
      const progressPercent = document.getElementById('progressPercent');
      let isDragging = false;

      function getPercentFromY(clientY) {
        const rect = progressBar.getBoundingClientRect();
        const y = clientY - rect.top;
        const percent = Math.max(0, Math.min(100, (y / rect.height) * 100));
        return percent;
      }

      function seekToPercent(percent) {
        if (sentenceMode && sentences.length > 0) {
          const targetSentence = Math.floor((percent / 100) * sentences.length);
          currentSentence = Math.max(0, Math.min(targetSentence, sentences.length - 1));
          currentIndex = sentences[currentSentence].startIdx;
        } else if (words.length > 0) {
          const targetWord = Math.floor((percent / 100) * words.length);
          currentIndex = Math.max(0, Math.min(targetWord, words.length - 1));
        }
        renderText();
        updateWordProgress();
      }

      function onDragStart(e) {
        isDragging = true;
        progressPercent.classList.add('dragging');
        e.preventDefault();
      }

      function onDragMove(e) {
        if (!isDragging) return;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const percent = getPercentFromY(clientY);
        seekToPercent(percent);
      }

      function onDragEnd() {
        if (!isDragging) return;
        isDragging = false;
        progressPercent.classList.remove('dragging');
      }

      progressPercent.addEventListener('mousedown', onDragStart);
      progressPercent.addEventListener('touchstart', onDragStart);
      document.addEventListener('mousemove', onDragMove);
      document.addEventListener('touchmove', onDragMove);
      document.addEventListener('mouseup', onDragEnd);
      document.addEventListener('touchend', onDragEnd);

      // Also allow clicking anywhere on the bar
      progressBar.addEventListener('click', (e) => {
        if (e.target === progressPercent) return;
        const percent = getPercentFromY(e.clientY);
        seekToPercent(percent);
      });
    }

    // Paste modal functions
    function openPasteModal() {
      document.getElementById('pasteModal').classList.add('active');
      document.getElementById('pasteTextarea').focus();
    }

    function closePasteModal() {
      document.getElementById('pasteModal').classList.remove('active');
      document.getElementById('pasteTextarea').value = '';
    }

    async function loadPastedText() {
      const text = document.getElementById('pasteTextarea').value.trim();
      if (!text) return alert('◊ê◊†◊ê ◊î◊ì◊ë◊ß ◊ò◊ß◊°◊ò');

      closePasteModal();
      document.getElementById('textInput').value = text;

      showLoading('◊ò◊ï◊¢◊ü...');
      hasPages = text.includes('\f');

      if (hasPages) {
        await loadPagesAsync(text);
      } else {
        dirtyText = text;
        cleanedText = await cleanTextAsync(text);
        await initPacerAsync(useCleanText ? cleanedText : dirtyText);
      }
      hideLoading();
      if (typeof saveState === 'function') saveState();
      
      // Save to library
      if (hasPages) {
        currentLibraryId = await saveToLibrary(text, pages);
      } else {
        currentLibraryId = await saveToLibrary(text);
      }
      log('Saved to library: ' + currentLibraryId);
    }

    // Drop prompt toggle functions
    function hideDropPrompt() {
      document.querySelector('.drop-prompt').classList.add('hidden');
    }

    function showDropPrompt() {
      document.querySelector('.drop-prompt').classList.remove('hidden');
    }

    // Click outside drop prompt to dismiss
    document.getElementById('inputArea').addEventListener('click', (e) => {
      const prompt = document.querySelector('.drop-prompt');
      if (!prompt.contains(e.target) && !prompt.classList.contains('hidden')) {
        hideDropPrompt();
      }
    });

    // New document button shows input area with drop prompt
    document.getElementById('newDocBtn').addEventListener('click', () => {
      if (autoAdvance) toggleAuto();
      currentLibraryId = null; // Reset so next load creates new library item
      document.getElementById('inputArea').style.display = 'block';
      document.getElementById('textDisplay').style.display = 'none';
      showDropPrompt();
    });

    // PDF modal functions
    let currentPdfFilename = '';

    function showPdfModal(filename) {
      log('showPdfModal() called with: ' + filename, 'i');
      currentPdfFilename = filename;
      document.getElementById('pdfCommand').textContent = `pdftotext "${filename}"`;
      const modal = document.getElementById('pdfModal');
      log('modal element: ' + (modal ? 'found' : 'NOT FOUND'), modal ? 'i' : 'e');
      modal.classList.add('active');
      log('modal classList: ' + modal.classList, 'i');
      enablePdfDropzone();
      log('PDF modal opened for: ' + filename, 'i');
    }

    function closePdfModal() {
      disablePdfDropzone();
      document.getElementById('pdfModal').classList.remove('active');
    }

    function copyPdfCommand() {
      const command = document.getElementById('pdfCommand').textContent;
      navigator.clipboard.writeText(command).then(() => {
        log('Command copied: ' + command, 'i');
        const btn = event.target;
        btn.textContent = '‚úì';
        setTimeout(() => { btn.textContent = 'üìã'; }, 1500);
      });
    }

    function copyCdCommand() {
      const command = document.getElementById('cdCommand').textContent;
      navigator.clipboard.writeText(command).then(() => {
        log('CD command copied: ' + command, 'i');
        const btn = event.target;
        btn.textContent = '‚úì';
        setTimeout(() => { btn.textContent = 'üìã'; }, 1500);
      });
    }

    // Close modal on background click
    document.getElementById('pdfModal').addEventListener('click', (e) => {
      if (e.target.id === 'pdfModal') closePdfModal();
    });

    // PDF modal dropzone handlers (only active when modal is open)
    async function handlePdfDropzoneDrop(e) {
      e.preventDefault();
      document.getElementById('pdfDropzone').classList.remove('drag-over');
      const file = e.dataTransfer.files[0];
      if (!file) return;

      if (!file.name.match(/\.(txt|md)$/i)) {
        alert('◊®◊ß ◊ß◊ë◊¶◊ô txt ◊ê◊ï md');
        return;
      }

      closePdfModal();
      showLoading('◊ß◊ï◊®◊ê ◊ß◊ï◊ë◊•...');
      const text = await file.text();
      document.getElementById('textInput').value = text;

      hasPages = text.includes('\f');
      log(`pdfDropzone hasPages=${hasPages}`);

      if (hasPages) {
        await loadPagesAsync(text);
      } else {
        dirtyText = text;
        cleanedText = await cleanTextAsync(text);
        await initPacerAsync(useCleanText ? cleanedText : dirtyText);
      }
      hideLoading();
      if (typeof saveState === 'function') saveState();

      // Save to library
      if (hasPages) {
        currentLibraryId = await saveToLibrary(text, pages);
      } else {
        currentLibraryId = await saveToLibrary(text);
      }
      log('Saved to library: ' + currentLibraryId);

      // Extract images from pending PDF after text is loaded
      if (pendingPdfFile) {
        log('Text loaded via modal, now extracting images from pending PDF', 'i');
        extractPdfPageImages(pendingPdfFile);
        pendingPdfFile = null;
      }
    }

    function handlePdfDropzoneDragover(e) {
      e.preventDefault();
      document.getElementById('pdfDropzone').classList.add('drag-over');
    }

    function handlePdfDropzoneDragleave(e) {
      e.preventDefault();
      document.getElementById('pdfDropzone').classList.remove('drag-over');
    }

    function enablePdfDropzone() {
      const dz = document.getElementById('pdfDropzone');
      dz.addEventListener('dragover', handlePdfDropzoneDragover);
      dz.addEventListener('dragleave', handlePdfDropzoneDragleave);
      dz.addEventListener('drop', handlePdfDropzoneDrop);
    }

    function disablePdfDropzone() {
      const dz = document.getElementById('pdfDropzone');
      dz.removeEventListener('dragover', handlePdfDropzoneDragover);
      dz.removeEventListener('dragleave', handlePdfDropzoneDragleave);
      dz.removeEventListener('drop', handlePdfDropzoneDrop);
    }

    // Drag and drop support
    const inputArea = document.getElementById('inputArea');
    log('inputArea element: ' + (inputArea ? 'found' : 'NOT FOUND'), inputArea ? 'i' : 'e');

    inputArea.addEventListener('dragover', (e) => {
      log('dragover fired', 'i');
      e.preventDefault();
      inputArea.classList.add('drag-over');
    });
    inputArea.addEventListener('dragleave', (e) => {
      log('dragleave fired', 'i');
      e.preventDefault();
      inputArea.classList.remove('drag-over');
    });
    inputArea.addEventListener('drop', async (e) => {
      log('drop fired', 'i');
      e.preventDefault();
      inputArea.classList.remove('drag-over');
      const file = e.dataTransfer.files[0];
      log('file: ' + (file ? file.name : 'no file'), 'i');
      if (!file) return;

      // PDF detection - store for later, show tutorial modal
      if (file.name.match(/\.pdf$/i)) {
        log('PDF detected, storing for image extraction after text loads', 'i');
        pendingPdfFile = file;
        showPdfModal(file.name);
        return;
      }

      // Only allow txt/md
      if (!file.name.match(/\.(txt|md)$/i)) {
        alert('◊í◊®◊ï◊® ◊ß◊ï◊ë◊• txt, md ◊ê◊ï pdf');
        return;
      }

      showLoading('◊ß◊ï◊®◊ê ◊ß◊ï◊ë◊•...');
      const text = await file.text();
      document.getElementById('textInput').value = text;

      // Check for page breaks
      hasPages = text.includes('\f');
      log(`drop hasPages=${hasPages}`);

      if (hasPages) {
        await loadPagesAsync(text);
      } else {
        dirtyText = text;
        cleanedText = await cleanTextAsync(text);
        await initPacerAsync(useCleanText ? cleanedText : dirtyText);
      }
      hideLoading();
      if (typeof saveState === 'function') saveState();

      // Extract images from pending PDF after text is loaded
      if (pendingPdfFile) {
        log('Text loaded, now extracting images from pending PDF', 'i');
        extractPdfPageImages(pendingPdfFile);
        pendingPdfFile = null;
      }
    });

    // Global drag and drop - anywhere on screen
    document.addEventListener('dragover', (e) => {
      e.preventDefault();
    });
    document.addEventListener('drop', async (e) => {
      // Ignore if dropped on inputArea (handled above) or pdfDropzone
      if (e.target.closest('#inputArea') || e.target.closest('#pdfDropzone')) return;

      e.preventDefault();
      const file = e.dataTransfer.files[0];
      if (!file) return;

      // PDF detection
      if (file.name.match(/\.pdf$/i)) {
        log('Global drop: PDF detected', 'i');
        pendingPdfFile = file;
        showPdfModal(file.name);
        return;
      }

      // Only allow txt/md
      if (!file.name.match(/\.(txt|md)$/i)) {
        alert('◊í◊®◊ï◊® ◊ß◊ï◊ë◊• txt, md ◊ê◊ï pdf');
        return;
      }

      showLoading('◊ß◊ï◊®◊ê ◊ß◊ï◊ë◊•...');
      const text = await file.text();
      document.getElementById('textInput').value = text;

      hasPages = text.includes('\f');
      log(`global drop hasPages=${hasPages}`);

      if (hasPages) {
        await loadPagesAsync(text);
      } else {
        dirtyText = text;
        cleanedText = await cleanTextAsync(text);
        await initPacerAsync(useCleanText ? cleanedText : dirtyText);
      }
      hideLoading();
      if (typeof saveState === 'function') saveState();

      // Extract images from pending PDF after text is loaded
      if (pendingPdfFile) {
        log('Text loaded (global), now extracting images from pending PDF', 'i');
        extractPdfPageImages(pendingPdfFile);
        pendingPdfFile = null;
      }
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT' || e.target.isContentEditable) return;

      switch(e.code) {
        case 'Space':
          e.preventDefault();
          toggleAuto();
          break;
        case 'ArrowLeft': // Left = forward in RTL
          e.preventDefault();
          nextChunk();
          break;
        case 'ArrowRight': // Right = back in RTL
          e.preventDefault();
          prevChunk();
          break;
        case 'ArrowDown':
          e.preventDefault();
          nextLine();
          break;
        case 'ArrowUp':
          e.preventDefault();
          prevLine();
          break;
        case 'PageDown':
          e.preventDefault();
          if (hasPages) nextPage();
          break;
        case 'PageUp':
          e.preventDefault();
          if (hasPages) prevPage();
          break;
        case 'KeyR':
          reset();
          break;
      }
    });

    log('All event listeners initialized', 'i');

    // Settings dropdown toggle
    document.getElementById('styleBtn').addEventListener('click', () => {
      document.getElementById('settingsDropdown').classList.toggle('open');
    });

    // Close settings when clicking outside
    document.addEventListener('click', (e) => {
      const dropdown = document.getElementById('settingsDropdown');
      const styleBtn = document.getElementById('styleBtn');
      if (dropdown.classList.contains('open') &&
          !dropdown.contains(e.target) &&
          !styleBtn.contains(e.target)) {
        dropdown.classList.remove('open');
      }
    });

    // Settings application functions
    const textDisplay = document.getElementById('textDisplay');

    function applyVisualSettings() {
      const settings = getVisualSettings();

      // Font
      textDisplay.style.fontFamily = settings.fontFamily;
      textDisplay.style.fontSize = settings.fontSize + 'px';
      textDisplay.style.fontWeight = settings.fontWeight;

      // Spacing
      textDisplay.style.lineHeight = settings.lineHeight;
      textDisplay.style.letterSpacing = settings.letterSpacing + 'px';

      // Layout
      textDisplay.style.paddingLeft = settings.margins + 'px';
      textDisplay.style.paddingRight = settings.margins + 'px';
      if (settings.textAlign === 'center-right') {
        textDisplay.style.textAlign = 'right';
        textDisplay.classList.add('centered-block');
      } else {
        textDisplay.style.textAlign = settings.textAlign;
        textDisplay.classList.remove('centered-block');
      }

      // Highlights are now handled by applyHighlightColors() with opacity sliders

      // Paragraph spacing (applied via CSS class)
      document.documentElement.style.setProperty('--paragraph-spacing', settings.paragraphSpacing + 'px');

      saveVisualSettings(settings);
    }

    function getVisualSettings() {
      return {
        fontFamily: document.getElementById('settingsFont').value,
        fontSize: parseInt(document.getElementById('settingsFontSize').value),
        fontWeight: document.getElementById('fontWeightBold').classList.contains('active') ? 'bold' : 'normal',
        lineHeight: parseFloat(document.getElementById('settingsLineHeight').value),
        letterSpacing: parseFloat(document.getElementById('settingsLetterSpacing').value),
        paragraphSpacing: parseInt(document.getElementById('settingsParagraphSpacing').value),
        margins: parseInt(document.getElementById('settingsMargins').value),
        textAlign: document.getElementById('alignCenter').classList.contains('active') ? 'center' :
                   document.getElementById('alignJustify').classList.contains('active') ? 'justify' :
                   document.getElementById('alignCenterRight').classList.contains('active') ? 'center-right' : 'right',
        highlightRead: document.getElementById('settingsHighlightRead').value,
        highlightCurrent: document.getElementById('settingsHighlightCurrent').value,
        popSize: parseInt(document.getElementById('settingsPopSize').value),
        animSpeed: parseInt(document.getElementById('settingsAnimSpeed').value),
        volume: parseInt(document.getElementById('settingsVolume').value)
      };
    }

    function saveVisualSettings(settings) {
      localStorage.setItem('reading-pacer-visual', JSON.stringify(settings));
    }

    function loadVisualSettings() {
      const saved = localStorage.getItem('reading-pacer-visual');
      if (!saved) return;

      try {
        const settings = JSON.parse(saved);

        // Apply to form elements
        if (settings.fontFamily) document.getElementById('settingsFont').value = settings.fontFamily;
        if (settings.fontSize) {
          document.getElementById('settingsFontSize').value = settings.fontSize;
          document.getElementById('fontSizeValue').textContent = settings.fontSize + 'px';
        }
        if (settings.fontWeight === 'bold') {
          document.getElementById('fontWeightNormal').classList.remove('active');
          document.getElementById('fontWeightBold').classList.add('active');
        }
        if (settings.lineHeight) {
          document.getElementById('settingsLineHeight').value = settings.lineHeight;
          document.getElementById('lineHeightValue').textContent = settings.lineHeight;
        }
        if (settings.letterSpacing !== undefined) {
          document.getElementById('settingsLetterSpacing').value = settings.letterSpacing;
          document.getElementById('letterSpacingValue').textContent = settings.letterSpacing + 'px';
        }
        if (settings.paragraphSpacing !== undefined) {
          document.getElementById('settingsParagraphSpacing').value = settings.paragraphSpacing;
          document.getElementById('paragraphSpacingValue').textContent = settings.paragraphSpacing + 'px';
        }
        if (settings.margins) {
          document.getElementById('settingsMargins').value = settings.margins;
          document.getElementById('marginsValue').textContent = settings.margins + 'px';
        }
        if (settings.textAlign) {
          document.querySelectorAll('#alignRight, #alignCenter, #alignJustify, #alignCenterRight').forEach(b => b.classList.remove('active'));
          if (settings.textAlign === 'center') document.getElementById('alignCenter').classList.add('active');
          else if (settings.textAlign === 'justify') document.getElementById('alignJustify').classList.add('active');
          else if (settings.textAlign === 'center-right') document.getElementById('alignCenterRight').classList.add('active');
          else document.getElementById('alignCenterRight').classList.add('active');
        }
        if (settings.highlightRead) document.getElementById('settingsHighlightRead').value = settings.highlightRead;
        if (settings.highlightCurrent) document.getElementById('settingsHighlightCurrent').value = settings.highlightCurrent;

        // Animation settings
        if (settings.popSize !== undefined) {
          document.getElementById('settingsPopSize').value = settings.popSize;
          document.getElementById('popSizeValue').textContent = settings.popSize + '%';
          document.documentElement.style.setProperty('--pop-scale', 1 + settings.popSize / 100);
        }
        if (settings.animSpeed !== undefined) {
          document.getElementById('settingsAnimSpeed').value = settings.animSpeed;
          document.getElementById('animSpeedValue').textContent = (settings.animSpeed / 100).toFixed(2) + 's';
          document.documentElement.style.setProperty('--anim-speed', (settings.animSpeed / 100) + 's');
        }

        // Volume
        if (settings.volume !== undefined) {
          document.getElementById('settingsVolume').value = settings.volume;
          document.getElementById('volumeValue').textContent = settings.volume + '%';
        }

        applyVisualSettings();
      } catch (e) {
        log('Failed to load visual settings: ' + e.message, 'e');
      }
    }

    function hexToRgba(hex, alpha) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    // Wire up all settings controls
    document.getElementById('settingsFont').addEventListener('change', applyVisualSettings);

    document.getElementById('settingsFontSize').addEventListener('input', function() {
      document.getElementById('fontSizeValue').textContent = this.value + 'px';
      applyVisualSettings();
    });

    document.getElementById('fontWeightNormal').addEventListener('click', function() {
      document.getElementById('fontWeightBold').classList.remove('active');
      this.classList.add('active');
      applyVisualSettings();
    });
    document.getElementById('fontWeightBold').addEventListener('click', function() {
      document.getElementById('fontWeightNormal').classList.remove('active');
      this.classList.add('active');
      applyVisualSettings();
    });

    document.getElementById('settingsLineHeight').addEventListener('input', function() {
      document.getElementById('lineHeightValue').textContent = this.value;
      applyVisualSettings();
    });

    document.getElementById('settingsLetterSpacing').addEventListener('input', function() {
      document.getElementById('letterSpacingValue').textContent = this.value + 'px';
      applyVisualSettings();
    });

    document.getElementById('settingsParagraphSpacing').addEventListener('input', function() {
      document.getElementById('paragraphSpacingValue').textContent = this.value + 'px';
      applyVisualSettings();
    });

    document.getElementById('settingsMargins').addEventListener('input', function() {
      document.getElementById('marginsValue').textContent = this.value + 'px';
      applyVisualSettings();
    });

    ['alignRight', 'alignCenter', 'alignJustify', 'alignCenterRight'].forEach(id => {
      document.getElementById(id).addEventListener('click', function() {
        document.querySelectorAll('#alignRight, #alignCenter, #alignJustify, #alignCenterRight').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        applyVisualSettings();
      });
    });

    document.getElementById('settingsHighlightRead').addEventListener('input', applyHighlightColors);
    document.getElementById('settingsHighlightCurrent').addEventListener('input', applyHighlightColors);

    // Highlight opacity sliders
    document.getElementById('highlightReadOpacity').addEventListener('input', function() {
      document.getElementById('highlightReadOpacityValue').textContent = this.value + '%';
      localStorage.setItem('reading-pacer-highlight-read-opacity', this.value);
      applyHighlightColors();
    });
    document.getElementById('highlightCurrentOpacity').addEventListener('input', function() {
      document.getElementById('highlightCurrentOpacityValue').textContent = this.value + '%';
      localStorage.setItem('reading-pacer-highlight-current-opacity', this.value);
      applyHighlightColors();
    });

    // Apply highlight colors with opacity
    function applyHighlightColors() {
      const readColor = document.getElementById('settingsHighlightRead').value;
      const currentColor = document.getElementById('settingsHighlightCurrent').value;
      const readOpacity = parseInt(document.getElementById('highlightReadOpacity').value);
      const currentOpacity = parseInt(document.getElementById('highlightCurrentOpacity').value);

      document.documentElement.style.setProperty('--highlight-read', hexToRgba(readColor, readOpacity / 100));
      document.documentElement.style.setProperty('--highlight-current', hexToRgba(currentColor, currentOpacity / 100));
      document.documentElement.style.setProperty('--highlight-current-border', hexToRgba(currentColor, Math.min(1, currentOpacity / 100 + 0.3)));

      // Save opacity values
      localStorage.setItem('reading-pacer-highlight-read-opacity', readOpacity);
      localStorage.setItem('reading-pacer-highlight-current-opacity', currentOpacity);

      // Save colors too
      const settings = getVisualSettings();
      saveVisualSettings(settings);
    }

    // Metronome toggle
    document.getElementById('metronomeOn').addEventListener('click', function() {
      document.getElementById('metronomeOff').classList.remove('active');
      this.classList.add('active');
      metronomeEnabled = true;
      localStorage.setItem('reading-pacer-metronome', 'true');
    });
    document.getElementById('metronomeOff').addEventListener('click', function() {
      document.getElementById('metronomeOn').classList.remove('active');
      this.classList.add('active');
      metronomeEnabled = false;
      localStorage.setItem('reading-pacer-metronome', 'false');
    });

    // VN Mode toggle
    document.getElementById('vnModeOn').addEventListener('click', function() {
      document.getElementById('vnModeOff').classList.remove('active');
      this.classList.add('active');
      vnMode = true;
      document.body.classList.add('vn-mode');
      localStorage.setItem('reading-pacer-vnmode', 'true');
      if (words.length > 0) renderText();
    });
    document.getElementById('vnModeOff').addEventListener('click', function() {
      document.getElementById('vnModeOn').classList.remove('active');
      this.classList.add('active');
      vnMode = false;
      document.body.classList.remove('vn-mode');
      localStorage.setItem('reading-pacer-vnmode', 'false');
      if (words.length > 0) renderText();
    });

    // VN Radius slider
    document.getElementById('settingsVnRadius').addEventListener('input', function() {
      vnRadius = parseInt(this.value);
      document.getElementById('vnRadiusValue').textContent = this.value;
      localStorage.setItem('reading-pacer-vnradius', this.value);
      if (vnMode && words.length > 0) renderText();
    });

    // VN Sentence Buffer slider
    document.getElementById('settingsVnSentenceBuffer').addEventListener('input', function() {
      vnSentenceBuffer = parseInt(this.value);
      document.getElementById('vnSentenceBufferValue').textContent = this.value;
      localStorage.setItem('reading-pacer-vnsentencebuffer', this.value);
      if (vnMode && words.length > 0) renderText();
    });

    // VN Border toggle
    document.getElementById('vnBorderOn').addEventListener('click', function() {
      document.getElementById('vnBorderOff').classList.remove('active');
      this.classList.add('active');
      vnBorder = true;
      localStorage.setItem('reading-pacer-vnborder', 'true');
      if (vnMode && words.length > 0) drawVnBorder();
    });
    document.getElementById('vnBorderOff').addEventListener('click', function() {
      document.getElementById('vnBorderOn').classList.remove('active');
      this.classList.add('active');
      vnBorder = false;
      localStorage.setItem('reading-pacer-vnborder', 'false');
      drawVnBorder(); // Will hide the SVG
    });

    // Half-bold mode toggle (◊î◊ì◊í◊©◊™ ◊ó◊¶◊ô)
    document.getElementById('halfBoldModeOn').addEventListener('click', function() {
      document.getElementById('halfBoldModeOff').classList.remove('active');
      this.classList.add('active');
      halfBoldMode = true;
      document.getElementById('textDisplay').classList.add('half-bold-mode');
      document.documentElement.style.setProperty('--half-bold-color', halfBoldColor);
      localStorage.setItem('reading-pacer-halfbold', 'true');
      if (words.length > 0) renderText();
    });
    document.getElementById('halfBoldModeOff').addEventListener('click', function() {
      document.getElementById('halfBoldModeOn').classList.remove('active');
      this.classList.add('active');
      halfBoldMode = false;
      document.getElementById('textDisplay').classList.remove('half-bold-mode');
      localStorage.setItem('reading-pacer-halfbold', 'false');
      if (words.length > 0) renderText();
    });

    // Half-bold color picker
    document.getElementById('settingsHalfBoldColor').addEventListener('input', applyHalfBoldColor);

    // Half-bold color opacity slider
    document.getElementById('halfBoldColorOpacity').addEventListener('input', function() {
      document.getElementById('halfBoldColorOpacityValue').textContent = this.value + '%';
      localStorage.setItem('reading-pacer-halfbold-opacity', this.value);
      applyHalfBoldColor();
    });

    // Half-bold font size slider
    document.getElementById('halfBoldFontSize').addEventListener('input', function() {
      document.getElementById('halfBoldFontSizeValue').textContent = this.value + '%';
      localStorage.setItem('reading-pacer-halfbold-fontsize', this.value);
      document.documentElement.style.setProperty('--half-bold-font-size', this.value + '%');
    });

    function applyHalfBoldColor() {
      const color = document.getElementById('settingsHalfBoldColor').value;
      const opacityVal = parseInt(document.getElementById('halfBoldColorOpacity').value);
      const opacity = opacityVal / 100;
      localStorage.setItem('reading-pacer-halfbold-color', color);
      localStorage.setItem('reading-pacer-halfbold-opacity', opacityVal);

      if (opacity === 0) {
        document.documentElement.style.setProperty('--half-bold-color', 'inherit');
      } else {
        document.documentElement.style.setProperty('--half-bold-color', hexToRgba(color, opacity));
      }
      if (halfBoldMode && words.length > 0) renderText();
    }

    document.getElementById('settingsVolume').addEventListener('input', function() {
      document.getElementById('volumeValue').textContent = this.value + '%';
      applyVisualSettings();
    });

    // Animation settings
    document.getElementById('settingsPopSize').addEventListener('input', function() {
      const val = this.value;
      document.getElementById('popSizeValue').textContent = val + '%';
      document.documentElement.style.setProperty('--pop-scale', 1 + val / 100);
      applyVisualSettings();
    });

    document.getElementById('settingsAnimSpeed').addEventListener('input', function() {
      const val = this.value;
      document.getElementById('animSpeedValue').textContent = (val / 100).toFixed(2) + 's';
      document.documentElement.style.setProperty('--anim-speed', (val / 100) + 's');
      applyVisualSettings();
    });

    // Initialize animation CSS vars
    document.documentElement.style.setProperty('--pop-scale', 1.08);
    document.documentElement.style.setProperty('--anim-speed', '0.15s');

    // Web Audio API - zero latency sound
    // Pattern: click1, click2, click2, click2, repeat (metronome pattern)
    let audioCtx = null;
    let clickBuffers = [null, null];
    let pageFinishBuffer = null;
    let clickPattern = 0;
    let audioReady = false;
    let metronomeEnabled = localStorage.getItem('reading-pacer-metronome') !== 'false';

    // Restore metronome toggle UI state
    if (!metronomeEnabled) {
      document.getElementById('metronomeOn').classList.remove('active');
      document.getElementById('metronomeOff').classList.add('active');
    }

    // Restore VN mode toggle UI state
    if (vnMode) {
      document.getElementById('vnModeOff').classList.remove('active');
      document.getElementById('vnModeOn').classList.add('active');
      document.body.classList.add('vn-mode');
    }

    // Restore VN radius slider
    document.getElementById('settingsVnRadius').value = vnRadius;
    document.getElementById('vnRadiusValue').textContent = vnRadius;

    // Restore VN sentence buffer slider
    document.getElementById('settingsVnSentenceBuffer').value = vnSentenceBuffer;
    document.getElementById('vnSentenceBufferValue').textContent = vnSentenceBuffer;

    // Restore VN border toggle
    if (vnBorder) {
      document.getElementById('vnBorderOff').classList.remove('active');
      document.getElementById('vnBorderOn').classList.add('active');
    }

    // Restore half-bold mode settings (◊î◊ì◊í◊©◊™ ◊ó◊¶◊ô)
    if (halfBoldMode) {
      document.getElementById('halfBoldModeOff').classList.remove('active');
      document.getElementById('halfBoldModeOn').classList.add('active');
      document.getElementById('textDisplay').classList.add('half-bold-mode');
    }
    if (halfBoldColor) {
      document.getElementById('settingsHalfBoldColor').value = halfBoldColor;
      document.documentElement.style.setProperty('--half-bold-color', halfBoldColor);
    }

    // Update VN border on scroll
    let vnBorderScrollTimeout;
    window.addEventListener('scroll', function() {
      if (vnBorder && vnMode) {
        clearTimeout(vnBorderScrollTimeout);
        vnBorderScrollTimeout = setTimeout(drawVnBorder, 16); // ~60fps throttle
      }
    });

    // Embedded audio as base64
    const CLICK1_B64 = '//OEZAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAADAAAFcABcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFzCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsL///////////////////////////////////////////8AAABQTEFNRTMuMTAwBHgAAAAAAAAAADUIJAJcLQAB4AAABXB6+3Z4AAAAAAAAAAAAAAAAAAAA//PUZAAI8E97f6CMABabBlZfQSgAuJdmjACcgfl2UAAZAAAAFyAAAF/oiJuAAAgaD4fwfB/WD4fdWD4OHMHwQOYOAg78oGK0p//KBjo5QEP/1g+flwf5v///5cH5bI1EA5eDBAMYxvgGMY+QBjyApoQhCEoIB8XcQDgoRvOc5znIQhCEIQhznO5znOQhG+/+QhEb/8hzoIBwOBwjIT/////znOf5CEJ//5CCAcDjCYAAQOEwyJw+hnSpOnDgAAAlCYAsQADgNAGijNkEgjoRLlpGpzGRSBAy2xFm/YUFCzxgVgQBQ9wpGXlWi3QRABqsLbr4LnI1A0HEwxQ0VqGAOBuYgQqBqQCYq1mAsAoYIoZZjMkuAoHkCgKAgAcvymUYr4Q5gWAUFtm3ZkYtoIA8AanE0yfQxTpaIraoK+hCAEl+MgDIhMzQ+IgARIAdOFhy1WRsBWLFHRXbAsMvg7bwOVJmsuFQXb8ttS6NLlZbVYCXdWkYAAJZgMgDQDFtRB+kMjANAcMLAFkxJQA0EtbuWE6SAJGDeFYYQ4ESZxMAaFwAC5qCrsLRRVZq0lUrObYQ//PkZPkw5htbf8z4JBhapn7/j1AADCvqCoHdqVXa0kruS7JQABDc5zmGGeHcO1aXtWl7MxnNeIEACHgGVTONKoas4444zUjpZcnoYGoKQCA0FgFnsu0HP//7l+dC3sq1M/8a1Ko1yVRr60axuSqryJRGWvV//J7dM+0GQNfvQW/s1fj1qUvs6KgohAOvc+VSrCjwi1DKrV/DsrjspkMolc1DuZux4p2p0AAB+kdAFtAiVxiDbN98TZJ63jbBG9EechrLoYErcMdY55L7/RKnnGLs5j/8z6qa/T8fDomfqFUt/Nbf756XS5yPNR2oqU9v+UEke/1nqTugVRf/l6v9dWZzK3EaSEggJKRH8cDAIlszMpGkUWJVVYcSSeSIBCSiOaRgX+BuIRsAsFAyiEDSIwDiQEAYGGDgKARlAyMKWE2hYSIJF8ipOmqi8Xi8ykieTLpdNW1GReIsXjZ6ki8XjZJKkZF4vJUS6XXWijSS6KLVJVEyQEgpqZF4zICOafJkc0ipqkXi8bIt1JJJekkkkkj/rRRRR9aKKKKP0UUUUUUXWYkyRUusXiLF01RpJJJEWLpqj1oo0WUkXknWkkklRRRRSSSSSSrRSSSSSdExLqT0UWUXi8xkXi8bJPqSNhsU//OkZNsbehEtD+NQAIwQAjGdwAAAFGog4FyfhWCoKuKhqDTg79axE8SnesFYl/4lBXKgqd1gqd/iU7/WdywNf5b+Iga/kUxBTUUzLjEwMKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq';
    const PAGE_FINISH_B64 = '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AMyRBEcEJRZ109f9Temh2N+ZjdNRngNcPEPNH6af//VFhAPq//s0xPcAB6i9OeSCgWDRl6d88FBtRc3W5AACQCgMODEakWTV/+r/rUj0SUJ4gQGdcCyjFS9Kk3/9mDpgGKw4jB1aqAAHAIA4AAACNSHmRiii//q/6jMy1kogTooUCyQdUkjztUpFP/+WC8F9QGtoYVKLRlgABMhLHABtiDgRETJFv/qb/09Ah4zRVE8gZN+I//skxPuARny/Pe2ChWjNF+c9sFB0PLifTdD//TPCPgL+DfiJKrmAAAAAcDgAAAROCRY5Y/rW2kYhkErA1JAej8BIUTqSOlZv/////8xJIMsgNeQUCiDf///////6MAAAAAAsBo4a////apAy1nBGSZFwGR4Zgrs+//s0xPkABzy/N+yCh2DcF2d9oFCtgg7//1LHKB7xJyFq6gAAAACgOAAAAM0BKC////1HX7jpNQ6oGiLkepfTTv//oGoDYHAqqkAAAAJg4ADNzYzLbf//+s4ipZkLSKmJ2LwVGCwiqk2fWr//yuALjpLTVbywAACgYDgAAA3kYEfLM0h20mr/OvzAkTMP0Awk//skxP4AyAi7MeeChyDTl2Z5QFNMIOwbs+gpP//////1ERCAYLmM72ZAACAgaKXMNZ3Ayst6z4f/XSE8GvSFbF0gwGlzjMpL6art//////sI6AIPjImSlXcAAHZAOAAAALAQ9EEKMOabLdv/K3f5D21EqFrpSBCB//skxPSAxei5PeoCemCmF2c5QFNMA+3IHIiRNm06aLf/qWERIGnpCPl////Z///6VKTDxAADs8EkQIAISIeaJMn/zh/60ThgMi+mXA+I2GqBxQ4eoZqtMEU0P/9IL4AaiSMqv///////+qqqipgKgIA4AAAL46gM//skxPmARiS7NemCmmC0Fyc9QE9MWkDQl1igE00/x8H/0ywHvkCP9IiJVD8QBAQg1JfUk3//QFxAZ1gQxU1FyAS9QkYkBNHnAKgDRX8lH6y/LhgHKMWesibjkBCpGK33//9MZ0Dl8jUadwiHCHqAOAAAHrblMq3///skxPuAxwi7MewChaCYFyb5QE9MMkPE6D8QMh4XzUXeobCYSCAUyC2J+lX//3IYB78TQc////////TEBASDhLmA9ftnSf63/IedHEYCbibNuoZpZPAJqi2petv//cpAcGxq86j9dZgAeggIQDgAABi+r9Aa5Nc0//sUxP2ARNi5OeoCOmCpl2a9MENMP/UcM0VF00fUdHCcHWBjnQmp5+62//10gLQ0Q5///////9if2Zm6oAsjgEAADnCgAwQCxHwrr1NYmRBiLyl/6Y5wZCQ6BJJLBqAS//skxPoAxei5NewChSC9lyZ5sFDccX6H//50NsFvuagLcAlwOAAAAL1wLgRRlFgOAOcTwCwZb/dkVVIlNDpEENRaQAQwMikvroN//1gG46P///////QlVD04BMAAmRYgupJ4uhZt1JOGOBxt/6LJsmRdA8/WM2o6//s0xPwAx8S5K+oCmmDglyW5QFNMBjnIxWfrpL//5QARQ4WVS8qbCAqwOAAAAG2Q3w5o5woUA0IdNlJBMEafX1pmhcRGVKiSXkQqAwbI0/b//5kBFUt0EzMTlAGkBmQvkIQkOBQLqUL5FTdnzQwCAMGkSHHquoroogGISRf1f//mYI4bqgmZeoeqgDgAAAnJ//skxP4AxqS5MeoCmmCtlyZ5QE9MOuVCZOCtvdjnirJIs+frfwUsSKR6CQD9lqzfqBRC+BhVQwzz9LSb//////mINyzL///////6ymIWGjJgwBtMpp3BCzIrrfxK1/P+3hBR+ysS+0JGtDNevsOe5QA5RJxf9Fv///sUxP8AhqS3L+oCemCtF2Y5QEtM////+oQULv///////9OKmgCbiKA4EDAAUjCHDZJ4qAOIm6XpayQJEfIY20A2Y2S1/IAtADHhiRf1///WNQeh5H0//+489XBmgF5n//s0xPQABpC3L+oCGmDCFub9UENMZxwACsR3LAQhCS+3eTAEgpac6K1NU+3mdQXCv//zMKMs////f9fXmM7FVdrMAAzNADgQUAA/ROugiCeR3of1GApMTgS5keOBMQeD/ly4GUxt9///1Aehff//Yq1pFMO7W6Fht3THAYABDR2uwrwGKAaEa6j3GcJYMWhp//skxP8AxwS3L+qCGmDAlyX5QEtMpTZRdAeUiL6/UOWtAAYJa+r//9YK+YKZmQgIiKA4AAAZFJaAXPJJ9+GQBoGo8jFWozC3Iw0U6DdZDJkAfIk29b///hIF/u5mZXVZAAXAAHUWAOAjNEidICgyaS1JVBkw8qGd//skxPwAxiy3M+oCGmC7Fua5QDdMEKI1CMBtdXzOoLrK//8C9PqgKXXV79y7uMvAABAADlAhDA4CzKIGBfqrLqXe7euY5PRZ+Zd3VAOSHpNFlHvOVhmm////////rFsRj9zL3s7EABQAAAwJNACARCxdMkUUKFFz//s0xP0AyCi5LewekmDqlyW5jMy0gd4ljek6jEgKT6387iDX//8Ejj7u3N7N1gAUcAHhy4zAUxlLX2h180ebZBgHFu3qtynyvWVOcBNH////////6wuJ3/9viChP/cze7tAAGAAA4VUUETwbg02fkaW2RCBMxYARe9hRd1j11BSN////////UF6VC928y8yw//skxPyAhwS3M+oBumC8oOg9QDcUABwAAGwVQbnBcyI6DVpEhnXRImggcfTGEednUc0UH85hY+///KgDUDl3N5t1JzC2AqVMobPWeu3sBxXRGAECOIohrvCqmrYzbyjgFw////////6JgKEOulVay7jNu7QAHAAO//skxPoABoy3OemBumDJFuc9MDdMsEWCByKmzEWnQzIp29+pDg6RNDRIuHmpe0e3WAot46qgFbQ////////qEpmSG2bq7vMsDimExWotDseTQkoYom5TE+qIcgPKo+xxedRryGorAaAL//8PJqqsuq2pnLIAGAAA//skxPgABcS3MemBumDIFuf9QCsUy3AZKFlQzJJosiyxFA+86m3N6yVDsMo0QtXl5JIGzZW//6AEjuvLDdAN2gAcAAAyHJdZcWvlgenJUY7+YDtemWT+p1DMssLON//1AZWGcAVwaHA4EAABEJLzrJF/e6xYepbx//skxPkABsC3O+7iAcCsFug9QB8Q+H4iDMRyl+LKnANTRKrelrdBBBv/ghReTJ//2f////6FiJ3h4iIeVAHtQAm5qWe8bz3Iw7koZxOu25cHuAxCUuQ7ktXO1cVEBxE5Xdx/Ibt5Siy1mJuya3z7PJXl9/Cm6U97//skxPoABoC1Qeyhp6C1Fqh9lDT04oqGA6HTGo51YrKqyJ395GSJV5TMO0Sl70znfzTAKVUXntEZu9AXoT/l////2q1qd4h3h3dQB6iADeMpEkJQI+hDkePkhTOQUWE+AcxYjtEJMouohqBH0LknyUktXYtpLZE8//skxPqAxby1PeiBWKDBlyb5l8g85MLCmgJED6rSCnDInmaVijQXurW2K6PUryClhXidI5Smi7EIIuFRMuFSVMUmVhU08485++FAIiEgaKu//9NMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//skxPyAxui3N+ymTqCvFyc5QDcUVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//sUxPyABeC3N+mBWKCgFue9ACsUVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//tUxPaABwi5J+oBumHAmmT9l4scVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//s0xPeDzhy3Jeek3CAAAD/AAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV';
    const CLICK2_B64 = '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';

    function b64ToArrayBuffer(b64) {
      const binary = atob(b64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes.buffer;
    }

    // Init audio on every play attempt until ready
    async function initAudio() {
      if (audioReady) return true;
      if (audioCtx) return false; // already trying

      log('Audio: initializing...', 'i');
      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)({
          latencyHint: 'interactive'
        });
        log('Audio: ctx state=' + audioCtx.state, 'i');

        const buf1 = b64ToArrayBuffer(CLICK1_B64);
        const buf2 = b64ToArrayBuffer(CLICK2_B64);
        log('Audio: decoded base64', 'i');

        clickBuffers[0] = await audioCtx.decodeAudioData(buf1);
        clickBuffers[1] = await audioCtx.decodeAudioData(buf2);
        const bufPage = b64ToArrayBuffer(PAGE_FINISH_B64);
        pageFinishBuffer = await audioCtx.decodeAudioData(bufPage);
        log('Audio: buffers ready ' + clickBuffers[0].duration.toFixed(3) + 's', 'i');

        audioReady = true;
        log('Audio: READY!', 'i');
        return true;
      } catch (e) {
        log('Audio: ERROR ' + e.message, 'e');
        audioCtx = null;
        return false;
      }
    }

    async function playClick() {
      if (!metronomeEnabled) return;
      if (!audioReady) {
        await initAudio();
        if (!audioReady) return;
      }
      if (audioCtx.state === 'suspended') {
        await audioCtx.resume();
      }

      const buffer = clickPattern === 0 ? clickBuffers[0] : clickBuffers[1];
      clickPattern = (clickPattern + 1) % 4;

      const source = audioCtx.createBufferSource();
      source.buffer = buffer;
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'highshelf';
      filter.frequency.value = 2000;
      filter.gain.value = -12;
      const gain = audioCtx.createGain();
      gain.gain.value = parseInt(document.getElementById('settingsVolume').value) / 100;
      source.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);
      source.start(0);
    }

    function playWordSound() { log('playWordSound called', 'i'); playClick(); }
    async function playPageFinishSound() {
      if (!audioReady) {
        await initAudio();
        if (!audioReady) return;
      }
      if (audioCtx.state === 'suspended') {
        await audioCtx.resume();
      }
      const source = audioCtx.createBufferSource();
      source.buffer = pageFinishBuffer;
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'highshelf';
      filter.frequency.value = 2000;
      filter.gain.value = -12;
      const gain = audioCtx.createGain();
      gain.gain.value = parseInt(document.getElementById('settingsVolume').value) / 100;
      source.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);
      source.start(0);
    }


    // ==================== LIBRARY SYSTEM ====================
    
    // IndexedDB setup
    const LIBRARY_DB_NAME = 'ReadingPacerLibrary';
    const LIBRARY_DB_VERSION = 1;
    let libraryDB = null;

    function openLibraryDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(LIBRARY_DB_NAME, LIBRARY_DB_VERSION);
        
        request.onerror = () => reject(request.error);
        request.onsuccess = () => {
          libraryDB = request.result;
          resolve(libraryDB);
        };
        
        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains('items')) {
            const store = db.createObjectStore('items', { keyPath: 'id' });
            store.createIndex('lastAccess', 'lastAccess', { unique: false });
          }
        };
      });
    }

    // Get library metadata from localStorage
    function getLibraryMeta() {
      try {
        return JSON.parse(localStorage.getItem('libraryMeta') || '[]');
      } catch (e) {
        return [];
      }
    }

    // Save library metadata to localStorage
    function saveLibraryMeta(meta) {
      localStorage.setItem('libraryMeta', JSON.stringify(meta));
    }

    // Generate unique ID
    function generateId() {
      return Date.now().toString(36) + Math.random().toString(36).substr(2);
    }

    // Extract name from first sentence
    function extractName(text) {
      const cleaned = text.replace(/\s+/g, ' ').trim();
      const firstSentence = cleaned.split(/[.!?]/)[0];
      return firstSentence.substring(0, 50) + (firstSentence.length > 50 ? '...' : '');
    }

    // Save item to library
    async function saveToLibrary(text, pagesData = null) {
      if (!libraryDB) await openLibraryDB();
      
      const id = generateId();
      const name = extractName(text);
      const now = Date.now();
      
      // Save heavy data to IndexedDB
      const item = {
        id,
        text,
        pages: pagesData,
        createdAt: now
      };
      
      await new Promise((resolve, reject) => {
        const tx = libraryDB.transaction('items', 'readwrite');
        const store = tx.objectStore('items');
        const request = store.put(item);
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
      
      // Save metadata to localStorage
      const meta = getLibraryMeta();
      meta.unshift({
        id,
        name,
        lastAccess: now,
        createdAt: now,
        currentIndex: 0,
        currentPage: 0,
        hasPages: !!pagesData,
        totalPages: pagesData ? pagesData.length : 1
      });
      saveLibraryMeta(meta);
      
      renderLibrary();
      return id;
    }

    // Update library item access time and position
    function updateLibraryItem(id, updates) {
      const meta = getLibraryMeta();
      const idx = meta.findIndex(m => m.id === id);
      if (idx >= 0) {
        Object.assign(meta[idx], updates, { lastAccess: Date.now() });
        // Move to top (most recent)
        const item = meta.splice(idx, 1)[0];
        meta.unshift(item);
        saveLibraryMeta(meta);
      }
    }

    // Load item from library
    async function loadFromLibrary(id) {
      if (!libraryDB) await openLibraryDB();
      
      const item = await new Promise((resolve, reject) => {
        const tx = libraryDB.transaction('items', 'readonly');
        const store = tx.objectStore('items');
        const request = store.get(id);
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
      
      if (!item) return null;
      
      const meta = getLibraryMeta().find(m => m.id === id);
      updateLibraryItem(id, {});
      
      return { ...item, meta };
    }

    // Delete item from library
    async function deleteFromLibrary(id) {
      if (!libraryDB) await openLibraryDB();
      
      // Delete from IndexedDB
      await new Promise((resolve, reject) => {
        const tx = libraryDB.transaction('items', 'readwrite');
        const store = tx.objectStore('items');
        const request = store.delete(id);
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
      
      // Delete from metadata
      const meta = getLibraryMeta().filter(m => m.id !== id);
      saveLibraryMeta(meta);
      
      // Also update cached list
      if (cachedLibraryList) {
        cachedLibraryList = cachedLibraryList.filter(m => m.id !== id);
      }
      
      renderLibrary();
    }

    // Rename library item
    function renameLibraryItem(id, newName) {
      const meta = getLibraryMeta();
      const item = meta.find(m => m.id === id);
      if (item) {
        item.name = newName;
        saveLibraryMeta(meta);
      }
    }

    // Current active library item
    let currentLibraryId = null;
    let cachedLibraryList = null;

    // Render library sidebar
    function renderLibrary() {
      const list = document.getElementById('libraryList');
      // Use cached list if available (keeps order stable while browsing)
      if (!cachedLibraryList) {
        cachedLibraryList = getLibraryMeta();
      }
      const meta = cachedLibraryList;
      
      if (meta.length === 0) {
        list.innerHTML = '<div class="library-empty">◊ê◊ô◊ü ◊§◊®◊ô◊ò◊ô◊ù ◊ë◊°◊§◊®◊ô◊ô◊î</div>';
        return;
      }
      
      list.innerHTML = meta.map(item => {
        const date = new Date(item.lastAccess).toLocaleDateString('he-IL');
        const activeClass = item.id === currentLibraryId ? 'active' : '';
        const pageInfo = item.hasPages ? ` ‚Ä¢ ◊¢◊û◊ï◊ì ${(item.currentPage || 0) + 1}/${item.totalPages || '?'}` : '';
        return `
          <div class="library-item ${activeClass}" data-id="${item.id}">
            <div class="library-item-content">
              <div class="library-item-name">${item.name}</div>
              <div class="library-item-meta">${date}${pageInfo}</div>
            </div>
            <button class="library-item-rename" title="◊©◊†◊î ◊©◊ù">‚úèÔ∏è</button>
            <button class="library-item-delete" title="◊û◊ó◊ß">üóëÔ∏è</button>
          </div>
        `;
      }).join('');
      
      // Add event listeners
      list.querySelectorAll('.library-item').forEach(el => {
        const id = el.dataset.id;
        
        // Click to load
        el.addEventListener('click', async (e) => {
          if (e.target.classList.contains('library-item-delete')) return;
          if (e.target.classList.contains('library-item-name') && 
              e.target.contentEditable === 'true') return;
          
          const item = await loadFromLibrary(id);
          if (item) {
            currentLibraryId = id;
            
            // Load the text/pages
            if (item.pages && item.pages.length > 0) {
              pages = item.pages;
              hasPages = true;
              currentPage = item.meta?.currentPage || 0;
              initCurrentPage().then(() => {
                currentIndex = item.meta?.currentIndex || 0;
                renderText();
                updateWordProgress();
              });
              document.getElementById('inputArea').style.display = 'none';
              document.getElementById('textDisplay').style.display = 'block';
              updatePageNav();
            } else {
              document.getElementById('textInput').value = item.text;
              dirtyText = item.text;
              cleanTextAsync(item.text).then(clean => {
                cleanedText = clean;
                initPacerAsync(useCleanText ? cleanedText : dirtyText).then(() => {
                  currentIndex = item.meta?.currentIndex || 0;
                  renderText();
                  updateWordProgress();
                });
              });
            }
            
            renderLibrary();
          }
        });
        
        // Double-click to rename
        const nameEl = el.querySelector('.library-item-name');
        nameEl.addEventListener('dblclick', (e) => {
          e.stopPropagation();
          nameEl.contentEditable = 'true';
          nameEl.focus();
          
          // Select all text
          const range = document.createRange();
          range.selectNodeContents(nameEl);
          const sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(range);
        });
        
        nameEl.addEventListener('blur', () => {
          nameEl.contentEditable = 'false';
          renameLibraryItem(id, nameEl.textContent.trim());
        });
        
        nameEl.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            nameEl.blur();
          }
          if (e.key === 'Escape') {
            nameEl.contentEditable = 'false';
            renderLibrary(); // Restore original name
          }
        });
        
        // Rename button
        el.querySelector('.library-item-rename').addEventListener('click', (e) => {
          e.stopPropagation();
          nameEl.contentEditable = 'true';
          nameEl.focus();
          const range = document.createRange();
          range.selectNodeContents(nameEl);
          const sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(range);
        });

        // Delete button
        el.querySelector('.library-item-delete').addEventListener('click', (e) => {
          e.stopPropagation();
          if (confirm('◊ú◊û◊ó◊ï◊ß ◊ê◊™ ◊î◊§◊®◊ô◊ò ◊û◊î◊°◊§◊®◊ô◊ô◊î?')) {
            deleteFromLibrary(id);
            if (currentLibraryId === id) currentLibraryId = null;
          }
        });
      });
    }

    // Toggle library sidebar
    function toggleLibrary() {
      const sidebar = document.getElementById('librarySidebar');
      if (sidebar.classList.contains('open')) {
        closeLibrary();
      } else {
        openLibrary();
      }
    }

    function openLibrary() {
      document.getElementById('librarySidebar').classList.add('open');
      document.getElementById('libraryOverlay').classList.add('open');
      cachedLibraryList = null; // Force refresh on open
      renderLibrary();
    }

    function closeLibrary() {
      document.getElementById('librarySidebar').classList.remove('open');
      document.getElementById('libraryOverlay').classList.remove('open');
    }

    // Library button handlers
    document.getElementById('libraryBtn').addEventListener('click', toggleLibrary);
    document.getElementById('libraryClose').addEventListener('click', closeLibrary);
    document.getElementById('libraryOverlay').addEventListener('click', closeLibrary);

    // Save current position periodically
    setInterval(() => {
      if (currentLibraryId && words.length > 0) {
        updateLibraryItem(currentLibraryId, {
          currentIndex,
          currentPage: hasPages ? currentPage : 0
        });
      }
    }, 5000);

    // Initialize library DB on load
    openLibraryDB().then(() => {
      log('Library DB initialized');
      renderLibrary();
    });

    // ==================== END LIBRARY SYSTEM ====================


    // Load visual settings on startup
    loadVisualSettings();

    // Restore opacity values from localStorage and apply colors
    const savedReadOpacity = localStorage.getItem('reading-pacer-highlight-read-opacity');
    const savedCurrentOpacity = localStorage.getItem('reading-pacer-highlight-current-opacity');
    const savedHalfBoldOpacity = localStorage.getItem('reading-pacer-halfbold-opacity');

    if (savedReadOpacity !== null) {
      document.getElementById('highlightReadOpacity').value = savedReadOpacity;
      document.getElementById('highlightReadOpacityValue').textContent = savedReadOpacity + '%';
    }
    if (savedCurrentOpacity !== null) {
      document.getElementById('highlightCurrentOpacity').value = savedCurrentOpacity;
      document.getElementById('highlightCurrentOpacityValue').textContent = savedCurrentOpacity + '%';
    }
    if (savedHalfBoldOpacity !== null) {
      document.getElementById('halfBoldColorOpacity').value = savedHalfBoldOpacity;
      document.getElementById('halfBoldColorOpacityValue').textContent = savedHalfBoldOpacity + '%';
    }

    // Restore half-bold font size
    const savedHalfBoldFontSize = localStorage.getItem('reading-pacer-halfbold-fontsize');
    if (savedHalfBoldFontSize !== null) {
      document.getElementById('halfBoldFontSize').value = savedHalfBoldFontSize;
      document.getElementById('halfBoldFontSizeValue').textContent = savedHalfBoldFontSize + '%';
      document.documentElement.style.setProperty('--half-bold-font-size', savedHalfBoldFontSize + '%');
    }

    // Apply highlight colors with opacity
    applyHighlightColors();
    applyHalfBoldColor();

    // Sync JS variables from input values (respects browser cache)
    chunkSize = parseInt(document.getElementById('chunkSizeInput').value) || 1;
    wpm = parseInt(document.getElementById('wpmInput').value) || 200;
    scrollTolerance = parseInt(document.getElementById('scrollToleranceInput').value) || 20;
    document.getElementById('chunkSize').value = chunkSize;
    document.getElementById('wpm').value = wpm;

    // Save state to localStorage
    function saveState() {
      const state = {
        text: document.getElementById('textInput').value,
        currentPage: currentPage,
        currentIndex: currentIndex,
        currentSentence: currentSentence,
        useCleanText: useCleanText,
        sentenceMode: sentenceMode
      };
      localStorage.setItem('reading-pacer-state', JSON.stringify(state));
    }

    // Restore state from localStorage
    async function restoreState() {
      const saved = localStorage.getItem('reading-pacer-state');
      if (!saved) {
        loadSampleText();
        return;
      }

      try {
        const state = JSON.parse(saved);
        if (!state.text || state.text.trim().length === 0) {
          loadSampleText();
          return;
        }

        showLoading('◊ò◊ï◊¢◊ü ◊û◊°◊û◊ö ◊ß◊ï◊ì◊ù...');

        document.getElementById('textInput').value = state.text;
        useCleanText = state.useCleanText !== undefined ? state.useCleanText : true;
        sentenceMode = state.sentenceMode || false;

        hasPages = state.text.includes('\f');

        if (hasPages) {
          await loadPagesAsync(state.text);
          if (state.currentPage !== undefined && state.currentPage < pages.length) {
            currentPage = state.currentPage;
            await initCurrentPage();
            updatePageNav();
          }
        } else {
          dirtyText = state.text;
          cleanedText = await cleanTextAsync(state.text);
          await initPacerAsync(useCleanText ? cleanedText : dirtyText);
        }

        // Restore position
        if (state.currentIndex !== undefined) {
          currentIndex = Math.min(state.currentIndex, words.length - 1);
        }
        if (state.currentSentence !== undefined) {
          currentSentence = Math.min(state.currentSentence, sentences.length - 1);
        }

        renderText();
        updateWordProgress();
        hideLoading();
        log('State restored from localStorage');
      } catch (e) {
        log('Failed to restore state: ' + e.message, 'e');
        hideLoading();
        loadSampleText();
      }
    }

    // Save state on navigation + play sounds
    const originalNextChunk = nextChunk;
    nextChunk = function() {
      const prevPage = currentPage;
      originalNextChunk();
      saveState();
      playWordSound();
    };

    const originalPrevChunk = prevChunk;
    prevChunk = function() {
      originalPrevChunk();
      saveState();
      playWordSound();
    };

    const originalGoToPage = goToPage;
    goToPage = function(pageIdx, keepAutoAdvance) {
      originalGoToPage(pageIdx, keepAutoAdvance);
      saveState();
    };

    const originalSetPosition = setPosition;
    setPosition = function(idx) {
      originalSetPosition(idx);
      saveState();
      playWordSound();
    };

    // ============================================
    // FIGURES PANEL FUNCTIONALITY
    // ============================================

    let figureImages = [];  // Array of image URLs/paths per page
    let figuresLoaded = false;
    let currentFigurePage = 0;
    let pendingPdfFile = null;  // Store PDF for image extraction after text loads

    // Toggle figures panel
    document.getElementById('figuresBtn').addEventListener('click', () => {
      const panel = document.getElementById('figuresPanel');
      const progressBar = document.getElementById('progressBar');
      panel.classList.toggle('open');
      document.body.classList.toggle('figures-panel-open', panel.classList.contains('open'));
      if (progressBar) progressBar.classList.toggle('figures-open', panel.classList.contains('open'));
      localStorage.setItem('reading-pacer-panel-open', panel.classList.contains('open'));
      if (panel.classList.contains('open') && figuresLoaded) {
        updateFiguresDisplay();
      }
    });

    function closeFiguresPanel() {
      document.getElementById('figuresPanel').classList.remove('open');
      document.body.classList.remove('figures-panel-open');
      const progressBar = document.getElementById('progressBar');
      if (progressBar) progressBar.classList.remove('figures-open');
      localStorage.setItem('reading-pacer-panel-open', 'false');
    }

    // Restore panel state
    function restorePanelState() {
      const wasOpen = localStorage.getItem('reading-pacer-panel-open') === 'true';
      if (wasOpen) {
        document.getElementById('figuresPanel').classList.add('open');
        document.body.classList.add('figures-panel-open');
        const progressBar = document.getElementById('progressBar');
        if (progressBar) progressBar.classList.add('figures-open');
      }
    }

    // Convert file to base64 data URL
    function fileToDataURL(file) {
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => resolve(null);
        reader.readAsDataURL(file);
      });
    }

    // Extract page images from PDF using PDF.js (images only, not text)
    async function extractPdfPageImages(file) {
      log('extractPdfPageImages starting', 'i');
      showLoading('◊û◊ó◊ú◊• ◊¢◊û◊ï◊ì◊ô◊ù ◊û-PDF...');

      try {
        // Set PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // Read file as ArrayBuffer
        const arrayBuffer = await file.arrayBuffer();
        log('PDF loaded into memory', 'i');

        // Load the PDF document
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        const numPages = pdf.numPages;
        log(`PDF has ${numPages} pages`, 'i');

        // Render pages to images
        figureImages = [];
        const scale = 1.5; // Render at 1.5x for decent quality

        for (let pageNum = 1; pageNum <= numPages; pageNum++) {
          showLoading(`◊û◊ó◊ú◊• ◊¢◊û◊ï◊ì ${pageNum}/${numPages}...`);
          const page = await pdf.getPage(pageNum);

          // Render page to canvas
          const viewport = page.getViewport({ scale });
          const canvas = document.createElement('canvas');
          canvas.width = viewport.width;
          canvas.height = viewport.height;
          const ctx = canvas.getContext('2d');

          await page.render({
            canvasContext: ctx,
            viewport: viewport
          }).promise;

          // Convert to data URL
          const dataUrl = canvas.toDataURL('image/jpeg', 0.8);
          figureImages.push({
            url: dataUrl,
            name: `page-${String(pageNum).padStart(2, '0')}.jpg`
          });

          log(`Page ${pageNum} rendered`, 'i');
        }

        // Setup figures
        figuresLoaded = figureImages.length > 0;
        if (figuresLoaded) {
          currentFigurePage = 0;
          updateFiguresDisplay();
          await saveFigures();

          // Open figures panel
          const panel = document.getElementById('figuresPanel');
          if (panel && !panel.classList.contains('open')) {
            panel.classList.add('open');
            document.body.classList.add('figures-panel-open');
            localStorage.setItem('reading-pacer-panel-open', 'true');
          }
        }

        hideLoading();
        log(`PDF page images extracted: ${figureImages.length} pages`, 'i');

      } catch (e) {
        hideLoading();
        log(`PDF image extraction error: ${e.message}`, 'e');
        alert('◊©◊í◊ô◊ê◊î ◊ë◊ó◊ô◊ú◊ï◊• ◊¢◊û◊ï◊ì◊ô◊ù ◊û◊î-PDF: ' + e.message);
      }
    }

    // Load figures from dropped folder or file input
    async function loadFiguresFromFiles(files) {
      log(`loadFiguresFromFiles called with ${files.length} files`, 'i');

      figureImages = [];
      const imageFiles = Array.from(files).filter(f => {
        const isImage = f.type.startsWith('image/') || /\.(png|jpg|jpeg|gif|webp)$/i.test(f.name);
        return isImage;
      });

      log(`Filtered to ${imageFiles.length} image files`, 'i');

      // Sort by filename (expecting page-01.png, page-02.png, etc.)
      imageFiles.sort((a, b) => a.name.localeCompare(b.name, undefined, {numeric: true}));

      // Convert to base64 for persistence
      for (let idx = 0; idx < imageFiles.length; idx++) {
        const file = imageFiles[idx];
        const dataUrl = await fileToDataURL(file);
        if (dataUrl) {
          figureImages[idx] = {
            url: dataUrl,
            name: file.name
          };
        }
      }

      figuresLoaded = figureImages.length > 0;
      log(`figuresLoaded = ${figuresLoaded}, count = ${figureImages.length}`, 'i');

      if (figuresLoaded) {
        // Clamp to valid range
        const textPage = typeof currentPage !== 'undefined' ? currentPage : 0;
        currentFigurePage = Math.min(textPage, figureImages.length - 1);
        currentFigurePage = Math.max(0, currentFigurePage);
        updateFiguresDisplay();
        saveFigures();
      } else {
        log('No images loaded!', 'w');
      }
    }

    // IndexedDB for large figure storage
    const DB_NAME = 'reading-pacer-db';
    const DB_VERSION = 1;
    const STORE_NAME = 'figures';

    function openDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            db.createObjectStore(STORE_NAME);
          }
        };
      });
    }

    // Save figures to IndexedDB
    async function saveFigures() {
      if (!figuresLoaded || figureImages.length === 0) return;
      try {
        const db = await openDB();
        const tx = db.transaction(STORE_NAME, 'readwrite');
        const store = tx.objectStore(STORE_NAME);
        store.put(figureImages, 'pages');
        await new Promise((resolve, reject) => {
          tx.oncomplete = resolve;
          tx.onerror = () => reject(tx.error);
        });
        db.close();
        log(`Saved ${figureImages.length} figures to IndexedDB`, 'i');
      } catch (e) {
        log(`Failed to save figures: ${e.message}`, 'e');
      }
    }

    // Restore figures from IndexedDB
    async function restoreFigures() {
      try {
        const db = await openDB();
        const tx = db.transaction(STORE_NAME, 'readonly');
        const store = tx.objectStore(STORE_NAME);
        const request = store.get('pages');

        const saved = await new Promise((resolve, reject) => {
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        });
        db.close();

        if (!saved || !Array.isArray(saved)) return;

        figureImages = saved;
        figuresLoaded = figureImages.length > 0;

        if (figuresLoaded) {
          const textPage = typeof currentPage !== 'undefined' ? currentPage : 0;
          currentFigurePage = Math.min(textPage, figureImages.length - 1);
          currentFigurePage = Math.max(0, currentFigurePage);
          updateFiguresDisplay();
          log(`Restored ${figureImages.length} figures from IndexedDB`, 'i');
        }
      } catch (e) {
        log(`Failed to restore figures: ${e.message}`, 'e');
      }
    }

    // Update figures display - show all pages as thumbnails
    function updateFiguresDisplay() {
      log(`updateFiguresDisplay called`, 'i');
      const content = document.getElementById('figuresContent');

      if (!figuresLoaded || figureImages.length === 0) {
        content.innerHTML = `
          <div class="figures-placeholder">
            <p>◊í◊®◊ï◊® ◊™◊ô◊ß◊ô◊ô◊™ ◊™◊û◊ï◊†◊ï◊™</p>
          </div>`;
        return;
      }

      // Build thumbnails for all pages
      let html = '';
      figureImages.forEach((fig, idx) => {
        const isActive = idx === currentFigurePage ? 'active' : '';
        html += `
          <div class="page-thumb ${isActive}" data-page="${idx}" onclick="goToPageFromThumb(${idx})" ondblclick="openLightbox('${fig.url}')">
            <img src="${fig.url}" alt="Page ${idx + 1}">
            <span class="page-thumb-label">${idx + 1}</span>
          </div>`;
      });

      content.innerHTML = html;
      log(`  Rendered ${figureImages.length} thumbnails`, 'i');

      // Position current page as second from top
      setTimeout(() => {
        updateActiveThumb();
      }, 50);
    }

    // Update just the active state without rebuilding
    function updateActiveThumb() {
      const thumbs = document.querySelectorAll('.page-thumb');
      const content = document.getElementById('figuresContent');

      thumbs.forEach((thumb, idx) => {
        thumb.classList.toggle('active', idx === currentFigurePage);
      });

      // Position: previous page at top, current page second
      if (currentFigurePage > 0 && thumbs.length > 1) {
        const prevThumb = thumbs[currentFigurePage - 1];
        if (prevThumb) {
          // Scroll so previous page is at the very top
          content.scrollTo({
            top: prevThumb.offsetTop - content.offsetTop,
            behavior: 'smooth'
          });
        }
      } else {
        // First page - just scroll to top
        content.scrollTo({ top: 0, behavior: 'smooth' });
      }
    }

    // Click thumbnail to navigate
    function goToPageFromThumb(pageIdx) {
      if (typeof goToPage === 'function' && hasPages) {
        goToPage(pageIdx);
      }
      currentFigurePage = pageIdx;
      updateActiveThumb();
    }

    // Lightbox with zoom/pan
    let lbZoom = 1;
    let lbPanX = 0;
    let lbPanY = 0;
    let lbDragging = false;
    let lbLastX = 0;
    let lbLastY = 0;

    function openLightbox(src) {
      const lightbox = document.getElementById('figureLightbox');
      const img = document.getElementById('lightboxImg');
      img.src = src;
      lbZoom = 1;
      lbPanX = 0;
      lbPanY = 0;
      updateLightboxTransform();
      lightbox.classList.add('active');
      lightbox.classList.remove('zoomed');
    }

    function closeLightbox() {
      const lightbox = document.getElementById('figureLightbox');
      lightbox.classList.remove('active', 'zoomed', 'dragging');
      lbZoom = 1;
      lbPanX = 0;
      lbPanY = 0;
    }

    function updateLightboxTransform() {
      const img = document.getElementById('lightboxImg');
      img.style.transform = `translate(${lbPanX}px, ${lbPanY}px) scale(${lbZoom})`;
    }

    // Zoom with scroll wheel
    document.getElementById('figureLightbox').addEventListener('wheel', (e) => {
      e.preventDefault();
      const lightbox = document.getElementById('figureLightbox');
      const img = document.getElementById('lightboxImg');
      const rect = img.getBoundingClientRect();

      // Mouse position relative to image center
      const imgCenterX = rect.left + rect.width / 2;
      const imgCenterY = rect.top + rect.height / 2;
      const mouseX = e.clientX - imgCenterX;
      const mouseY = e.clientY - imgCenterY;

      // Zoom factor
      const delta = e.deltaY > 0 ? 0.9 : 1.1;
      const newZoom = Math.max(0.5, Math.min(10, lbZoom * delta));

      // Adjust pan to zoom toward cursor
      const zoomRatio = newZoom / lbZoom;
      lbPanX = mouseX - (mouseX - lbPanX) * zoomRatio;
      lbPanY = mouseY - (mouseY - lbPanY) * zoomRatio;

      lbZoom = newZoom;
      lightbox.classList.toggle('zoomed', lbZoom > 1.05);
      updateLightboxTransform();
    }, { passive: false });

    // Pan with mouse drag
    document.getElementById('figureLightbox').addEventListener('mousedown', (e) => {
      if (lbZoom > 1.05) {
        lbDragging = true;
        lbLastX = e.clientX;
        lbLastY = e.clientY;
        document.getElementById('figureLightbox').classList.add('dragging');
        e.preventDefault();
      }
    });

    document.addEventListener('mousemove', (e) => {
      if (lbDragging) {
        lbPanX += e.clientX - lbLastX;
        lbPanY += e.clientY - lbLastY;
        lbLastX = e.clientX;
        lbLastY = e.clientY;
        updateLightboxTransform();
      }
    });

    document.addEventListener('mouseup', () => {
      if (lbDragging) {
        lbDragging = false;
        document.getElementById('figureLightbox').classList.remove('dragging');
      }
    });

    // Click to close only if not zoomed
    document.getElementById('figureLightbox').addEventListener('click', (e) => {
      if (lbZoom <= 1.05 && e.target.id === 'figureLightbox') {
        closeLightbox();
      }
    });

    // Double-click to reset zoom or close
    document.getElementById('figureLightbox').addEventListener('dblclick', () => {
      if (lbZoom > 1.05) {
        lbZoom = 1;
        lbPanX = 0;
        lbPanY = 0;
        updateLightboxTransform();
        document.getElementById('figureLightbox').classList.remove('zoomed');
      } else {
        closeLightbox();
      }
    });

    // Close lightbox on Escape
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Escape') {
        closeLightbox();
        closeFiguresPanel();
      }
    });

    // Drag & drop for figures panel
    const figuresContentEl = document.getElementById('figuresContent');
    let dragCounter = 0;

    figuresContentEl.addEventListener('dragenter', (e) => {
      e.preventDefault();
      e.stopPropagation();
      dragCounter++;
      figuresContentEl.classList.add('drag-over');
      log('Figures drag enter', 'i');
    });

    figuresContentEl.addEventListener('dragleave', (e) => {
      e.preventDefault();
      e.stopPropagation();
      dragCounter--;
      if (dragCounter === 0) {
        figuresContentEl.classList.remove('drag-over');
      }
    });

    figuresContentEl.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.stopPropagation();
      e.dataTransfer.dropEffect = 'copy';
    });

    figuresContentEl.addEventListener('drop', (e) => {
      e.preventDefault();
      e.stopPropagation();
      dragCounter = 0;
      figuresContentEl.classList.remove('drag-over');
      log('Figures drop event', 'i');

      // Handle dropped files or folder
      const items = e.dataTransfer.items;
      const droppedFiles = e.dataTransfer.files;

      // Try webkitGetAsEntry for folder support
      if (items && items.length > 0 && items[0].webkitGetAsEntry) {
        const files = [];
        const processEntry = (entry) => {
          return new Promise((resolve) => {
            if (entry.isFile) {
              entry.file(f => {
                files.push(f);
                resolve();
              }, () => resolve());
            } else if (entry.isDirectory) {
              const reader = entry.createReader();
              const readEntries = () => {
                reader.readEntries(async (entries) => {
                  if (entries.length === 0) {
                    resolve();
                  } else {
                    for (const ent of entries) {
                      await processEntry(ent);
                    }
                    readEntries(); // Continue reading (folders can have >100 entries)
                  }
                }, () => resolve());
              };
              readEntries();
            } else {
              resolve();
            }
          });
        };

        const promises = [];
        for (let i = 0; i < items.length; i++) {
          const entry = items[i].webkitGetAsEntry();
          if (entry) {
            promises.push(processEntry(entry));
          }
        }

        Promise.all(promises).then(() => {
          log(`Processed ${files.length} files from drop`, 'i');
          if (files.length > 0) {
            loadFiguresFromFiles(files);
          }
        });
      } else if (droppedFiles && droppedFiles.length > 0) {
        // Fallback: direct file drop (no folder support)
        log(`Fallback: ${droppedFiles.length} files dropped`, 'i');
        loadFiguresFromFiles(droppedFiles);
      }
    });

    // Sync figures with page changes
    const originalGoToPageForFigures = goToPage;
    goToPage = function(pageIdx, keepAutoAdvance) {
      originalGoToPageForFigures(pageIdx, keepAutoAdvance);
      if (figuresLoaded) {
        currentFigurePage = Math.min(pageIdx, figureImages.length - 1);
        if (document.getElementById('figuresPanel').classList.contains('open')) {
          updateActiveThumb();
        }
      }
    };

    // Restore state on load instead of sample text
    restoreState();

    // Init progress bar drag
    initProgressBarDrag();

    // Restore panel state and figures
    restorePanelState();
    setTimeout(restoreFigures, 100);
  </script>
</body>
</html>
